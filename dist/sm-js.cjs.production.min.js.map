{"version":3,"file":"sm-js.cjs.production.min.js","sources":["../src/exceptions.ts","../src/smDataTypes.ts","../src/dataConversions.ts","../src/queryDefinitionAdapters.ts","../node_modules/regenerator-runtime/runtime.js","../src/smQueriers.ts","../src/transaction/getMutationNameFromOperations.ts","../src/transaction/edges/utilities.ts","../src/transaction/edges/create.ts","../src/transaction/edges/drop.ts","../src/transaction/edges/replace.ts","../src/transaction/edges/update.ts","../src/transaction/convertNodeDataToSMPersistedData.ts","../src/transaction/create.ts","../src/transaction/update.ts","../src/react/context.tsx","../src/gqlClient.ts","../src/index.ts","../src/DOProxyGenerator.ts","../src/DO.ts","../src/SMQueryManager.ts","../src/transaction/transaction.ts","../src/transaction/drop.ts","../src/Repository.ts","../src/config.ts","../src/react/useSMSubscription.tsx"],"sourcesContent":["// thrown when any property on the DO is accessed but is not marked as upToDate\n// by calling DO.setUpToDateData({ [propName]: true })\n// or DO.setUpToDateData({ nested: { [propName]: true } })\n// this is done automatically by smData fetchers, smQuery and smSubscribe\n// so this error should only occur when data is accessed but was never queried or is not currently being subscribed to (is cached only)\nexport class SMNotUpToDateException extends Error {\n  public propName: string;\n\n  constructor(opts: { propName: string; nodeType: string; queryId: string }) {\n    super(\n      `SMNotUpToDate exception - The property \"${opts.propName}\" on the DO for the node type ${opts.nodeType} was read but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\n    );\n    this.propName = opts.propName;\n  }\n}\n\nexport class SMNotUpToDateInComputedException extends Error {\n  constructor(opts: {\n    computedPropName: string;\n    propName: string;\n    nodeType: string;\n    queryId: string;\n  }) {\n    super(\n      `SMNotUpToDateInComputed exception - The property \"${opts.propName}\" on the DO for the node type \"${opts.nodeType}\" was read for the computed property \"${opts.computedPropName}\" but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\n    );\n  }\n}\n\nexport class SMNotCachedException extends Error {\n  constructor(opts: { nodeType: string; id: string }) {\n    super(\n      `SMNotCached exception - Attempted to get the node with the type \"${opts.nodeType}\" and id \"${opts.id}\" but it was not cached.`\n    );\n  }\n}\n\nexport class SMDataTypeException extends Error {\n  constructor(opts: { dataType: string; value: any }) {\n    super(\n      `SMDataType exception - the data type ${opts.dataType} received a bad value. Value: \"${opts.value}\"`\n    );\n  }\n}\n\nexport class SMDataTypeExplicitDefaultException extends Error {\n  constructor(opts: { dataType: string }) {\n    super(\n      `SMDataTypeExplicitDefaultException - the data type ${opts.dataType} requires setting an explicit default value for non-optional properties`\n    );\n  }\n}\n\nexport class SMDataParsingException extends Error {\n  constructor(opts: { receivedData: any; message: string }) {\n    super(\n      `SMDataParsing exception - ${opts.message}\\nData: ${JSON.stringify(\n        opts.receivedData,\n        null,\n        2\n      )}.`\n    );\n  }\n}\n\nexport class SMUnexpectedSubscriptionMessageException extends Error {\n  public exception: {\n    subscriptionMessage: Record<string, any>;\n    description: string;\n  };\n\n  constructor(exception: {\n    subscriptionMessage: Record<string, any>;\n    description: string;\n  }) {\n    super(\n      `SMUnexpectedSubscriptionMessage exception - unexpected subscription message received`\n    );\n    this.exception = exception;\n  }\n}\n\nexport class SMUnexpectedQueryResultException extends Error {\n  public exception: {\n    queryRecord: Record<string, any>;\n    resultData: Record<string, any>;\n  };\n\n  constructor(exception: {\n    queryRecord: Record<string, any>;\n    resultData: Record<string, any>;\n  }) {\n    super(\n      `SMUnexpectedQueryResult exception - unexpected query result received`\n    );\n    this.exception = exception;\n  }\n}\n\nexport function throwLocallyLogInProd(error: Error) {\n  if (process?.env?.NODE_ENV !== 'production') {\n    throw error;\n  } else {\n    console.error(error);\n  }\n}\n","import {\n  SMDataTypeException,\n  SMDataTypeExplicitDefaultException,\n  throwLocallyLogInProd,\n} from './exceptions';\nimport {\n  GetExpectedNodeDataType,\n  GetSMDataType,\n  IByReferenceQueryBuilder,\n  IChildrenQueryBuilder,\n  ISMData,\n  ISMNode,\n  ISMQueryPagination,\n  MapFnForNode,\n  Maybe,\n  QueryDefinition,\n  SMDataDefaultFn,\n} from './types';\n\nexport const SM_DATA_TYPES = {\n  string: 's',\n  maybeString: 'mS',\n  number: 'n',\n  maybeNumber: 'mN',\n  boolean: 'b',\n  maybeBoolean: 'mB',\n  object: 'o',\n  maybeObject: 'mO',\n  record: 'r',\n  maybeRecord: 'mR',\n  array: 'a',\n  maybeArray: 'mA',\n};\n\nexport class SMData<\n  TParsedValue,\n  TSMValue,\n  TBoxedValue extends\n    | ISMData\n    | Record<string, ISMData | SMDataDefaultFn>\n    | undefined\n> implements ISMData<TParsedValue, TSMValue, TBoxedValue> {\n  type: typeof SM_DATA_TYPES[keyof typeof SM_DATA_TYPES];\n  parser: (smValue: TSMValue) => TParsedValue;\n  boxedValue: TBoxedValue;\n  defaultValue: Maybe<TParsedValue>;\n  isOptional: boolean;\n\n  constructor(opts: {\n    type: string;\n    parser: (smValue: TSMValue) => TParsedValue;\n    boxedValue?: TBoxedValue;\n    defaultValue?: TParsedValue;\n    isOptional: boolean;\n  }) {\n    this.type = opts.type;\n    this.parser = opts.parser;\n    this.boxedValue = opts.boxedValue as TBoxedValue;\n    this.defaultValue = opts.defaultValue ?? null;\n    this.isOptional = opts.isOptional;\n  }\n}\n\n/**\n * smData serve 2 purposes:\n * 1) they convert strings from SM into their real types (objects, strings, numbers, booleans)\n * 2) they serve as a way for TS to infer the data type of the node based on the smData types used,\n */\n\nexport const string = (defaultValue: string) =>\n  new SMData<string, string, undefined>({\n    type: SM_DATA_TYPES.string,\n    parser: value => (value != null ? String(value) : value),\n    defaultValue,\n    isOptional: false,\n  });\n\nstring._default = string('');\n\nstring.optional = new SMData<Maybe<string>, Maybe<string>, undefined>({\n  type: SM_DATA_TYPES.maybeString,\n  parser: value => (value != null ? String(value) : value),\n  isOptional: true,\n});\n\nexport const number = (\n  defaultValue: number\n): SMData<number, string, undefined> =>\n  new SMData<number, string, undefined>({\n    type: SM_DATA_TYPES.number,\n    parser: value => {\n      const parsed = Number(value);\n\n      if (isNaN(parsed)) {\n        throwLocallyLogInProd(\n          new SMDataTypeException({\n            dataType: SM_DATA_TYPES.number,\n            value,\n          })\n        );\n        return number._default.defaultValue as number;\n      }\n\n      return parsed;\n    },\n    defaultValue,\n    isOptional: false,\n  }) as SMData<number, string, undefined>;\n\nnumber._default = number(0);\n\nnumber.optional = new SMData<Maybe<number>, Maybe<string>, undefined>({\n  type: SM_DATA_TYPES.maybeNumber,\n  parser: value => {\n    if (value != null) {\n      return Number(value);\n    }\n    return value;\n  },\n  isOptional: true,\n});\n\nexport const boolean = <TDefaultValue extends boolean>(\n  defaultValue?: TDefaultValue\n) => {\n  if (defaultValue === undefined) {\n    return (new SMDataTypeExplicitDefaultException({\n      dataType: SM_DATA_TYPES.boolean,\n    }) as unknown) as ISMData<boolean, string | boolean, undefined>;\n  }\n\n  return new SMData<boolean, string | boolean, undefined>({\n    type: SM_DATA_TYPES.boolean,\n    parser: value => {\n      if (value === 'true' || value === true) {\n        return true;\n      } else if (value === 'false' || value === false) {\n        return false;\n      } else {\n        throw new SMDataTypeException({\n          dataType: SM_DATA_TYPES.boolean,\n          value: value,\n        });\n      }\n    },\n    defaultValue,\n    isOptional: false,\n  }) as TDefaultValue extends undefined\n    ? Error\n    : ISMData<boolean, string | boolean, undefined>;\n};\n// need this in order to trigger an error when a user doesn't provide a default\n//@ts-ignore\nboolean._default = boolean();\n\nboolean.optional = new SMData<\n  Maybe<boolean>,\n  Maybe<string | boolean>,\n  undefined\n>({\n  type: SM_DATA_TYPES.maybeBoolean,\n  parser: value => {\n    if (value == null) return value;\n\n    if (value === 'true' || value === true) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  isOptional: true,\n});\n\nexport const object = <\n  TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\n>(\n  boxedValue: TBoxedValue\n) =>\n  new SMData<\n    GetExpectedNodeDataType<TBoxedValue>,\n    GetExpectedNodeDataType<TBoxedValue>,\n    TBoxedValue\n  >({\n    type: SM_DATA_TYPES.object,\n    /**\n     * Doesn't need to do any parsing on the data to convert strings to their real types\n     * That's done by the DO class's \"objectDataSetter\" method\n     */\n    parser: val => val,\n    boxedValue,\n    isOptional: false,\n  });\n\nobject._default = null as any;\n\nobject.optional = <\n  TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\n>(\n  boxedValue: TBoxedValue\n) =>\n  new SMData<\n    Maybe<GetExpectedNodeDataType<TBoxedValue>>,\n    Maybe<GetExpectedNodeDataType<TBoxedValue>>,\n    TBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeObject,\n    /**\n     * Doesn't need to do any parsing on the data to convert strings to their real types\n     * That's done by the DO class's \"objectDataSetter\" method\n     */\n    parser: val => val,\n    boxedValue,\n    isOptional: true,\n  });\n\nexport const record = <\n  TKey extends string,\n  TBoxedValue extends ISMData | SMDataDefaultFn\n>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  return new SMData<\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.record,\n    parser: val => val,\n    boxedValue: boxedValue as typeof parsedBoxedValue,\n    isOptional: false,\n    defaultValue: {} as Record<string, any>,\n  });\n};\n\nrecord.optional = <TBoxedValue extends ISMData | SMDataDefaultFn>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  return new SMData<\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeRecord,\n    parser: val => val,\n    boxedValue: parsedBoxedValue,\n    isOptional: true,\n    defaultValue: null,\n  });\n};\n\nrecord._default = null as any;\n\nexport const array = <TBoxedValue extends ISMData | SMDataDefaultFn>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  function smArray(\n    defaultValue: Array<GetSMDataType<typeof parsedBoxedValue>>\n  ) {\n    return new SMData<\n      Array<GetSMDataType<typeof parsedBoxedValue>>,\n      Array<GetSMDataType<typeof parsedBoxedValue>>,\n      typeof parsedBoxedValue\n    >({\n      type: SM_DATA_TYPES.array,\n      parser: value => value,\n      boxedValue: parsedBoxedValue,\n      defaultValue,\n      isOptional: false,\n    });\n  }\n\n  smArray.optional = new SMData<\n    Maybe<Array<GetSMDataType<typeof parsedBoxedValue>>>,\n    Maybe<Array<GetSMDataType<typeof parsedBoxedValue>>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeArray,\n    parser: value => value,\n    boxedValue: parsedBoxedValue,\n    isOptional: true,\n  });\n\n  smArray._default = smArray([]);\n\n  return smArray;\n};\n\nexport const SM_RELATIONAL_TYPES = {\n  byReference: 'bR' as 'bR',\n  children: 'bP' as 'bP',\n};\n\nexport const reference = <\n  TParentHoldingReference extends ISMNode,\n  TReferencedNode extends ISMNode = ISMNode\n>(opts: {\n  def: TReferencedNode;\n  idProp: keyof TParentHoldingReference['smData'];\n}) => {\n  return ((queryBuilderOpts: { map: MapFnForNode<TReferencedNode> }) => {\n    return {\n      ...opts,\n      _smRelational: SM_RELATIONAL_TYPES.byReference,\n      map: queryBuilderOpts.map,\n    };\n  }) as IByReferenceQueryBuilder<TReferencedNode>;\n};\n\nexport const children = <TSMNode extends ISMNode>(opts: {\n  def: TSMNode;\n  depth?: number;\n}) => {\n  return ((queryBuilderOpts: {\n    map: MapFnForNode<TSMNode>;\n    pagination: ISMQueryPagination;\n  }) => {\n    return {\n      ...opts,\n      _smRelational: SM_RELATIONAL_TYPES.children,\n      map: queryBuilderOpts.map,\n      depth: opts.depth,\n    };\n  }) as IChildrenQueryBuilder<TSMNode>;\n};\n\nexport const OBJECT_PROPERTY_SEPARATOR = '__dot__';\n\nexport const OBJECT_IDENTIFIER = '__object__';\n\n// HACK ALERT! Exists only to make TS work the way we need it\n// It makes it possible to accept multiple node types within a record of query definitions, without losing type safety\n// See this for a simplified example https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBBwYHMA8ARAhlXAFQE8AHAUwD4AKFMNdALkQHkBbGKTASQGUYw6ADbkAwqgw58RMlQA0iAOQB9ZTADOJCr1zByAVXXlCACzET0AMXDR4YAIT3FlAJTM+A4efqS8BLVSIAN4AUIiIAE7kUCARSEEAdEl0DHIqapqyOnqGxmbiPlY2sAiOisxQESDkiAC+IfUhAlDkEcC4EDXchHAAJnB+uMFhiDC9zOqVniME6gDWE1OCDSEhdJOIUH0D0u49-YOIALzBo+NKAIwATADMigqzC0r9m2aIveTkvYp1q1CyiAAitUIsRLGApP5ZJRjohqL1dohBgEXMcYQAFXARWC4ISQmQUSirZqtdqdRAeQQiAoMfEBGGhcLhdIaALZAxGUzeBjWSAlBxOCpVchyEbhBEEZjI2SipmIACOIOIzGBrTBEOlhJWTTALTaHS6AFkQEJYDSMMNwgBtObkZWISYRTwAXXc-Cp3MkuDAxCJjXWUEQbGIADk+uRBu5jaaYOb0LDGYgQEYIpptupmInxYitgdpLKmYq1cxqEEzg9cPM6qijjDS+XNpW5tWRrUC7ihPs4BnkBZS2L3jntoMC+Ei6CS2WxhWq7Ua3Wp70Z82562XCsgA\nexport function queryDefinition<\n  TSMNode extends ISMNode,\n  TMapFn extends MapFnForNode<TSMNode> | undefined\n>(queryDefinition: QueryDefinition<TSMNode, TMapFn>) {\n  return queryDefinition;\n}\n","export const JSON_TAG = '__JSON__';\nexport const NULL_TAG = '__NULL__';\n\nexport function parseJSONFromBE(jsonString: string) {\n  if (!jsonString.startsWith(JSON_TAG)) {\n    throw Error(`parseJSONFromBE - invalid json received:\\n${jsonString}`);\n  }\n\n  // convert string array into js array\n  if (jsonString.startsWith(`${JSON_TAG}[`)) {\n    return JSON.parse(jsonString.replace('__JSON__', ''));\n  }\n\n  // Allow new line text (\\n to \\\\n)\n  // replacing prevents JSON.parse to complaining\n  return JSON.parse(jsonString.replace(JSON_TAG, '').replace(/\\n/g, '\\\\n'));\n}\n\nexport function prepareValueForFE(value: any): any {\n  if (value === NULL_TAG) {\n    return null;\n  } else if (value === 'true' || value === 'false') {\n    return value === 'true';\n  } else if (typeof value === 'string' && value.startsWith(JSON_TAG)) {\n    return parseJSONFromBE(value);\n  } else if (Array.isArray(value)) {\n    return value.map(entry => {\n      if (typeof entry === 'object') {\n        return prepareValueForFE(entry);\n      } else {\n        return entry;\n      }\n    });\n  } else if (value != null && typeof value === 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return prepareForFE(value);\n  } else {\n    return value;\n  }\n}\n\nexport function prepareForFE(beData: Record<string, any>) {\n  return Object.keys(beData).reduce((prepared, key) => {\n    const value = beData[key];\n    return {\n      ...prepared,\n      [key]: prepareValueForFE(value),\n    };\n  }, {} as Record<string, any>);\n}\n","import { gql } from '@apollo/client/core';\nimport {\n  SM_DATA_TYPES,\n  SM_RELATIONAL_TYPES,\n  OBJECT_PROPERTY_SEPARATOR,\n} from './smDataTypes';\nimport { SMUnexpectedSubscriptionMessageException } from './exceptions';\nimport {\n  NodeRelationalFns,\n  NodeRelationalQueryBuilderRecord,\n  MapFn,\n  ISMData,\n  NodeRelationalQuery,\n  ISMNode,\n  NodeComputedFns,\n  RelationalQueryRecordEntry,\n  BaseQueryRecordEntry,\n  IByReferenceQuery,\n  QueryDefinitions,\n  QueryRecord,\n  QueryRecordEntry,\n  QueryFilterEqualsKeyValue,\n} from './types';\n\nexport const PROPERTIES_QUERIED_FOR_ALL_NODES = ['id', 'version'];\n\n/**\n * Relational fns are specified when creating an smNode as fns that return a NodeRelationalQueryBuilder\n * so they can be evaluated lazily to avoid dependency loops between nodes related to each other.\n *\n * This fn executs those fns at query time, and returns a record of relational query builders\n */\nfunction getRelationalQueryBuildersFromRelationalFns(\n  relationaFns?: NodeRelationalFns<any>\n) {\n  if (!relationaFns) return {};\n\n  return Object.keys(relationaFns).reduce((acc, key) => {\n    acc[key] = relationaFns[key]();\n\n    return acc;\n  }, {} as NodeRelationalQueryBuilderRecord);\n}\n\nfunction getMapFnReturn(opts: {\n  mapFn: MapFn<any, any, any>;\n  properties: Record<string, ISMData>;\n  relational?: NodeRelationalFns<any>;\n}) {\n  const mapFnOpts: Record<string, any> = {\n    ...opts.properties,\n    ...getRelationalQueryBuildersFromRelationalFns(opts.relational),\n  };\n\n  Object.keys(opts.properties).forEach(key => {\n    const data = opts.properties[key] as ISMData;\n\n    if (\n      data.type === SM_DATA_TYPES.object ||\n      data.type === SM_DATA_TYPES.maybeObject\n    ) {\n      mapFnOpts[key] = (opts: { map: MapFn<any, any, any> }) => opts.map;\n    }\n  });\n\n  return opts.mapFn(mapFnOpts) as Record<\n    string,\n    ISMData | MapFn<any, any, any> | NodeRelationalQuery<ISMNode>\n  >;\n}\n\n/**\n * The functions in this file are responsible for translating queryDefinitionss to gql documents\n * only function that should be needed outside this file is convertQueryDefinitionToQueryInfo\n * other fns are exported for testing purposes only\n */\nfunction getQueriedProperties(opts: {\n  queryId: string;\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\n  smData: Record<string, any>;\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\n  // this optional arg is only true the first time this fn is called\n  // and is used to ensure we also query nested data that was stored in the old format (stringified json)\n  isRootLevel?: true;\n}): Array<string> {\n  const mapFnReturn = getMapFnReturn({\n    mapFn: opts.mapFn,\n    properties: opts.smData,\n    relational: opts.smRelational,\n  });\n\n  if (mapFnReturn == null) {\n    // @TODO ran into this issue when I forgot to call the query for a nested object, figure out a way to give a better error message\n    // user: useAuthenticatedOrgUserData(\n    //   ({ id, orgRole, accessLevel, preferences }) => ({\n    //     id,\n    //     orgRole,\n    //     accessLevel,\n    //     preferences: preferences({\n    //       query: ({ universityLevel }) => ({ universityLevel }), => this university level is a nested object\n    //     }),\n    //   })\n    // ),\n    throw Error(\n      `The query with the id '${opts.queryId}' has an unexpected value in the query result.`\n    );\n  }\n\n  return Object.keys(mapFnReturn).reduce(\n    (acc, key) => {\n      const isData = !!opts.smData[key];\n\n      if (!isData) return acc;\n\n      // we always query these properties, can ignore any explicit requests for it\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\n        return acc;\n      }\n\n      const data = opts.smData[key] as ISMData;\n      if (\n        data.type === SM_DATA_TYPES.object ||\n        data.type === SM_DATA_TYPES.maybeObject\n      ) {\n        // query for any data stored in old format (stringified json at the root of the node)\n        acc.push(key);\n\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\n        acc.push(\n          ...getQueriedProperties({\n            queryId: opts.queryId,\n            mapFn: mapFnReturn[key] as MapFn<any, any, any>,\n            smData: (data.boxedValue as unknown) as Record<string, ISMData>,\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\n        );\n        return acc;\n      }\n\n      return [...acc, key];\n    },\n    opts.isRootLevel\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\n      : ([] as Array<string>)\n  );\n}\n\nfunction getAllNodeProperties(opts: {\n  nodeProperties: Record<string, ISMData>;\n  isRootLevel: boolean;\n}) {\n  return Object.keys(opts.nodeProperties).reduce(\n    (acc, key) => {\n      // we are already querying these properties, can ignore any explicit requests for it\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\n        return acc;\n      }\n\n      const data = opts.nodeProperties[key] as ISMData;\n      if (\n        data.type === SM_DATA_TYPES.object ||\n        data.type === SM_DATA_TYPES.maybeObject\n      ) {\n        // query for any data stored in old format (stringified json at the root of the node)\n        acc.push(key);\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\n        acc.push(\n          ...getAllNodeProperties({\n            nodeProperties: opts.nodeProperties[key].boxedValue as Record<\n              string,\n              ISMData\n            >,\n            isRootLevel: false,\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\n        );\n        return acc;\n      }\n\n      return [...acc, key];\n    },\n    opts.isRootLevel\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\n      : ([] as Array<string>)\n  );\n}\n\nfunction getRelationalQueries(opts: {\n  queryId: string;\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\n  smData: Record<string, any>;\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\n}): Record<string, RelationalQueryRecordEntry> | undefined {\n  const mapFnReturn = getMapFnReturn({\n    mapFn: opts.mapFn,\n    properties: opts.smData,\n    relational: opts.smRelational,\n  });\n\n  const relationalQueries = Object.keys(mapFnReturn).reduce((acc, key) => {\n    const isData = !!opts.smData[key];\n    const isComputed = opts.smComputed ? !!opts.smComputed[key] : false;\n\n    if (isData || isComputed) {\n      return acc;\n    } else {\n      const relationalQuery = mapFnReturn[key] as NodeRelationalQuery<ISMNode>;\n\n      if (relationalQuery._smRelational == null) {\n        throw Error(\n          `getRelationalQueries - the key \"${key}\" is not a data property, not a computed property and does not contain a relational query.`\n        );\n      }\n\n      const mapFn = (data: any) => relationalQuery.map(data);\n\n      const relationalQueryRecord: BaseQueryRecordEntry = {\n        def: relationalQuery.def,\n        properties: getQueriedProperties({\n          queryId: opts.queryId,\n          mapFn: mapFn,\n          smData: relationalQuery.def.smData,\n          smComputed: relationalQuery.def.smComputed,\n          smRelational: relationalQuery.def.smRelational,\n          isRootLevel: true,\n        }),\n      };\n\n      const relationalQueriesWithinThisRelationalQuery = getRelationalQueries({\n        queryId: opts.queryId,\n        mapFn: mapFn,\n        smData: relationalQuery.def.smData,\n        smComputed: relationalQuery.def.smComputed,\n        smRelational: relationalQuery.def.smRelational,\n      });\n\n      if (relationalQueriesWithinThisRelationalQuery) {\n        relationalQueryRecord.relational = relationalQueriesWithinThisRelationalQuery;\n      }\n\n      const relationalType = relationalQuery._smRelational;\n      if (relationalType === SM_RELATIONAL_TYPES.byReference) {\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          byReference: true;\n        }).byReference = true;\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          idProp: string;\n        }).idProp = (relationalQuery as IByReferenceQuery<ISMNode, any>).idProp;\n      } else if (relationalType === SM_RELATIONAL_TYPES.children) {\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          children: true;\n        }).children = true;\n        if ('depth' in relationalQuery) {\n          (relationalQueryRecord as RelationalQueryRecordEntry & {\n            depth?: number;\n          }).depth = relationalQuery.depth;\n        }\n      } else {\n        throw Error(`relationalType \"${relationalType}\" is not valid.`);\n      }\n\n      acc[key] = relationalQueryRecord as RelationalQueryRecordEntry;\n      return acc;\n    }\n  }, {} as Record<string, RelationalQueryRecordEntry>);\n\n  if (Object.keys(relationalQueries).length === 0) return undefined;\n  return relationalQueries;\n}\n\nexport function getQueryRecordFromQueryDefinition(opts: {\n  queryId: string;\n  queryDefinitions: QueryDefinitions;\n}) {\n  const queryRecord: QueryRecord = {};\n\n  Object.keys(opts.queryDefinitions).forEach(queryDefinitionsAlias => {\n    const queryDefinition = opts.queryDefinitions[queryDefinitionsAlias];\n\n    let queriedProps;\n    let nodeDef;\n    let relational;\n    if (queryDefinition._isSMNodeDef) {\n      // shorthand syntax where the dev only specified a node defition, nothing else\n      nodeDef = queryDefinition as ISMNode;\n      queriedProps = getAllNodeProperties({\n        nodeProperties: nodeDef.smData,\n        isRootLevel: true,\n      });\n    } else {\n      nodeDef = queryDefinition.def;\n      if (queryDefinition.map) {\n        queriedProps = getQueriedProperties({\n          mapFn: queryDefinition.map,\n          queryId: opts.queryId,\n          smData: queryDefinition.def.smData,\n          smComputed: queryDefinition.def.smComputed,\n          smRelational: queryDefinition.def.smRelational,\n          isRootLevel: true,\n        });\n        relational = getRelationalQueries({\n          mapFn: queryDefinition.map,\n          queryId: opts.queryId,\n          smData: nodeDef.smData,\n          smComputed: nodeDef.smComputed,\n          smRelational: nodeDef.smRelational,\n        });\n      } else {\n        queriedProps = getAllNodeProperties({\n          nodeProperties: nodeDef.smData,\n          isRootLevel: true,\n        });\n      }\n    }\n\n    const queryRecordEntry = {\n      def: nodeDef,\n      properties: queriedProps,\n      relational,\n    };\n\n    if ('ids' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { ids: Array<string> }).ids =\n        queryDefinition.ids;\n    } else if ('id' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { id: string }).id =\n        queryDefinition.id;\n    } else if ('underIds' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & {\n        underIds: Array<string>;\n      }).underIds = queryDefinition.underIds;\n      if ('depth' in queryDefinition) {\n        (queryRecordEntry as QueryRecordEntry & { depth?: string }).depth =\n          queryDefinition.depth;\n      }\n    }\n\n    if ('filter' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { filter: any }).filter =\n        queryDefinition.filter;\n    }\n\n    queryRecord[queryDefinitionsAlias] = queryRecordEntry as QueryRecordEntry;\n  });\n  return queryRecord;\n}\n\nfunction getIdsString(ids: Array<string>) {\n  return `[${ids.map(id => `\"${id}\"`).join(',')}]`;\n}\n\nexport function getKeyValueFilterString<NodeType>(\n  clause: Partial<Record<keyof NodeType, string>>\n) {\n  return `{${Object.entries(clause).reduce((acc, [key, value]) => {\n    acc += `${key}: ${JSON.stringify(value)}`;\n    return acc;\n  }, '')}}`;\n}\n\nfunction getGetNodeOptions(opts: {\n  def: ISMNode;\n  underIds?: Array<string>;\n  depth?: number;\n  /** @TODO_TECH_DEBT_10_22 - https://tractiontools.atlassian.net/browse/MIO-335 */\n  filter?:\n    | Array<QueryFilterEqualsKeyValue<ISMNode>>\n    | QueryFilterEqualsKeyValue<ISMNode>;\n}) {\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\n\n  if (opts.underIds) {\n    options.push(`underIds: [${opts.underIds.map(id => `\"${id}\"`).join(',')}]`);\n  }\n\n  if (opts.depth !== null && opts.depth !== undefined) {\n    options.push(`depth: ${opts.depth}`);\n  }\n\n  if (opts.filter !== null && opts.filter !== undefined) {\n    options.push(\n      Array.isArray(opts.filter)\n        ? `filter: [${opts.filter.map(getKeyValueFilterString).join(',')}]`\n        : `filter: ${getKeyValueFilterString(opts.filter)}`\n    );\n  }\n\n  return options.join(', ');\n}\n\n// subscriptions use a slightly different set of arguments for now\n// https://tractiontools.atlassian.net/secure/RapidBoard.jspa?rapidView=53&projectKey=SMT&modal=detail&selectedIssue=SMT-636\nfunction getSubscriptionGetNodeOptions(opts: {\n  def: ISMNode;\n  under?: string;\n  depth?: number;\n}) {\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\n\n  if (opts.under) {\n    options.push(`underIds: [\"${opts.under}\"]`);\n  }\n\n  // @TODO uncomment when subscriptions support depth params\n  // if (opts.depth != null) {\n  //   options.push(`depth: ${opts.depth}`)\n  // }\n\n  return options.join(', ');\n}\n\nfunction getSpaces(numberOfSpaces: number) {\n  return new Array(numberOfSpaces).fill(' ').join('');\n}\n\nfunction getQueryPropertiesString(opts: {\n  queryRecordEntry: QueryRecordEntry | RelationalQueryRecordEntry;\n  nestLevel: number;\n}) {\n  let propsString = `\\n${getSpaces((opts.nestLevel + 2) * 2)}`;\n  propsString += opts.queryRecordEntry.properties.join(\n    `,\\n${getSpaces((opts.nestLevel + 2) * 2)}`\n  );\n\n  if (opts.queryRecordEntry.relational) {\n    propsString +=\n      (propsString !== '' ? ',' : '') +\n      getRelationalQueryString({\n        relationalQueryRecord: opts.queryRecordEntry.relational,\n        nestLevel: opts.nestLevel + 2,\n      });\n  }\n\n  return propsString;\n}\n\nfunction getRelationalQueryString(opts: {\n  relationalQueryRecord: Record<string, RelationalQueryRecordEntry>;\n  nestLevel: number;\n}) {\n  return Object.keys(opts.relationalQueryRecord).reduce((acc, alias) => {\n    const relationalQueryRecordEntry = opts.relationalQueryRecord[alias];\n\n    let operation: string;\n\n    if ('byReference' in relationalQueryRecordEntry) {\n      operation = `GetReferences(propertyNames: \"${relationalQueryRecordEntry.idProp}\")`;\n    } else if ('children' in relationalQueryRecordEntry) {\n      const depthString =\n        'depth' in relationalQueryRecordEntry\n          ? relationalQueryRecordEntry.depth !== undefined\n            ? `,depth: ${relationalQueryRecordEntry.depth}`\n            : ''\n          : '';\n      operation = `GetChildren(type: \"${relationalQueryRecordEntry.def.type}\"${depthString})`;\n    } else {\n      throw Error(\n        `relationalQueryRecordEntry is invalid\\n${JSON.stringify(\n          relationalQueryRecordEntry,\n          null,\n          2\n        )}`\n      );\n    }\n\n    return (\n      acc +\n      `\\n${getSpaces(opts.nestLevel * 2)}${alias}: ${operation} {` +\n      getQueryPropertiesString({\n        queryRecordEntry: relationalQueryRecordEntry,\n        nestLevel: opts.nestLevel,\n      }) +\n      `\\n${getSpaces(opts.nestLevel * 2)}}`\n    );\n  }, '');\n}\n\nfunction getRootLevelQueryString(\n  opts: {\n    alias: string;\n  } & QueryRecordEntry\n) {\n  let operation: string;\n  if ('ids' in opts) {\n    operation = `GetNodesByIdNew(ids: ${getIdsString(opts.ids)})`;\n  } else if ('id' in opts) {\n    operation = `GetNodesByIdNew(ids: ${getIdsString([opts.id])})`;\n  } else {\n    operation = `GetNodesNew(${getGetNodeOptions(opts)})`;\n  }\n\n  return (\n    `${opts.alias}: ${operation} {` +\n    `${getQueryPropertiesString({ queryRecordEntry: opts, nestLevel: 1 })}` +\n    `\\n${getSpaces(4)}}`\n  );\n}\n\nexport type SubscriptionConfig = {\n  alias: string;\n  gqlString: string;\n  extractNodeFromSubscriptionMessage: (\n    subscriptionMessage: Record<string, any>\n  ) => any;\n  extractOperationFromSubscriptionMessage: (\n    subscriptionMessage: Record<string, any>\n  ) => any;\n};\n\nexport function getQueryInfo(opts: {\n  queryDefinitions: QueryDefinitions;\n  queryId: string;\n}) {\n  const queryRecord: QueryRecord = getQueryRecordFromQueryDefinition(opts);\n  const queryGQLString = `\n    query ${getSanitizedQueryId({ queryId: opts.queryId })} {\n        ${Object.keys(queryRecord)\n          .map(alias =>\n            getRootLevelQueryString({\n              alias,\n              ...queryRecord[alias],\n            })\n          )\n          .join('\\n    ')}\n    }\n  `.trim();\n\n  const subscriptionConfigs: Array<SubscriptionConfig> = Object.keys(\n    queryRecord\n  ).reduce((subscriptionConfigsAcc, alias) => {\n    const subscriptionName = getSanitizedQueryId({\n      queryId: opts.queryId + '_' + alias,\n    });\n    const queryRecordEntry = queryRecord[alias];\n\n    let operations: Array<string>;\n    if ('ids' in queryRecordEntry) {\n      operations = [\n        `GetNodesById(ids: ${getIdsString(\n          queryRecordEntry.ids\n        )}, monitorChildEvents: true)`,\n      ];\n    } else if ('id' in queryRecordEntry) {\n      operations = [\n        `GetNodesById(ids: ${getIdsString([\n          queryRecordEntry.id,\n        ])}, monitorChildEvents: true)`,\n      ];\n    } else if ('underIds' in queryRecordEntry) {\n      operations = queryRecordEntry.underIds.map(underId => {\n        return `GetNodesNew(${getSubscriptionGetNodeOptions({\n          ...queryRecordEntry,\n          under: underId,\n        })}, monitorChildEvents: true)`;\n      });\n    } else {\n      operations = [\n        `GetNodesNew(${getSubscriptionGetNodeOptions(\n          queryRecordEntry\n        )}, monitorChildEvents: true)`,\n      ];\n    }\n\n    const gqlStrings = operations.map(operation => {\n      return `\n    subscription ${subscriptionName} {\n      ${alias}: ${operation} {\n        node {\n          ${getQueryPropertiesString({ queryRecordEntry, nestLevel: 5 })}\n        }\n        operation { action, path }\n      }\n    }\n        `.trim();\n    });\n\n    function extractNodeFromSubscriptionMessage(\n      subscriptionMessage: Record<string, any>\n    ) {\n      if (!subscriptionMessage[alias].node) {\n        throw new SMUnexpectedSubscriptionMessageException({\n          subscriptionMessage,\n          description: 'No \"node\" found in message',\n        });\n      }\n\n      return subscriptionMessage[alias].node;\n    }\n\n    function extractOperationFromSubscriptionMessage(\n      subscriptionMessage: Record<string, any>\n    ) {\n      if (!subscriptionMessage[alias].operation) {\n        throw new SMUnexpectedSubscriptionMessageException({\n          subscriptionMessage,\n          description: 'No \"operation\" found in message',\n        });\n      }\n\n      return subscriptionMessage[alias].operation;\n    }\n\n    gqlStrings.forEach(gqlString => {\n      subscriptionConfigsAcc.push({\n        alias,\n        gqlString,\n        extractNodeFromSubscriptionMessage,\n        extractOperationFromSubscriptionMessage,\n      });\n    });\n\n    return subscriptionConfigsAcc;\n  }, [] as Array<SubscriptionConfig>);\n\n  return {\n    subscriptionConfigs: subscriptionConfigs,\n    queryGQLString,\n    queryRecord,\n  };\n}\n\n/**\n * Converts a queryDefinitions into a gql doc that can be sent to the gqlClient\n * Returns a queryRecord for easily deduping requests based on the data that is being requested\n * Can later also be used to build a diff to request only the necessary data\n * taking into account the previous query record to avoid requesting data already in memory\n */\nexport function convertQueryDefinitionToQueryInfo(opts: {\n  queryDefinitions: QueryDefinitions;\n  queryId: string;\n}) {\n  const { queryGQLString, subscriptionConfigs, queryRecord } = getQueryInfo(\n    opts\n  );\n\n  return {\n    queryGQL: gql(queryGQLString),\n    subscriptionConfigs: subscriptionConfigs.map(subscriptionConfig => ({\n      ...subscriptionConfig,\n      gql: gql(subscriptionConfig.gqlString),\n    })),\n    queryRecord,\n  };\n}\n\nfunction getSanitizedQueryId(opts: { queryId: string }): string {\n  return opts.queryId.replace(/-/g, '_');\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import {\n  convertQueryDefinitionToQueryInfo,\n  SubscriptionConfig,\n} from './queryDefinitionAdapters';\nimport {\n  ISMJS,\n  ISMQueryManager,\n  QueryDefinitions,\n  QueryOpts,\n  QueryReturn,\n  QueryDataReturn,\n  SubscriptionOpts,\n  SubscriptionMeta,\n  SubscriptionCanceller,\n} from './types';\n\nlet queryIdx = 0;\n\n/**\n * Declared as a factory function so that \"subscribe\" can generate its own querier which shares the same query manager\n * Which ensures that the socket messages are applied to the correct base set of results\n */\nexport function generateQuerier({\n  smJSInstance,\n  queryManager,\n}: {\n  smJSInstance: ISMJS;\n  queryManager?: ISMQueryManager;\n}) {\n  return async function query<TQueryDefinitions extends QueryDefinitions>(\n    queryDefinitions: TQueryDefinitions,\n    opts?: QueryOpts<TQueryDefinitions>\n  ): Promise<QueryReturn<TQueryDefinitions>> {\n    const startStack = new Error().stack as string;\n\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\n    const { queryGQL, queryRecord } = convertQueryDefinitionToQueryInfo({\n      queryDefinitions,\n      queryId,\n    });\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    function getError(error: any) {\n      if (opts?.onError) {\n        return error;\n      } else {\n        // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n        error.stack =\n          error.stack +\n          '\\n' +\n          startStack.substring(startStack.indexOf('\\n') + 1);\n\n        return error;\n      }\n    }\n\n    if (!token) {\n      const error = getError(\n        new Error(\n          `No token registered with the name \"${tokenName}\".\\n` +\n            'Please register this token prior to using it with sm.setToken({ tokenName, token })) '\n        )\n      );\n\n      if (opts?.onError) {\n        opts.onError(error);\n        return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n      } else {\n        throw error;\n      }\n    }\n\n    return smJSInstance.gqlClient\n      .query({\n        gql: queryGQL,\n        token: token,\n        batched: opts?.batched,\n      })\n      .then((queryResult: any) => {\n        let results;\n        try {\n          const qM =\n            queryManager || new smJSInstance.SMQueryManager(queryRecord);\n          qM.onQueryResult({\n            queryId,\n            queryResult,\n          });\n\n          results = qM.getResults() as QueryDataReturn<TQueryDefinitions>;\n        } catch (e) {\n          const error = getError(\n            new Error(`Error applying query results\\n${e}`)\n          );\n\n          if (opts?.onError) {\n            opts.onError(error);\n            return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n          } else {\n            throw error;\n          }\n        }\n\n        opts?.onData && opts.onData({ results });\n        return { data: results, error: null };\n      })\n      .catch(e => {\n        const error = getError(new Error(`Error querying data\\n${e}`));\n        if (opts?.onError) {\n          opts.onError(error);\n          return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n        } else {\n          throw error;\n        }\n      });\n  };\n}\n\nexport function generateSubscriber(smJSInstance: ISMJS) {\n  return async function subscribe<\n    TQueryDefinitions extends QueryDefinitions,\n    TSubscriptionOpts extends SubscriptionOpts<TQueryDefinitions>\n  >(\n    queryDefinitions: TQueryDefinitions,\n    opts: TSubscriptionOpts\n  ): Promise<\n    TSubscriptionOpts extends { skipInitialQuery: true }\n      ? SubscriptionMeta\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta\n  > {\n    type ReturnType = TSubscriptionOpts extends {\n      skipInitialQuery: true;\n    }\n      ? SubscriptionMeta\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta;\n\n    // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n    const startStack = new Error().stack as string;\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\n    const {\n      queryGQL,\n      queryRecord,\n      subscriptionConfigs,\n    } = convertQueryDefinitionToQueryInfo({\n      queryDefinitions,\n      queryId,\n    });\n\n    opts.onQueryInfoConstructed &&\n      opts.onQueryInfoConstructed({ queryGQL, queryId });\n\n    function getError(error: any) {\n      if (opts.onError) {\n        return error;\n      } else {\n        // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n        error.stack =\n          error.stack +\n          '\\n' +\n          startStack.substring(startStack.indexOf('\\n') + 1);\n\n        return error;\n      }\n    }\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    if (!token) {\n      const error = getError(\n        new Error(\n          `No token registered with the name \"${tokenName}\".\\n` +\n            'Please register this token prior to using it with sm.setToken(tokenName, { token })) '\n        )\n      );\n      if (opts.onError) {\n        opts.onError(error);\n        return { data: {}, unsub, error } as TSubscriptionOpts extends {\n          skipInitialQuery: true;\n        }\n          ? SubscriptionMeta\n          : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta;\n      } else {\n        throw error;\n      }\n    }\n\n    const queryManager = new smJSInstance.SMQueryManager(queryRecord);\n\n    function updateQueryManagerWithSubscriptionMessage(data: {\n      message: Record<string, any>;\n      subscriptionConfig: SubscriptionConfig;\n    }) {\n      let node;\n      let operation;\n      try {\n        node = data.subscriptionConfig.extractNodeFromSubscriptionMessage(\n          data.message\n        );\n        operation = data.subscriptionConfig.extractOperationFromSubscriptionMessage(\n          data.message\n        );\n        queryManager.onSubscriptionMessage({\n          node,\n          operation,\n          queryId: queryId,\n          subscriptionAlias: data.subscriptionConfig.alias,\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error applying subscription message\\n${e}`)\n        );\n\n        if (opts.onError) {\n          opts.onError(error);\n        } else {\n          console.error(error);\n        }\n      }\n    }\n\n    let subscriptionCancellers: Array<SubscriptionCanceller> = [];\n    // Subscriptions are initialized immediately, rather than after the query resolves, to prevent an edge case where an update to a node happens\n    // while the data for that node is being transfered from SM to the client. This would result in a missed update.\n    // However, we must be careful to not call opts.onData with any subscription messages before the query resolves,\n    // because a subscription message only includes info about the node that changed, not all data being subscribed to,\n    // which means the consumer of this API would receive and incomplete data set in this edge case.\n    // This flag prevents that, by short-circuiting opts.onData in subscription messages, if the query has not resolved\n    let mustAwaitQuery = !opts.skipInitialQuery;\n    const messageQueue: Array<{\n      message: Record<string, any>;\n      subscriptionConfig: SubscriptionConfig;\n    }> = [];\n    function initSubs() {\n      try {\n        subscriptionCancellers = subscriptionConfigs.map(subscriptionConfig => {\n          return smJSInstance.gqlClient.subscribe({\n            gql: subscriptionConfig.gql,\n            token: token,\n            onMessage: message => {\n              if (mustAwaitQuery) {\n                messageQueue.push({ message, subscriptionConfig });\n                return;\n              }\n\n              updateQueryManagerWithSubscriptionMessage({\n                message,\n                subscriptionConfig,\n              });\n\n              // @TODO When called with skipInitialQuery, results should be null\n              // and we should simply expose a \"delta\" from the message\n              // probably don't need a query manager in that case either.\n              opts.onData({\n                results: queryManager.getResults() as QueryDataReturn<\n                  TQueryDefinitions\n                >,\n              });\n            },\n            onError: e => {\n              // Can never throw here. The dev consuming this would have no way of catching it\n              // To catch an error in a subscription they must provide onError\n              const error = getError(\n                new Error(`Error in a subscription message\\n${e}`)\n              );\n\n              if (opts.onError) {\n                opts.onError(error);\n              } else {\n                console.error(error);\n              }\n            },\n          });\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error initializating subscriptions\\n${e}`)\n        );\n\n        if (opts?.onError) {\n          opts.onError(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    function unsub() {\n      subscriptionCancellers.forEach(cancel => cancel());\n    }\n\n    initSubs();\n    opts.onSubscriptionInitialized && opts.onSubscriptionInitialized(unsub);\n    if (opts.skipInitialQuery) {\n      return { unsub } as ReturnType;\n    } else {\n      const query = generateQuerier({ smJSInstance, queryManager });\n      try {\n        // this query method will post its results to the queryManager declared above\n        await query(queryDefinitions, {\n          queryId: opts.queryId,\n          tokenName: opts.tokenName,\n          batched: opts.batched,\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error querying initial data set\\n${e}`)\n        );\n\n        if (opts?.onError) {\n          opts.onError(error);\n          return { data: {}, unsub, error } as ReturnType;\n        } else {\n          throw error;\n        }\n      }\n\n      if (mustAwaitQuery) {\n        mustAwaitQuery = false;\n        messageQueue.forEach(updateQueryManagerWithSubscriptionMessage);\n        messageQueue.length = 0;\n      }\n\n      const data = queryManager.getResults() as QueryDataReturn<\n        TQueryDefinitions\n      >;\n\n      opts.onData({ results: data as QueryDataReturn<TQueryDefinitions> });\n\n      return { data, unsub, error: null } as ReturnType;\n    }\n  };\n}\n","export function getMutationNameFromOperations(\n  operations: Array<{ name?: string }>,\n  fallback: string\n) {\n  const operationNames = operations\n    .filter(operation => 'name' in operation && !!operation.name)\n    .map(operation => {\n      if ('name' in operation) {\n        return operation.name;\n      } else {\n        throw Error('Expected an operation name here');\n      }\n    });\n\n  if (operationNames.length) {\n    return operationNames.join('__');\n  }\n\n  return fallback;\n}\n","import { EdgePermissions } from './types';\n\nexport function getEdgePermissionsString(permissions: EdgePermissions): string {\n  return `\n    view: ${permissions.view ? 'true' : 'false'},\n    edit: ${permissions.edit ? 'true' : 'false'},\n    manage: ${permissions.manage ? 'true' : 'false'},\n    terminate: ${permissions.terminate ? 'true' : 'false'},\n    addChild: ${permissions.addChild ? 'true' : 'false'}\n  `;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  CreateEdgeOperation,\n  CreateEdgeOpts,\n  CreateEdgesOperation,\n  EdgeProperties,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function createEdge(edge: CreateEdgeOpts): CreateEdgeOperation {\n  return {\n    type: 'createEdge',\n    ...edge,\n    smOperationName: 'AttachEdge',\n  };\n}\n\nexport function createEdges(\n  edges: CreateEdgesOperation['edges']\n): CreateEdgesOperation {\n  return {\n    type: 'createEdges',\n    smOperationName: 'AttachEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeCreateOperations(\n  operations: Array<CreateEdgeOperation | CreateEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'createEdge') {\n      return convertEdgeCreationOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'createEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeCreationOperationToMutationArguments(edge)\n      );\n    }\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeCreationOperationToMutationArguments(\n  opts: EdgeProperties & { name?: string }\n): DocumentNode {\n  const edge = `{\\ntype: \"${opts.type || 'access'}\",${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n  const name = getMutationNameFromOperations([opts], 'CreateEdge');\n\n  return gql`\n    mutation ${name} {\n        AttachEdge(\n            newSourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  DropEdgeOpts,\n  DropEdgeOperation,\n  DropEdgeProperties,\n  DropEdgesOperation,\n} from './types';\n\nexport function dropEdge(edge: DropEdgeOpts): DropEdgeOperation {\n  return {\n    type: 'dropEdge',\n    smOperationName: 'DropEdge',\n    ...edge,\n  };\n}\n\nexport function dropEdges(edges: Array<DropEdgeOpts>): DropEdgesOperation {\n  return {\n    type: 'dropEdges',\n    smOperationName: 'DropEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeDropOperations(\n  operations: Array<DropEdgeOperation | DropEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'dropEdge') {\n      return convertEdgeDropOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'dropEdges') {\n      return operation.edges.map(operation =>\n        convertEdgeDropOperationToMutationArguments({\n          ...operation.edge,\n          name: operation.name,\n        })\n      );\n    }\n\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeDropOperationToMutationArguments(\n  opts: DropEdgeProperties & { name?: string }\n): DocumentNode {\n  const name = getMutationNameFromOperations([opts], 'DropEdge');\n\n  return gql`\n    mutation ${name} {\n        DropEdge(\n            sourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edgeType: \"${opts.type || 'access'}\"\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  ReplaceEdgeOperation,\n  ReplaceEdgeOpts,\n  ReplaceEdgeProperties,\n  ReplaceEdgesOperation,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function replaceEdge(edge: ReplaceEdgeOpts): ReplaceEdgeOperation {\n  return {\n    type: 'replaceEdge',\n    smOperationName: 'ReplaceEdge',\n    ...edge,\n  };\n}\n\nexport function replaceEdges(\n  edges: Array<{\n    edge: ReplaceEdgeProperties & { name?: string };\n    onSuccess?: () => any;\n  }>\n): ReplaceEdgesOperation {\n  return {\n    type: 'replaceEdges',\n    smOperationName: 'ReplaceEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeReplaceOperations(\n  operations: Array<ReplaceEdgeOperation | ReplaceEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'replaceEdge') {\n      return convertEdgeReplaceOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'replaceEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeReplaceOperationToMutationArguments(edge)\n      );\n    }\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeReplaceOperationToMutationArguments(\n  opts: ReplaceEdgeProperties & { name?: string }\n): DocumentNode {\n  const name = getMutationNameFromOperations([opts], 'ReplaceEdge');\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n\n  return gql`\n    mutation ${name} {\n        ReplaceEdge(\n            currentSourceId: \"${opts.current}\"\n            newSourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  EdgeProperties,\n  UpdateEdgeOperation,\n  UpdateEdgeOpts,\n  UpdateEdgesOperation,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function updateEdge(edge: UpdateEdgeOpts): UpdateEdgeOperation {\n  return {\n    type: 'updateEdge',\n    smOperationName: 'UpdateEdge',\n    ...edge,\n  };\n}\n\nexport function updateEdges(\n  edges: Array<{\n    edge: EdgeProperties & { name?: string };\n    onSuccess?: () => any;\n  }>\n): UpdateEdgesOperation {\n  return {\n    type: 'updateEdges',\n    smOperationName: 'UpdateEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeUpdateOperations(\n  operations: Array<UpdateEdgeOperation | UpdateEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'updateEdge') {\n      return convertEdgeUpdateOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'updateEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeUpdateOperationToMutationArguments(edge)\n      );\n    }\n\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeUpdateOperationToMutationArguments(\n  opts: EdgeProperties & { name?: string }\n): DocumentNode {\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n  const name = getMutationNameFromOperations([opts], 'UpdateEdge');\n\n  return gql`\n    mutation ${name} {\n        UpdateEdge(\n            sourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { OBJECT_IDENTIFIER, OBJECT_PROPERTY_SEPARATOR } from '../smDataTypes';\nimport { Maybe } from '../types';\nimport { NodeData } from './types';\n\nexport const JSON_TAG = '__JSON__';\n\n/**\n * Takes the json representation of a node's data and prepares it to be sent to SM\n *\n * @param nodeData an object with arbitrary data\n * @returns stringified params ready for mutation\n */\nexport function convertNodeDataToSMPersistedData(nodeData: NodeData): string {\n  const parsedData = Object.entries(nodeData).reduce((acc, [key, value]) => {\n    if (key === 'childNodes') {\n      if (!Array.isArray(value)) {\n        throw new Error(`\"childNodes\" is supposed to be an array`);\n      }\n\n      return {\n        ...acc,\n        childNodes: value.map(item => convertNodeDataToSMPersistedData(item)),\n      };\n    }\n\n    return {\n      ...acc,\n      ...prepareForBE({ key, value }),\n    };\n  }, {} as Record<string, any>);\n\n  const stringified = Object.entries(parsedData).reduce(\n    (acc, [key, value], i) => {\n      if (i > 0) {\n        acc += '\\n';\n      }\n      if (key === 'childNodes') {\n        return acc + `${key}: [\\n{\\n${value.join('\\n}\\n{\\n')}\\n}\\n]`;\n      }\n      return acc + `${key}: ${value === null ? value : `\"${value}\"`}`;\n    },\n    ``\n  );\n\n  return stringified;\n}\n\nfunction escapeText(text: string): string {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n');\n}\n\nfunction prepareForBE(opts: {\n  key: string;\n  value: any;\n}): Record<string, Maybe<string>> {\n  if (opts.value === null) {\n    return { [opts.key]: null };\n  } else if (Array.isArray(opts.value)) {\n    return {\n      [opts.key]: `${JSON_TAG}${escapeText(JSON.stringify(opts.value))}`,\n    };\n  } else if (typeof opts.value === 'object') {\n    return prepareObjectForBE({ [opts.key]: opts.value });\n  } else if (typeof opts.value === 'string') {\n    return { [opts.key]: escapeText(opts.value) };\n  } else if (\n    typeof opts.value === 'boolean' ||\n    typeof opts.value === 'number'\n  ) {\n    if (typeof opts.value === 'number' && isNaN(opts.value)) {\n      return { [opts.key]: null };\n    }\n    return { [opts.key]: String(opts.value) };\n  } else {\n    throw Error(\n      `I don't yet know how to handle feData of type \"${typeof opts.value}\"`\n    );\n  }\n}\n\n/**\n * Takes an object node value and flattens it to be sent to SM\n *\n * @param obj an object with arbitrary data\n * @param parentKey if the value is a nested object, the key of the parent is passed in order to prepend it to the child key\n * @returns a flat object where the keys are of \"key__dot__value\" syntax\n *\n * For example:\n * ```typescript\n * const obj = {settings: {schedule: {day: 'Monday'} } }\n *  const result = prepareValueForBE(obj)\n * ```\n * The result will be:\n *  ```typescript\n *  {\n * settings: '__object__',\n * settings__dot__schedule: '__object__',\n * settings__dot__schedule__dot__day: 'Monday',\n * }\n * ```\n */\nfunction prepareObjectForBE(obj: Record<string, any>, parentKey?: string) {\n  return Object.entries(obj).reduce((acc, [key, val]) => {\n    const preparedKey = parentKey\n      ? `${parentKey}${OBJECT_PROPERTY_SEPARATOR}${key}`\n      : key;\n\n    if (typeof val === 'object' && val != null) {\n      acc[preparedKey] = OBJECT_IDENTIFIER;\n      acc = { ...acc, ...prepareObjectForBE(val, preparedKey) };\n    } else {\n      acc[preparedKey] = val;\n    }\n    return acc;\n  }, {} as Record<string, any>);\n}\n","import { gql } from '@apollo/client/core';\nimport { DocumentNode } from '../types';\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\nimport { NodeData } from './types';\n\nexport type CreateNodesOperation = {\n  type: 'createNodes';\n  smOperationName: 'CreateNodes';\n  nodes: Array<{\n    data: NodeData;\n    under?: string | Array<string>;\n    position?: number;\n    onSuccess?: (data: any) => any;\n  }>;\n  name?: string;\n};\n\nexport function createNodes(\n  operation: Omit<CreateNodesOperation, 'type' | 'smOperationName'>\n): CreateNodesOperation {\n  return {\n    type: 'createNodes',\n    smOperationName: 'CreateNodes',\n    ...operation,\n  };\n}\n\nexport type CreateNodeOperation = {\n  type: 'createNode';\n  smOperationName: 'CreateNodes';\n  data: NodeData;\n  under?: string | Array<string>;\n  name?: string;\n  position?: number;\n  onSuccess?: (data: any) => any;\n};\n\nexport function createNode(\n  operation: Omit<CreateNodeOperation, 'type' | 'smOperationName'>\n): CreateNodeOperation {\n  return {\n    type: 'createNode',\n    smOperationName: 'CreateNodes',\n    ...operation,\n  };\n}\n\nexport function getMutationsFromTransactionCreateOperations(\n  operations: Array<CreateNodeOperation | CreateNodesOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n  const allCreateNodeOperations: Array<{\n    data: NodeData;\n    under?: string | Array<string>;\n  }> = operations.flatMap(operation => {\n    if (operation.type === 'createNode') {\n      return operation;\n    } else if (operation.type === 'createNodes') {\n      return operation.nodes;\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  const name = getMutationNameFromOperations(operations, 'CreateNodes');\n\n  // For now, returns a single mutation\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\n  return [\n    gql`\n      mutation ${name} {\n        CreateNodes(\n          createOptions: [\n            ${allCreateNodeOperations\n              .map(convertCreateNodeOperationToCreateNodesMutationArguments)\n              .join('\\n')}\n          ] \n        ) {\n          id\n        }\n      }\n    `,\n  ];\n}\n\nfunction convertCreateNodeOperationToCreateNodesMutationArguments(operation: {\n  data: NodeData;\n  under?: string | Array<string>;\n}): string {\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation.data);\n  let mutationArgs: Array<string> = [\n    `node: {\n        ${dataToPersistInSM}\n      }`,\n  ];\n\n  if (operation.under) {\n    const value =\n      typeof operation.under === 'string'\n        ? `[\"${operation.under}\"]`\n        : `[\"${operation.under.join('\", \"')}\"]`;\n\n    mutationArgs.push(`underIds: ${value}`);\n  }\n\n  return `{\n    ${mutationArgs.join('\\n')}\n  }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { OBJECT_PROPERTY_SEPARATOR } from '..';\n\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\nimport { NodeData } from './types';\n\nexport type UpdateNodesOperation = {\n  type: 'updateNodes';\n  smOperationName: 'UpdateNodes';\n  nodes: Array<{\n    data: { id: string } & NodeData;\n    position?: number;\n    onSuccess?: (data: any) => any;\n  }>;\n  name?: string;\n};\n\nexport function updateNodes(\n  operation: Omit<UpdateNodesOperation, 'type' | 'smOperationName'>\n): UpdateNodesOperation {\n  return {\n    type: 'updateNodes',\n    smOperationName: 'UpdateNodes',\n    ...operation,\n  };\n}\n\nexport type UpdateNodeOperation = {\n  type: 'updateNode';\n  smOperationName: 'UpdateNodes';\n  data: { id: string } & NodeData;\n  name?: string;\n  onSuccess?: (data: any) => any;\n};\n\nexport function updateNode(\n  operation: Omit<UpdateNodeOperation, 'type' | 'smOperationName'>\n): UpdateNodeOperation {\n  return {\n    type: 'updateNode',\n    smOperationName: 'UpdateNodes',\n    ...operation,\n  };\n}\n\nfunction getPropertiesToNull(object: Record<string, any>) {\n  return Object.entries(object).reduce((acc, [key, value]) => {\n    if (value == null) acc.push(key);\n    else if (!Array.isArray(value) && typeof value === 'object') {\n      acc.push(\n        ...getPropertiesToNull(value).map(\n          property => `${key}${OBJECT_PROPERTY_SEPARATOR}${property}`\n        )\n      );\n    }\n\n    return acc;\n  }, [] as Array<string>);\n}\n\nexport function getMutationsFromTransactionUpdateOperations(\n  operations: Array<UpdateNodeOperation | UpdateNodesOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n\n  const allUpdateNodeOperations: Array<{\n    id: string;\n  } & NodeData> = operations.flatMap(operation => {\n    if (operation.type === 'updateNode') {\n      return operation.data;\n    } else if (operation.type === 'updateNodes') {\n      return operation.nodes.map(({ data }) => data);\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  const name = getMutationNameFromOperations(operations, 'UpdateNodes');\n\n  const dropPropertiesMutations = allUpdateNodeOperations.reduce(\n    (acc, updateNodeOperation) => {\n      const propertiesToNull = getPropertiesToNull(updateNodeOperation);\n      if (propertiesToNull.length) {\n        acc.push(gql`\n        mutation {\n          DropProperties(\n            nodeIds: [\"${updateNodeOperation.id}\"]\n            propertyNames: [${propertiesToNull\n              .map(prop => `\"${prop}${OBJECT_PROPERTY_SEPARATOR}*\"`)\n              .join(',')}]\n  \n          )\n          { \n            id\n          }\n      }\n      `);\n      }\n      return acc;\n    },\n    [] as Array<DocumentNode>\n  );\n\n  // For now, returns a single mutation\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\n  return [\n    gql`\n        mutation ${name} {\n          UpdateNodes(\n            nodes: [\n              ${allUpdateNodeOperations\n                .map(convertUpdateNodeOperationToUpdateNodesMutationArguments)\n                .join('\\n')}\n            ] \n          ) {\n            id\n          }\n        }\n      `,\n  ].concat(dropPropertiesMutations);\n}\n\nfunction convertUpdateNodeOperationToUpdateNodesMutationArguments(\n  operation: {\n    id: string;\n  } & NodeData\n): string {\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation);\n\n  return `{\n      ${dataToPersistInSM}\n    }`;\n}\n","import React from 'react';\nimport { SubscriptionCanceller, ISMJS, DocumentNode } from '../types';\ninterface ISMContextSubscription {\n  results?: any;\n  error?: any;\n  querying?: boolean;\n  unsub?: SubscriptionCanceller;\n  suspendPromise?: Promise<any>;\n  onResults?: (newResults: any) => void;\n  onError?: (newError: any) => void;\n  setQuerying?: (querying: boolean) => void;\n  queryInfo?: { queryGQL: DocumentNode; queryId: string };\n  lastQueryTimestamp?: number;\n}\n\ninterface ISMContext {\n  smJSInstance: ISMJS;\n  ongoingSubscriptionRecord: Record<string, ISMContextSubscription>;\n  updateSubscriptionInfo: (\n    subscriptionId: string,\n    subInfo: Partial<ISMContextSubscription>\n  ) => void;\n  scheduleCleanup: (subscriptionId: string) => void;\n  cancelCleanup: (subscriptionId: string) => void;\n}\n\nexport const SMContext = React.createContext<ISMContext>(\n  (undefined as unknown) as ISMContext\n);\n\nexport const SMProvider = (props: {\n  children: React.ReactNode;\n  smJS: ISMJS;\n  subscriptionTTLMs?: number;\n}) => {\n  const existingContext = React.useContext(SMContext);\n\n  if (existingContext) {\n    throw Error(\n      'Another instance of an SMProvider was already detected higher up the render tree.\\nHaving multiple instances of SMProviders is not supported and may lead to unexpected results.'\n    );\n  }\n\n  const ongoingSubscriptionRecord = React.useRef<\n    Record<string, ISMContextSubscription>\n  >({});\n  const cleanupTimeoutRecord = React.useRef<Record<string, NodeJS.Timeout>>({});\n\n  const updateSubscriptionInfo: ISMContext['updateSubscriptionInfo'] = React.useCallback(\n    (subscriptionId, subInfo) => {\n      ongoingSubscriptionRecord.current[subscriptionId] = {\n        ...ongoingSubscriptionRecord.current[subscriptionId],\n        ...subInfo,\n      };\n    },\n    []\n  );\n\n  const scheduleCleanup: ISMContext['scheduleCleanup'] = React.useCallback(\n    subscriptionId => {\n      function cleanup() {\n        const existingContextSubscription =\n          ongoingSubscriptionRecord.current[subscriptionId];\n        if (existingContextSubscription) {\n          existingContextSubscription.unsub &&\n            existingContextSubscription.unsub();\n          delete ongoingSubscriptionRecord.current[subscriptionId];\n        }\n      }\n\n      if (props.subscriptionTTLMs != null) {\n        cleanupTimeoutRecord.current[subscriptionId] = setTimeout(\n          cleanup,\n          props.subscriptionTTLMs\n        );\n      } else {\n        cleanup();\n      }\n    },\n    [props.subscriptionTTLMs]\n  );\n\n  const cancelCleanup: ISMContext['cancelCleanup'] = React.useCallback(\n    subscriptionId => {\n      clearTimeout(cleanupTimeoutRecord.current[subscriptionId]);\n    },\n    []\n  );\n\n  return (\n    <SMContext.Provider\n      value={{\n        smJSInstance: props.smJS,\n        ongoingSubscriptionRecord: ongoingSubscriptionRecord.current,\n        updateSubscriptionInfo,\n        scheduleCleanup,\n        cancelCleanup,\n      }}\n    >\n      {props.children}\n    </SMContext.Provider>\n  );\n};\n","import {\n  ApolloClient,\n  InMemoryCache,\n  ApolloLink,\n  Observable,\n  split,\n  gql,\n} from '@apollo/client/core';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { HttpLink } from '@apollo/client/link/http';\nimport { BatchHttpLink } from '@apollo/client/link/batch-http';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { DocumentNode, ISMGQLClient } from './types';\n\nrequire('isomorphic-fetch');\n\ninterface IGetGQLClientOpts {\n  httpUrl: string;\n  wsUrl: string;\n}\n\nexport function getGQLCLient(gqlClientOpts: IGetGQLClientOpts) {\n  const wsLink = new WebSocketLink({\n    uri: gqlClientOpts.wsUrl,\n    options: {\n      reconnect: true,\n    },\n  });\n\n  const nonBatchedLink = new HttpLink({\n    uri: gqlClientOpts.httpUrl,\n  });\n\n  const queryBatchLink = split(\n    operation => operation.getContext().batchedQuery !== false,\n    new BatchHttpLink({\n      uri: gqlClientOpts.httpUrl,\n      batchMax: 30,\n      batchInterval: 50,\n    }),\n    nonBatchedLink\n  );\n\n  const mutationBatchLink = split(\n    operation => operation.getContext().batchedMutation,\n    new BatchHttpLink({\n      uri: gqlClientOpts.httpUrl,\n      // no batch max for explicitly batched mutations\n      // to ensure transactional integrity\n      batchMax: Number.MAX_SAFE_INTEGER,\n      batchInterval: 0,\n    }),\n    queryBatchLink\n  );\n\n  const requestLink = split(\n    // split based on operation type\n    ({ query }) => {\n      const definition = getMainDefinition(query);\n      return (\n        definition.kind === 'OperationDefinition' &&\n        definition.operation === 'subscription'\n      );\n    },\n    wsLink,\n    mutationBatchLink\n  );\n\n  function getContextWithToken(opts: { token: string }) {\n    return {\n      headers: {\n        Authorization: `Bearer ${opts.token}`,\n      },\n    };\n  }\n\n  function authenticateSubscriptionDocument(opts: {\n    gql: DocumentNode;\n    token: string;\n  }) {\n    const documentBody = opts.gql.loc?.source.body;\n\n    if (!documentBody) {\n      throw new Error('No documentBody found');\n    }\n\n    const operationsThatRequireToken = [\n      'GetChildren',\n      'GetReferences',\n      'GetNodes',\n      'GetNodesNew',\n      'GetNodesById',\n    ];\n\n    if (\n      operationsThatRequireToken.some(operation =>\n        documentBody?.includes(`${operation}(`)\n      )\n    ) {\n      let documentBodyWithAuthTokensInjected = documentBody;\n\n      operationsThatRequireToken.forEach(operation => {\n        documentBodyWithAuthTokensInjected = documentBodyWithAuthTokensInjected.replace(\n          new RegExp(operation + `\\\\((.*)\\\\)`, 'g'),\n          `${operation}($1, authToken: \"${opts.token}\")`\n        );\n      });\n\n      return gql(documentBodyWithAuthTokensInjected);\n    }\n\n    return opts.gql;\n  }\n\n  const authLink = new ApolloLink(\n    (operation, forward) =>\n      new Observable(observer => {\n        let handle: ZenObservable.Subscription;\n        Promise.resolve(operation)\n          .then(() => {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n\n        return () => {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n\n  const baseClient = new ApolloClient({\n    link: ApolloLink.from([authLink, requestLink]),\n    cache: new InMemoryCache(),\n    defaultOptions: {\n      watchQuery: {\n        fetchPolicy: 'no-cache',\n        errorPolicy: 'ignore',\n      },\n      query: {\n        fetchPolicy: 'no-cache',\n        errorPolicy: 'all',\n      },\n    },\n  });\n\n  const gqlClient: ISMGQLClient = {\n    query: async opts => {\n      const { data } = await baseClient.query({\n        query: opts.gql,\n        context: {\n          batchedQuery: opts.batched != null ? opts.batched : true,\n          ...getContextWithToken({ token: opts.token }),\n        },\n      });\n\n      return data;\n    },\n    subscribe: opts => {\n      const subscription = baseClient\n        .subscribe({\n          query: authenticateSubscriptionDocument(opts),\n        })\n        .subscribe({\n          next: message => {\n            if (!message.data)\n              opts.onError(\n                new Error(`Unexpected message structure.\\n${message}`)\n              );\n            else opts.onMessage(message.data);\n          },\n          error: opts.onError,\n        });\n\n      return () => subscription.unsubscribe();\n    },\n    mutate: async opts => {\n      return await Promise.all(\n        opts.mutations.map(mutation =>\n          baseClient.mutate({\n            mutation,\n            context: {\n              batchedMutation: true,\n              ...getContextWithToken({ token: opts.token }),\n            },\n          })\n        )\n      );\n    },\n  };\n\n  return gqlClient;\n}\n","import { createDOFactory } from './DO';\nimport { createDOProxyGenerator } from './DOProxyGenerator';\nimport { RepositoryFactory } from './Repository';\nimport { generateQuerier, generateSubscriber } from './smQueriers';\nimport { createSMQueryManager } from './SMQueryManager';\nimport { createTransaction } from './transaction/transaction';\nimport {\n  ISMJS,\n  SMConfig,\n  ISMData,\n  SMDataDefaultFn,\n  NodeRelationalQueryBuilderRecord,\n  NodeMutationFn,\n  NodeDefArgs,\n  ISMNode,\n} from './types';\n\nexport * from './smDataTypes';\nexport * from './react';\nexport * from './config';\n\nexport class SMJS implements ISMJS {\n  public gqlClient: ISMJS['gqlClient'];\n  public plugins: ISMJS['plugins'];\n  public query: ISMJS['query'];\n  public subscribe: ISMJS['subscribe'];\n  public SMQueryManager: ISMJS['SMQueryManager'];\n  public transaction: ISMJS['transaction'];\n  public tokens: Record<string, string> = {};\n  public DOFactory: ISMJS['DOFactory'];\n  public DOProxyGenerator: ISMJS['DOProxyGenerator'];\n\n  constructor(config: SMConfig) {\n    this.gqlClient = config.gqlClient;\n    this.plugins = config.plugins;\n    this.query = generateQuerier({ smJSInstance: this });\n    this.subscribe = generateSubscriber(this);\n    this.DOProxyGenerator = createDOProxyGenerator(this);\n    this.DOFactory = createDOFactory(this);\n    this.SMQueryManager = createSMQueryManager(this);\n    this.transaction = createTransaction(this);\n  }\n\n  public def<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any> = {},\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord = {},\n    TNodeMutations extends Record<\n      string,\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\n    > = {}\n  >(\n    def: NodeDefArgs<\n      TNodeData,\n      TNodeComputedData,\n      TNodeRelationalData,\n      TNodeMutations\n    >\n  ): ISMNode<\n    TNodeData,\n    TNodeComputedData,\n    TNodeRelationalData,\n    TNodeMutations\n  > {\n    const DOClass = this.DOFactory(def);\n\n    return {\n      _isSMNodeDef: true,\n      do: DOClass,\n      repository: RepositoryFactory({ def, DOClass }),\n      type: def.type,\n      smData: def.properties,\n      smComputed: def.computed,\n      smRelational: def.relational,\n      smMutations: def.mutations,\n    };\n  }\n\n  public getToken(opts: { tokenName: string }): string {\n    return this.tokens[opts.tokenName];\n  }\n\n  public setToken(opts: { tokenName: string; token: string }): void {\n    this.tokens[opts.tokenName] = opts.token;\n  }\n}\n","import {\n  SMNotUpToDateException,\n  SMNotUpToDateInComputedException,\n} from './exceptions';\nimport { OBJECT_PROPERTY_SEPARATOR, SM_DATA_TYPES } from './smDataTypes';\nimport {\n  ISMJS,\n  ISMData,\n  SMDataDefaultFn,\n  IDOProxy,\n  ISMNode,\n  NodeDO,\n  Maybe,\n  RelationalQueryRecordEntry,\n} from './types';\n\nexport function createDOProxyGenerator(smJSInstance: ISMJS) {\n  /**\n   * When some data fetcher like \"useQuery\" requests some data we do not directly return the DO instances\n   * Instead, we decorate each DO instance with a bit of functionality\n   * Firstly, we add getters for relational results\n   *      For example, if I request a list of todos and an assignee for each of those todos\n   *        this proxy generator would be adding an \"assignee\" getter to each todo and\n   *        that assignee getter would return a PROXIED DO for that user\n   *\n   * Why not just store that data on the do instance directly?\n   *      For this case I just described it wouldn't be a problem, since a todo has a single assignee\n   *      But imagine a scenario in which a developer is querying for a specific meeting and all active todos in that meeting\n   *        and then lazily querying all the archived todos for that meeting.\n   *        If the developer isn't extremely careful with naming collision (activeTodos vs archivedTodos distinction, vs just calling them \"todos\")\n   *        it's easy to see how this would create a problem if both query sources are getting the same DO instance\n   *\n   *      To get around this problem, EACH REQUEST RESULT WILL RETURN ITS OWN INSTANCE OF A PROXIED DO\n   *         so naming collision is never a problem.\n   *\n   *      This also gives us the benefit of support different paging results being displayed simultaneously, since again, the relation results from different\n   *         queries will never overwrite each other.\n   *\n   *\n   * Another use for this proxy is to ensure the developer receives helpful errors when they try to read some data that is not being subscribed to\n   *      This means that if I query a list of users, request their \"firstName\" and \"id\", but then attempt to read user.lastName from the result of that query\n   *      we don't just return the cached value, or undefined, because this is likely unintentional. Most apps will want to have real time data.\n   *\n   *      Instead, we'll throw an error and tell them - hey, you tried to read this property from this node type in this query, but you didn't request it/aren't subscribed to it!\n   */\n  return function DOProxyGenerator<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any>,\n    TRelationalResults extends Record<string, Array<IDOProxy> | IDOProxy>\n  >(opts: {\n    node: ISMNode<TNodeData, TNodeComputedData>;\n    queryId: string;\n    do: NodeDO;\n    // The DOProxy protects the dev from reading a property that we haven't actually queried from SM\n    allPropertiesQueried: Array<string>;\n    relationalResults: Maybe<TRelationalResults>;\n    relationalQueries: Maybe<Record<string, RelationalQueryRecordEntry>>;\n  }): NodeDO & TRelationalResults & IDOProxy {\n    let relationalResults = opts.relationalResults;\n\n    // Casting to unknown here because we don't want type safety around structure of a node's data when building plugins\n    // but completely losing type safety in opts.node.smComputed would break the return type inference in QueryDataReturn\n    const nodeSMComputed = (opts.node.smComputed as unknown) as Record<\n      string,\n      (proxy: IDOProxy) => any\n    >;\n    const computedAccessors = nodeSMComputed\n      ? Object.keys(nodeSMComputed).reduce((acc, computedKey) => {\n          let computedFn = () => nodeSMComputed[computedKey](proxy as IDOProxy);\n          smJSInstance.plugins?.forEach(plugin => {\n            if (plugin.DOProxy?.computedDecorator) {\n              computedFn = plugin.DOProxy.computedDecorator({\n                ProxyInstance: proxy,\n                computedFn,\n              });\n            }\n          });\n\n          acc[computedKey] = computedFn;\n\n          return acc;\n        }, {} as Record<string, () => any>)\n      : {};\n\n    const proxy = new Proxy(opts.do as Record<string, any>, {\n      getOwnPropertyDescriptor: function(target, key: string) {\n        // This gives better json stringify results\n        // by preventing attempts to get properties which are not\n        // guaranteed to be up to date\n        // @TODO write tests for this enumeration\n        if (\n          opts.allPropertiesQueried.includes(key) ||\n          (opts.relationalQueries &&\n            Object.keys(opts.relationalQueries).includes(key))\n        ) {\n          return {\n            ...Object.getOwnPropertyDescriptor(target, key),\n            enumerable: true,\n            configurable: true,\n          };\n        }\n\n        return {\n          ...Object.getOwnPropertyDescriptor(target, key),\n          enumerable: false,\n        };\n      },\n      get: (target, key: string) => {\n        if (key === 'updateRelationalResults') {\n          return (newRelationalResults: Maybe<TRelationalResults>) => {\n            relationalResults = {\n              ...relationalResults,\n              ...newRelationalResults,\n            } as Maybe<TRelationalResults>;\n          };\n        }\n\n        if (\n          relationalResults &&\n          opts.relationalQueries &&\n          Object.keys(relationalResults).includes(key)\n        ) {\n          // SM returns an array when \"byReference\" is used\n          // but we only care about the first result\n          if ('byReference' in opts.relationalQueries[key]) {\n            const results = relationalResults[key];\n            if (!Array.isArray(results))\n              throw Error(`Expected results to be an array but it wasn't`);\n            return results[0];\n          }\n          return relationalResults[key];\n        }\n\n        if (Object.keys(opts.node.smData).includes(key)) {\n          if (!opts.allPropertiesQueried.includes(key)) {\n            throw new SMNotUpToDateException({\n              propName: key,\n              queryId: opts.queryId,\n              nodeType: opts.node.type,\n            });\n          }\n\n          const smDataForThisProp = opts.node.smData[key] as ISMData;\n          if (\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\n          ) {\n            // do not return an object if this prop came back as null from SM\n            if (opts.do[key] == null) return opts.do[key];\n\n            return getNestedObjectWithNotUpToDateProtection({\n              nodeType: opts.node.type,\n              queryId: opts.queryId,\n              allCachedData: opts.do[key],\n              smDataForThisObject: smDataForThisProp.boxedValue,\n              allPropertiesQueried: opts.allPropertiesQueried,\n              parentObjectKey: key,\n            });\n          }\n\n          return opts.do[key];\n        } else if (computedAccessors[key]) {\n          try {\n            return computedAccessors[key]();\n          } catch (e) {\n            if (e instanceof SMNotUpToDateException) {\n              throw new SMNotUpToDateInComputedException({\n                computedPropName: key,\n                propName: e.propName,\n                nodeType: opts.node.type,\n                queryId: opts.queryId,\n              });\n            }\n\n            throw e;\n          }\n        }\n\n        return target[key];\n      },\n    }) as NodeDO & TRelationalResults & IDOProxy;\n\n    return proxy;\n  };\n\n  function getNestedObjectWithNotUpToDateProtection(opts: {\n    nodeType: string;\n    queryId: string;\n    allCachedData: Record<string, any>;\n    smDataForThisObject: Record<string, ISMData>;\n    allPropertiesQueried: Array<string>;\n    parentObjectKey: Maybe<string>;\n  }) {\n    const objectToReturn = {};\n\n    Object.keys(opts.smDataForThisObject).forEach(objectProp => {\n      const name = opts.parentObjectKey\n        ? `${opts.parentObjectKey}${OBJECT_PROPERTY_SEPARATOR}${objectProp}`\n        : objectProp;\n      const smDataForThisProp = opts.smDataForThisObject[objectProp];\n      const isUpToDate =\n        opts.allPropertiesQueried.includes(name) ||\n        // this second case handles ensuring that nested objects are enumerable\n        // for example, if user matches the interface { address: { apt: { floor: number, unit: number } } }\n        // and we request address_apt_floor and address_apt_unit\n        // we need to make address.apt enumerable below\n        opts.allPropertiesQueried.some(prop => prop.startsWith(name));\n\n      Object.defineProperty(objectToReturn, objectProp, {\n        // @TODO write tests for this enumeration\n        enumerable: isUpToDate,\n        get: () => {\n          if (\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\n          ) {\n            if (opts.allCachedData[objectProp] == null)\n              return opts.allCachedData[objectProp];\n\n            return getNestedObjectWithNotUpToDateProtection({\n              nodeType: opts.nodeType,\n              queryId: opts.queryId,\n              allCachedData: opts.allCachedData[objectProp],\n              smDataForThisObject: smDataForThisProp.boxedValue,\n              allPropertiesQueried: opts.allPropertiesQueried,\n              parentObjectKey: name,\n            });\n          }\n\n          if (!isUpToDate) {\n            throw new SMNotUpToDateException({\n              propName: name,\n              nodeType: opts.nodeType,\n              queryId: opts.queryId,\n            });\n          }\n\n          return opts.allCachedData\n            ? opts.allCachedData[objectProp]\n            : undefined;\n        },\n      });\n    });\n\n    return objectToReturn;\n  }\n}\n","import { SMData, SM_DATA_TYPES } from './smDataTypes';\nimport {\n  ISMJS,\n  ISMData,\n  SMDataDefaultFn,\n  NodeRelationalQueryBuilderRecord,\n  NodeMutationFn,\n  NodeDO,\n  NodeComputedFns,\n  NodeRelationalFns,\n  DeepPartial,\n  NodeRelationalQueryBuilder,\n  ISMNode,\n} from './types';\n\nexport function createDOFactory(smJSInstance: ISMJS) {\n  /**\n   * Returns a DO class, since there is one instance of the DO class\n   * for each instance of that node type that is fetched from SM\n   */\n  return function DOFactory<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any>,\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\n    TNodeMutations extends Record<\n      string,\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\n    >,\n    TDOClass = new (initialData?: Record<string, any>) => NodeDO\n  >(node: {\n    type: string;\n    properties: TNodeData;\n    computed?: NodeComputedFns<TNodeData, TNodeComputedData>;\n    relational?: NodeRelationalFns<TNodeRelationalData>;\n    mutations?: TNodeMutations;\n  }): TDOClass {\n    // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\n    // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\n    // eslint-disable-next-line\n    // @ts-ignore\n    return class DO implements TDOClass {\n      public parsedData: DeepPartial<TNodeData>;\n      public version: number = -1;\n      private _defaults: Record<keyof TNodeData, any>;\n      private _persistedData: Record<string, any> = {};\n\n      constructor(initialData?: DeepPartial<TNodeData> & { version: number }) {\n        this._defaults = this.getDefaultData(node.properties);\n        if (initialData?.version) {\n          this.version = Number(initialData.version);\n        }\n\n        if (initialData) {\n          this._persistedData = this.parseReceivedData({\n            initialData,\n            nodeProperties: node.properties,\n          });\n        }\n\n        this.parsedData = this.getParsedData({\n          smData: node.properties,\n          persistedData: this._persistedData,\n          defaultData: this._defaults,\n        });\n\n        smJSInstance.plugins?.forEach(plugin => {\n          if (plugin.DO?.onConstruct) {\n            plugin.DO.onConstruct({\n              DOInstance: this,\n              parsedDataKey: 'parsedData',\n            });\n          }\n        });\n\n        this.initializeNodePropGettersAndSetters();\n        this.initializeNodeComputedGetters();\n        this.initializeNodeRelationalGetters();\n        this.initializeNodeMutations();\n      }\n\n      private parseReceivedData(opts: {\n        initialData: Record<string, any>;\n        nodeProperties: typeof node.properties;\n      }) {\n        const { initialData, nodeProperties } = opts;\n\n        return Object.entries(nodeProperties).reduce(\n          (acc, [propName, propValue]) => {\n            const property = this.getSMData(propValue);\n\n            const propExistsInInitialData =\n              propName in initialData && initialData[propName] != null;\n\n            if (this.isObjectType(property.type) && propExistsInInitialData) {\n              acc[propName] = this.parseReceivedData({\n                initialData: initialData[propName],\n                nodeProperties: property.boxedValue,\n              });\n            } else if (\n              this.isArrayType(property.type) &&\n              propExistsInInitialData\n            ) {\n              acc[propName] = initialData[propName].map(\n                property.boxedValue.parser\n              );\n            } else if (\n              propName in initialData &&\n              initialData[propName] === null\n            ) {\n              acc[propName] = null;\n            } else if (propExistsInInitialData) {\n              acc[propName] = property.parser(initialData[propName]);\n            }\n\n            return acc;\n          },\n          {} as Record<string, any>\n        );\n      }\n\n      private getDefaultData = (\n        nodePropertiesOrSMData:\n          | typeof node.properties\n          | SMData<any, any, any>\n          | ((_default: any) => SMData<any, any, any>)\n      ): Record<keyof TNodeData, any> => {\n        if (nodePropertiesOrSMData instanceof SMData) {\n          if (this.isObjectType(nodePropertiesOrSMData.type)) {\n            return this.getDefaultData(nodePropertiesOrSMData.boxedValue);\n          }\n          return nodePropertiesOrSMData.defaultValue;\n        }\n\n        const getDefaultFnValue = (\n          propName?: keyof TNodeData,\n          defaultSMData?: ISMData\n        ) => {\n          const defaultFn =\n            defaultSMData ||\n            ((nodePropertiesOrSMData as TNodeData)[\n              propName as keyof TNodeData\n            ] as any)._default;\n\n          // if a boolean dataType is not passed a default value, it returns an error. We throw it here\n          if (defaultFn instanceof Error) {\n            throw defaultFn;\n          }\n\n          // if array type, we need to set the default value as an array containing the parent type's boxedValue\n          if (this.isArrayType(defaultFn.type)) {\n            if (this.isObjectType(defaultFn.boxedValue.type)) {\n              return [this.getDefaultData(defaultFn.boxedValue.boxedValue)];\n            }\n            return [defaultFn.boxedValue.defaultValue];\n          }\n\n          return defaultFn.defaultValue;\n        };\n\n        if (typeof nodePropertiesOrSMData === 'function') {\n          return getDefaultFnValue(\n            undefined,\n            (nodePropertiesOrSMData as any)._default as ISMData\n          );\n        }\n\n        return Object.keys(nodePropertiesOrSMData).reduce(\n          (acc, prop: keyof TNodeData) => {\n            const propValue = nodePropertiesOrSMData[prop] as ISMData;\n            if (\n              this.isObjectType(propValue.type) ||\n              this.isRecordType(propValue.type)\n            ) {\n              acc[prop] = this.getDefaultData(propValue.boxedValue);\n            } else if (typeof propValue === 'function') {\n              const defaultValue = getDefaultFnValue(prop);\n\n              acc[prop] = defaultValue;\n            } else {\n              acc[prop] = (nodePropertiesOrSMData[\n                prop\n              ] as ISMData).defaultValue;\n            }\n            return acc;\n          },\n          {} as Record<keyof TNodeData, any>\n        );\n      };\n\n      private getParsedData(opts: {\n        smData: ISMData | Record<string, ISMData | SMDataDefaultFn>; // because it can be a single value (sm.number, sm.string, sm.boolean, sm.array, sm.record) or an object (root node data, nested objects)\n        persistedData: any;\n        defaultData: any;\n      }) {\n        if (\n          opts.smData instanceof SMData &&\n          opts.smData.isOptional &&\n          opts.persistedData == null\n        ) {\n          return null;\n        }\n\n        const property = this.getSMData(opts.smData as ISMData);\n\n        if (property instanceof SMData && property.boxedValue) {\n          // sm.array, sm.object or sm.record\n          if (this.isArrayType(property.type)) {\n            if (opts.persistedData) {\n              return (opts.persistedData || []).map((data: any) => {\n                return this.getParsedData({\n                  smData: property.boxedValue,\n                  persistedData: data,\n                  defaultData:\n                    property.type === SM_DATA_TYPES.array\n                      ? opts.defaultData?.[0] || null // If property is a non-optional array and the boxed value is of type sm.object, the default data for an array should be an array with a single item, where that item is the default data for that object\n                      : null,\n                });\n              });\n            } else {\n              return opts.defaultData;\n            }\n          } else {\n            // sm.object, sm.record\n            // safe to assume that if we made it this far, the expected data type is object and it's non optional, so lets default it to {}\n            if (!opts.persistedData) {\n              opts.persistedData = {};\n            }\n\n            const boxedValueSMProperty = this.getSMData(property.boxedValue);\n\n            if (boxedValueSMProperty instanceof SMData) {\n              // sm.record\n              return Object.keys(opts.persistedData).reduce((acc, key) => {\n                acc[key] = this.getParsedData({\n                  smData: property.boxedValue,\n                  persistedData: opts.persistedData[key],\n                  defaultData: opts.defaultData, //opts.defaultData,\n                }); // no default value for values in a record\n                return acc;\n              }, {} as Record<string, any>);\n            } else {\n              // if we're dealing with an object, lets loop over the keys in its boxed value\n              return Object.keys(property.boxedValue).reduce((acc, key) => {\n                acc[key] = this.getParsedData({\n                  smData: property.boxedValue[key],\n                  persistedData: opts.persistedData[key],\n                  defaultData: opts.defaultData?.[key],\n                });\n                return acc;\n              }, {} as Record<string, any>);\n            }\n          }\n        } else if (property instanceof SMData) {\n          // sm.string, sm.boolean, sm.number\n          if (opts.persistedData != null) {\n            return property.parser(opts.persistedData);\n          }\n\n          return opts.defaultData;\n        } else {\n          // root of node, simply loop over keys of data definition and call this function recursively\n          return Object.keys(property).reduce((acc, prop) => {\n            acc[prop] = this.getParsedData({\n              // @ts-ignore\n              smData: property[prop],\n              persistedData: opts.persistedData[prop],\n              defaultData: opts.defaultData[prop],\n            });\n            return acc;\n          }, {} as Record<string, any>);\n        }\n      }\n\n      public onDataReceived = (receivedData: DeepPartial<TNodeData>) => {\n        if (receivedData.version == null) {\n          throw Error('Message received for a node was missing a version');\n        }\n\n        const { version, ...restReceivedData } = receivedData;\n        const newVersion = Number(version);\n\n        if (newVersion >= this.version) {\n          this.version = newVersion;\n\n          const newData = this.parseReceivedData({\n            initialData: restReceivedData,\n            nodeProperties: node.properties,\n          });\n\n          this.extendPersistedWithNewlyReceivedData({\n            smData: node.properties,\n            object: this._persistedData,\n            extension: newData,\n          });\n\n          this.parsedData = this.getParsedData({\n            smData: node.properties,\n            persistedData: this._persistedData,\n            defaultData: this._defaults,\n          });\n        }\n      };\n\n      private extendPersistedWithNewlyReceivedData(opts: {\n        smData: Record<string, ISMData | SMDataDefaultFn>;\n        object: Record<string, any>;\n        extension: Record<string, any>;\n      }) {\n        Object.entries(opts.extension).forEach(([key, value]) => {\n          const smDataForThisProp = this.getSMData(opts.smData[key]);\n\n          // if this is a record, completely overwrite the stored persisted data\n          if (this.isRecordType(smDataForThisProp.type)) {\n            opts.object[key] = value;\n          } else {\n            // if it's an object, extend the persisted data we've received so far with the newly received data\n            if (this.isObjectType(smDataForThisProp.type)) {\n              if (value == null) {\n                opts.object[key] = null;\n              } else {\n                opts.object[key] = opts.object[key] || {};\n\n                this.extendPersistedWithNewlyReceivedData({\n                  smData: smDataForThisProp.boxedValue,\n                  object: opts.object[key],\n                  extension: value,\n                });\n              }\n            } else {\n              // otherwise no need to extend, simply overwrite the value\n              opts.object[key] = value;\n            }\n          }\n        });\n      }\n\n      /**\n       * initializes getters and setters for properties that are stored on this node in SM\n       * as properties on this DO instance\n       */\n      private initializeNodePropGettersAndSetters() {\n        Object.keys(node.properties).forEach(prop => {\n          const property = this.getSMData(node.properties[prop]);\n\n          if (this.isObjectType(property.type)) {\n            this.setObjectProp(prop);\n          } else if (this.isArrayType(property.type)) {\n            this.setArrayProp(prop);\n          } else {\n            this.setPrimitiveValueProp(prop);\n          }\n        });\n      }\n\n      private initializeNodeComputedGetters() {\n        const computedData = node.computed;\n        if (computedData) {\n          Object.keys(computedData).forEach(computedProp => {\n            this.setComputedProp({\n              propName: computedProp,\n              computedFn: computedData[computedProp] as (\n                data: Record<string, any>\n              ) => any,\n            });\n          });\n        }\n      }\n\n      private initializeNodeRelationalGetters() {\n        const relationalData = node.relational;\n        if (relationalData) {\n          Object.keys(relationalData).forEach(relationalProp => {\n            this.setRelationalProp({\n              propName: relationalProp,\n              relationalQueryGetter: relationalData[\n                relationalProp\n              ] as () => NodeRelationalQueryBuilder<\n                ISMNode<TNodeData, TNodeComputedData, TNodeRelationalData>\n              >,\n            });\n          });\n        }\n      }\n\n      private initializeNodeMutations() {\n        const mutations = node.mutations;\n        if (mutations) {\n          Object.keys(mutations).forEach(mutationName => {\n            Object.defineProperty(this, mutationName, {\n              get: () => mutations[mutationName].bind(this),\n            });\n          });\n        }\n      }\n\n      /**\n       * Object type props have different getters and setters than non object type\n       * because when an object property is set we extend the previous value, instead of replacing its reference entirely (we've seen great performance gains doing this)\n       */\n      private setObjectProp = (propNameForThisObject: string) => {\n        Object.defineProperty(this, propNameForThisObject, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propNameForThisObject];\n          },\n        });\n      };\n\n      private setPrimitiveValueProp = (propName: string) => {\n        Object.defineProperty(this, propName, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propName];\n          },\n        });\n      };\n\n      private setArrayProp = (propName: string) => {\n        Object.defineProperty(this, propName, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propName];\n          },\n        });\n      };\n\n      private setComputedProp(opts: {\n        propName: string;\n        computedFn: (nodeData: Record<string, any>) => any;\n      }) {\n        let computedGetter = () => opts.computedFn(this);\n        smJSInstance.plugins?.forEach(plugin => {\n          if (plugin.DO?.computedDecorator) {\n            computedGetter = plugin.DO.computedDecorator({\n              computedFn: computedGetter,\n              DOInstance: this,\n            });\n          }\n        });\n\n        Object.defineProperty(this, opts.propName, {\n          get: () => computedGetter(),\n          enumerable: true,\n        });\n      }\n\n      private setRelationalProp(opts: {\n        propName: string;\n        relationalQueryGetter: () => NodeRelationalQueryBuilder<\n          ISMNode<TNodeData, TNodeComputedData, TNodeRelationalData>\n        >;\n      }) {\n        Object.defineProperty(this, opts.propName, {\n          configurable: true,\n          get: () => {\n            return opts.relationalQueryGetter();\n          },\n        });\n      }\n\n      private getSMData(prop: ISMData<any, any, any> | SMDataDefaultFn) {\n        if (typeof prop === 'function') {\n          return (prop as any)._default as ISMData;\n        }\n        return prop as ISMData;\n      }\n\n      private isArrayType(type: string) {\n        return (\n          type === SM_DATA_TYPES.array || type === SM_DATA_TYPES.maybeArray\n        );\n      }\n\n      private isObjectType(type: string) {\n        return (\n          type === SM_DATA_TYPES.object || type === SM_DATA_TYPES.maybeObject\n        );\n      }\n\n      private isRecordType(type: string) {\n        return (\n          type === SM_DATA_TYPES.record || type === SM_DATA_TYPES.maybeRecord\n        );\n      }\n    };\n  };\n}\n","import { SMDataParsingException } from './exceptions';\nimport {\n  IDOProxy,\n  Maybe,\n  ISMJS,\n  ISMQueryManager,\n  QueryRecord,\n  BaseQueryRecordEntry,\n  RelationalQueryRecordEntry,\n} from './types';\n\ntype SMQueryManagerState = Record<\n  string, // the alias for this set of results\n  SMQueryManagerStateEntry\n>;\n\ntype SMQueryManagerStateEntry = {\n  // which id or ids represent the most up to date results for this alias, used in conjunction with proxyCache to build a returned data set\n  idsOrIdInCurrentResult: string | Array<string>;\n  proxyCache: SMQueryManagerProxyCache;\n};\n\ntype SMQueryManagerProxyCache = Record<\n  string, // id of the node\n  SMQueryManagerProxyCacheEntry\n>;\n\ntype SMQueryManagerProxyCacheEntry = {\n  proxy: IDOProxy;\n  relationalState: Maybe<SMQueryManagerState>;\n}; // the proxy for that DO and relational state from the query results/latest subscription message\n\nexport function createSMQueryManager(smJSInstance: ISMJS) {\n  /**\n   * SMQueryManager is in charge of\n   *\n   *    1) receiving data from an SM query and notifying the appropriate DO repositories\n   *    2) building proxies for those DOs\n   *    3) keeping a cache of those generated proxies so that we can update proxies on subscription messages, rather than generating new ones\n   *    4) handling incoming SM subscription messages and\n   *       4.1) notifying DO repositories with the data in those sub messages\n   *       4.2) build proxies for new DOs received + update relational data (recursively) for proxies that had been previously built\n   *    5) building the resulting data that is returned by useSMQuery from its cache of proxies\n   */\n  return class SMQueryManager implements ISMQueryManager {\n    public state: SMQueryManagerState = {};\n    public queryRecord: QueryRecord;\n\n    constructor(queryRecord: QueryRecord) {\n      this.queryRecord = queryRecord;\n    }\n\n    public onQueryResult(opts: { queryResult: any; queryId: string }) {\n      this.notifyRepositories({\n        data: opts.queryResult,\n        queryRecord: this.queryRecord,\n      });\n\n      this.state = this.getNewStateFromQueryResult(opts);\n    }\n\n    public onSubscriptionMessage(opts: {\n      node: Record<string, any>;\n      operation: {\n        action: 'UpdateNode' | 'DeleteNode' | 'InsertNode';\n        path: string;\n      };\n      queryId: string;\n      subscriptionAlias: string;\n    }) {\n      const { node, operation, subscriptionAlias } = opts;\n      const queryRecordEntryForThisSubscription = this.queryRecord[\n        subscriptionAlias\n      ];\n\n      if (operation.action === 'DeleteNode' && operation.path === node.id) {\n        const idsOrIdInCurrentResult = this.state[opts.subscriptionAlias]\n          .idsOrIdInCurrentResult;\n        if (Array.isArray(idsOrIdInCurrentResult)) {\n          this.state[\n            opts.subscriptionAlias\n          ].idsOrIdInCurrentResult = idsOrIdInCurrentResult.filter(\n            id => id !== node.id\n          );\n        }\n\n        return;\n      }\n\n      this.notifyRepositories({\n        data: {\n          [subscriptionAlias]: node,\n        },\n        queryRecord: {\n          [subscriptionAlias]: queryRecordEntryForThisSubscription,\n        },\n      });\n\n      this.updateProxiesAndStateFromSubscriptionMessage(opts);\n    }\n\n    /**\n     * Returns the current results based on received query results and subscription messages\n     */\n    getResults() {\n      return this.getResultsFromState(this.state);\n    }\n\n    /**\n     * Is used to build the overall results for the query, and also to build the relational results used by each proxy\n     * which is why \"state\" is a param here\n     */\n    public getResultsFromState(\n      state: SMQueryManagerState\n    ): Record<string, any> {\n      return Object.keys(state).reduce((resultsAcc, queryAlias) => {\n        const stateForThisAlias = state[queryAlias];\n        const idsOrId = stateForThisAlias.idsOrIdInCurrentResult;\n        resultsAcc[queryAlias] = Array.isArray(idsOrId)\n          ? idsOrId.map(id => stateForThisAlias.proxyCache[id].proxy)\n          : stateForThisAlias.proxyCache[idsOrId].proxy;\n\n        return resultsAcc;\n      }, {} as Record<string, any>);\n    }\n\n    /**\n     * Takes a queryRecord and the data that resulted from that query\n     * notifies the appropriate repositories so that DOs can be constructed or updated\n     */\n    public notifyRepositories(opts: {\n      data: Record<string, any>;\n      queryRecord: { [key: string]: BaseQueryRecordEntry };\n    }) {\n      Object.keys(opts.queryRecord).forEach(queryAlias => {\n        const dataForThisAlias = opts.data[queryAlias];\n\n        if (!dataForThisAlias) {\n          throw Error(\n            `notifyRepositories could not find resulting data for the alias \"${queryAlias}\" in the following queryRecord:\\n${JSON.stringify(\n              opts.queryRecord,\n              null,\n              2\n            )}\\nResulting data:\\n${JSON.stringify(opts.data, null, 2)}`\n          );\n        }\n\n        const nodeRepository = opts.queryRecord[queryAlias].def.repository;\n\n        if (Array.isArray(dataForThisAlias)) {\n          dataForThisAlias.flatMap(data => nodeRepository.onDataReceived(data));\n        } else {\n          nodeRepository.onDataReceived(dataForThisAlias);\n        }\n\n        const relationalQueries = opts.queryRecord[queryAlias].relational;\n\n        if (relationalQueries) {\n          Object.keys(relationalQueries).forEach(relationalAlias => {\n            const relationalDataForThisAlias = Array.isArray(dataForThisAlias)\n              ? dataForThisAlias.flatMap(\n                  (dataEntry: any) => dataEntry[relationalAlias]\n                )\n              : dataForThisAlias[relationalAlias];\n\n            if (relationalDataForThisAlias) {\n              const relationalQuery = relationalQueries[relationalAlias];\n\n              this.notifyRepositories({\n                data: {\n                  [relationalAlias]: relationalDataForThisAlias,\n                },\n                queryRecord: {\n                  [relationalAlias]: relationalQuery,\n                },\n              });\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Gets the initial state for this manager from the initial query results\n     *   does not execute on subscription messages\n     */\n    public getNewStateFromQueryResult(opts: {\n      queryResult: Record<string, any>;\n      queryId: string;\n    }): SMQueryManagerState {\n      return Object.keys(this.queryRecord).reduce(\n        (resultingStateAcc, queryAlias) => {\n          resultingStateAcc[queryAlias] = this.buildCacheEntry({\n            nodeData: opts.queryResult[queryAlias],\n            queryId: opts.queryId,\n            queryAlias,\n          });\n\n          return resultingStateAcc;\n        },\n        {} as SMQueryManagerState\n      );\n    }\n\n    public buildCacheEntry(opts: {\n      nodeData: Record<string, any> | Array<Record<string, any>>;\n      queryId: string;\n      queryAlias: string;\n      queryRecord?: { [key: string]: BaseQueryRecordEntry };\n    }): SMQueryManagerStateEntry {\n      const { nodeData, queryAlias } = opts;\n      const queryRecord = opts.queryRecord || this.queryRecord;\n      const { relational } = queryRecord[opts.queryAlias];\n\n      const buildRelationalStateForNode = (\n        node: Record<string, any>\n      ): Maybe<SMQueryManagerState> => {\n        if (!relational) return null;\n\n        return Object.keys(relational).reduce(\n          (relationalStateAcc, relationalAlias) => {\n            const relationalDataForThisAlias = node[relationalAlias];\n\n            if (relationalDataForThisAlias) {\n              return {\n                ...relationalStateAcc,\n                [relationalAlias]: this.buildCacheEntry({\n                  nodeData: relationalDataForThisAlias,\n                  queryId: opts.queryId,\n                  queryAlias: relationalAlias,\n                  queryRecord: relational,\n                }),\n              };\n            } else return relationalStateAcc;\n          },\n          {} as SMQueryManagerState\n        );\n      };\n\n      const buildProxyCacheEntryForNode = (\n        node: Record<string, any>\n      ): SMQueryManagerProxyCacheEntry => {\n        const relationalState = buildRelationalStateForNode(node);\n        const nodeRepository = queryRecord[queryAlias].def.repository;\n\n        const proxy = smJSInstance.DOProxyGenerator({\n          node: queryRecord[opts.queryAlias].def,\n          allPropertiesQueried: queryRecord[opts.queryAlias].properties,\n          relationalQueries: relational || null,\n          queryId: opts.queryId,\n          relationalResults: !relationalState\n            ? null\n            : this.getResultsFromState(relationalState),\n          do: nodeRepository.byId(node.id),\n        });\n\n        return {\n          proxy,\n          relationalState,\n        };\n      };\n\n      if (Array.isArray(opts.nodeData)) {\n        if ('id' in queryRecord[opts.queryAlias]) {\n          if (opts.nodeData[0] == null) {\n            throw new SMDataParsingException({\n              receivedData: opts.nodeData,\n              message: `Queried a node by id for the query with the id \"${opts.queryId}\" but received back an empty array`,\n            });\n          }\n\n          return {\n            idsOrIdInCurrentResult: opts.nodeData[0].id,\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\n\n              return proxyCacheAcc;\n            }, {} as SMQueryManagerProxyCache),\n          };\n        } else {\n          return {\n            idsOrIdInCurrentResult: opts.nodeData.map(node => node.id),\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\n\n              return proxyCacheAcc;\n            }, {} as SMQueryManagerProxyCache),\n          };\n        }\n      } else {\n        return {\n          idsOrIdInCurrentResult: opts.nodeData.id,\n          proxyCache: {\n            [(nodeData as { id: string }).id]: buildProxyCacheEntryForNode(\n              nodeData\n            ),\n          },\n        };\n      }\n    }\n\n    public updateProxiesAndStateFromSubscriptionMessage(opts: {\n      node: any;\n      queryId: string;\n      subscriptionAlias: string;\n    }) {\n      const { node, queryId, subscriptionAlias } = opts;\n      const queryRecordEntryForThisSubscription = this.queryRecord[\n        subscriptionAlias\n      ];\n      this.state[subscriptionAlias] = this.state[subscriptionAlias] || {};\n      const stateForThisAlias = this.state[subscriptionAlias];\n      const nodeId = node.id;\n      const { proxy, relationalState } =\n        stateForThisAlias.proxyCache[nodeId] || {};\n\n      if (proxy) {\n        const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\n          {\n            queryId,\n            proxy,\n            newRelationalData: this.getRelationalData({\n              queryRecord: queryRecordEntryForThisSubscription,\n              node: opts.node,\n            }),\n            relationalQueryRecord:\n              queryRecordEntryForThisSubscription.relational || null,\n            currentState: { proxy, relationalState },\n          }\n        );\n        stateForThisAlias.proxyCache[nodeId] = newCacheEntry;\n      } else {\n        const { proxyCache } = this.buildCacheEntry({\n          nodeData: node,\n          queryId,\n          queryAlias: subscriptionAlias,\n          queryRecord: this.queryRecord,\n        });\n\n        const newlyGeneratedProxy = proxyCache[node.id];\n\n        if (!newlyGeneratedProxy)\n          throw Error('Expected a newly generated proxy');\n\n        stateForThisAlias.proxyCache[nodeId] = proxyCache[node.id];\n      }\n\n      if ('id' in queryRecordEntryForThisSubscription) {\n        if ((stateForThisAlias.idsOrIdInCurrentResult as string) === nodeId) {\n          return;\n        }\n\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = nodeId;\n      } else {\n        if (\n          (\n            stateForThisAlias.idsOrIdInCurrentResult || ([] as Array<string>)\n          ).includes(nodeId)\n        )\n          return; // don't need to do anything if this id was already in the returned set\n\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = [\n          nodeId, // insert the new node at the start of the array\n          ...(this.state[opts.subscriptionAlias]\n            .idsOrIdInCurrentResult as Array<string>),\n        ];\n      }\n    }\n\n    public recursivelyUpdateProxyAndReturnNewCacheEntry(opts: {\n      queryId: string;\n      proxy: IDOProxy;\n      newRelationalData: Maybe<\n        Record<string, Array<Record<string, any> | Record<string, any>>>\n      >;\n      relationalQueryRecord: Maybe<Record<string, RelationalQueryRecordEntry>>;\n      currentState: SMQueryManagerProxyCacheEntry;\n    }): SMQueryManagerProxyCacheEntry {\n      const {\n        queryId,\n        proxy,\n        newRelationalData,\n        currentState,\n        relationalQueryRecord,\n      } = opts;\n      const { relationalState: currentRelationalState } = currentState;\n\n      const newRelationalState = !relationalQueryRecord\n        ? null\n        : Object.keys(relationalQueryRecord).reduce(\n            (relationalStateAcc, relationalAlias) => {\n              if (!newRelationalData || !newRelationalData[relationalAlias]) {\n                return relationalStateAcc;\n              }\n\n              const relationalDataForThisAlias =\n                newRelationalData[relationalAlias];\n              const queryRecordForThisAlias =\n                relationalQueryRecord[relationalAlias];\n\n              const currentStateForThisAlias = !currentRelationalState\n                ? null\n                : currentRelationalState[relationalAlias];\n\n              if (!currentStateForThisAlias) {\n                relationalStateAcc[relationalAlias] = this.buildCacheEntry({\n                  nodeData: relationalDataForThisAlias,\n                  queryId,\n                  queryAlias: relationalAlias,\n                  queryRecord: relationalQueryRecord,\n                });\n\n                return relationalStateAcc;\n              }\n\n              if (Array.isArray(relationalDataForThisAlias)) {\n                relationalStateAcc[relationalAlias] = relationalStateAcc[\n                  relationalAlias\n                ] || { proxyCache: {}, idsOrIdInCurrentResult: [] };\n\n                relationalDataForThisAlias.forEach(node => {\n                  const existingProxy =\n                    currentStateForThisAlias.proxyCache[node.id]?.proxy;\n\n                  if (!existingProxy) {\n                    const newCacheEntry = this.buildCacheEntry({\n                      nodeData: node,\n                      queryId: queryId,\n                      queryAlias: relationalAlias,\n                      queryRecord: relationalQueryRecord,\n                    });\n\n                    relationalStateAcc[relationalAlias] = {\n                      proxyCache: {\n                        ...relationalStateAcc[relationalAlias].proxyCache,\n                        [node.id]: newCacheEntry.proxyCache[node.id],\n                      },\n                      idsOrIdInCurrentResult: [\n                        ...(relationalStateAcc[relationalAlias]\n                          .idsOrIdInCurrentResult as Array<string>),\n                        node.id,\n                      ],\n                    };\n                  } else {\n                    const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\n                      {\n                        queryId,\n                        proxy: existingProxy,\n                        newRelationalData: this.getRelationalData({\n                          queryRecord: queryRecordForThisAlias,\n                          node,\n                        }),\n                        relationalQueryRecord:\n                          queryRecordForThisAlias.relational || null,\n                        currentState:\n                          currentStateForThisAlias.proxyCache[node.id],\n                      }\n                    );\n\n                    relationalStateAcc[relationalAlias] = {\n                      proxyCache: {\n                        ...relationalStateAcc[relationalAlias].proxyCache,\n                        [node.id]: newCacheEntry,\n                      },\n                      idsOrIdInCurrentResult: [\n                        ...(relationalStateAcc[relationalAlias]\n                          .idsOrIdInCurrentResult as Array<string>),\n                        node.id,\n                      ],\n                    };\n                  }\n                });\n              } else {\n                throw Error(\n                  `Not implemented. ${JSON.stringify(\n                    relationalDataForThisAlias\n                  )}`\n                );\n              }\n\n              return relationalStateAcc;\n            },\n            {} as SMQueryManagerState\n          );\n\n      newRelationalState\n        ? proxy.updateRelationalResults(\n            this.getResultsFromState(newRelationalState)\n          )\n        : proxy.updateRelationalResults(null);\n\n      return {\n        proxy,\n        relationalState: newRelationalState,\n      };\n    }\n\n    public getRelationalData(opts: {\n      queryRecord: BaseQueryRecordEntry;\n      node: Record<string, any>;\n    }) {\n      return opts.queryRecord.relational\n        ? Object.keys(opts.queryRecord.relational).reduce(\n            (relationalDataAcc, relationalAlias) => {\n              relationalDataAcc[relationalAlias] = opts.node[relationalAlias];\n\n              return relationalDataAcc;\n            },\n            {} as Record<string, any>\n          )\n        : null;\n    }\n  };\n}\n","import { DocumentNode } from '@apollo/client/core';\nimport { sortBy } from 'lodash';\nimport {\n  createEdge,\n  createEdges,\n  getMutationsFromEdgeCreateOperations,\n  dropEdge,\n  dropEdges,\n  getMutationsFromEdgeDropOperations,\n  replaceEdge,\n  replaceEdges,\n  getMutationsFromEdgeReplaceOperations,\n  updateEdge,\n  updateEdges,\n  getMutationsFromEdgeUpdateOperations,\n} from './edges';\nimport {\n  CreateEdgeOperation,\n  CreateEdgesOperation,\n  DropEdgeOperation,\n  DropEdgesOperation,\n  ReplaceEdgeOperation,\n  ReplaceEdgesOperation,\n  UpdateEdgeOperation,\n  UpdateEdgesOperation,\n} from './edges/types';\nimport {\n  createNode,\n  CreateNodeOperation,\n  createNodes,\n  CreateNodesOperation,\n  getMutationsFromTransactionCreateOperations,\n} from './create';\nimport {\n  getMutationsFromTransactionUpdateOperations,\n  updateNode,\n  UpdateNodeOperation,\n  updateNodes,\n  UpdateNodesOperation,\n} from './update';\nimport {\n  dropNode,\n  DropNodeOperation,\n  getMutationsFromTransactionDropOperations,\n} from './drop';\nimport { ISMJS } from '../types';\n\nexport interface ITransactionContext {\n  createNodes: typeof createNodes;\n  createNode: typeof createNode;\n  updateNodes: typeof updateNodes;\n  updateNode: typeof updateNode;\n  dropNode: typeof dropNode;\n  createEdge: typeof createEdge;\n  createEdges: typeof createEdges;\n  dropEdge: typeof dropEdge;\n  dropEdges: typeof dropEdges;\n  updateEdge: typeof updateEdge;\n  updateEdges: typeof updateEdges;\n  replaceEdge: typeof replaceEdge;\n  replaceEdges: typeof replaceEdges;\n}\n\ntype TIndexedOperationType = OperationType & { position?: number };\n\ntype TExecutionResult =\n  | Array<{\n      data: Record<string, any>;\n    }>\n  | Array<\n      Array<{\n        data: Record<string, any>;\n      }>\n    >;\n\ntype TOperationsByType = Record<\n  OperationType['type'],\n  Array<TIndexedOperationType>\n>;\n\nexport interface IPendingTransaction {\n  operations: TOperationsByType;\n  execute: () => Promise<any>;\n  callbackResult?: void | Promise<any> | Array<IPendingTransaction>;\n}\n\ntype OperationType =\n  | CreateNodeOperation\n  | CreateNodesOperation\n  | UpdateNodeOperation\n  | UpdateNodesOperation\n  | DropNodeOperation\n  | CreateEdgeOperation\n  | CreateEdgesOperation\n  | DropEdgeOperation\n  | DropEdgesOperation\n  | UpdateEdgeOperation\n  | UpdateEdgesOperation\n  | ReplaceEdgeOperation\n  | ReplaceEdgesOperation;\n\nexport function createTransaction(smJSInstance: ISMJS) {\n  /**\n   * A transaction allows developers to build groups of mutations that execute with transactional integrity\n   *   this means if one mutation fails, others are cancelled and any graph state changes are rolled back.\n   *\n   * The callback function can return a promise if the transaction requires some data fetching to build its list of operations.\n   */\n  return function transaction(\n    callback:\n      | ((context: ITransactionContext) => void | Promise<void>)\n      | Array<IPendingTransaction>,\n    opts?: { tokenName: string }\n  ) {\n    const operationsByType: TOperationsByType = {\n      createNode: [],\n      createNodes: [],\n      updateNode: [],\n      updateNodes: [],\n      dropNode: [],\n      createEdge: [],\n      createEdges: [],\n      dropEdge: [],\n      dropEdges: [],\n      replaceEdge: [],\n      replaceEdges: [],\n      updateEdge: [],\n      updateEdges: [],\n    };\n\n    /**\n     * Keeps track of the number of operations performed in this transaction (for operations that we need to provide callback data for).\n     * This is used to store each operation's order in the transaction so that we can map it to the response we get back from SM.\n     * SM responds with each operation in the order they were sent up.\n     */\n    let createOperationsCount = 0;\n    let updateOperationsCount = 0;\n\n    function pushOperation(operation: OperationType) {\n      if (!operationsByType[operation.type]) {\n        throw Error(\n          `No operationsByType array initialized for \"${operation.type}\"`\n        );\n      }\n      /**\n       * createNodes/updateNodes creates multiple nodes in a single operation,\n       * therefore we need to track the position of these nodes instead of just the position of the operation itself\n       */\n      if (operation.type === 'createNodes') {\n        createOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: createOperationsCount,\n          nodes: operation.nodes.map((node, idx) => {\n            return {\n              ...node,\n              position:\n                idx === 0\n                  ? createOperationsCount\n                  : (createOperationsCount += 1),\n            };\n          }),\n        });\n      } else if (operation.type === 'createNode') {\n        createOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: createOperationsCount,\n        });\n      } else if (operation.type === 'updateNodes') {\n        updateOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: updateOperationsCount,\n          nodes: operation.nodes.map((node, idx) => {\n            return {\n              ...node,\n              position:\n                idx === 0\n                  ? updateOperationsCount\n                  : (updateOperationsCount += 1),\n            };\n          }),\n        });\n      } else if (operation.type === 'updateNode') {\n        updateOperationsCount += 1;\n        operationsByType[operation.type].push({\n          ...operation,\n          position: updateOperationsCount,\n        });\n      } else {\n        operationsByType[operation.type].push(operation);\n      }\n    }\n\n    const context: ITransactionContext = {\n      createNode: opts => {\n        const operation = createNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createNodes: opts => {\n        const operation = createNodes(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateNode: opts => {\n        const operation = updateNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateNodes: opts => {\n        const operation = updateNodes(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropNode: opts => {\n        const operation = dropNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createEdge: opts => {\n        const operation = createEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createEdges: opts => {\n        const operation = createEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropEdge: opts => {\n        const operation = dropEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropEdges: opts => {\n        const operation = dropEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateEdge: opts => {\n        const operation = updateEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateEdges: opts => {\n        const operation = updateEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      replaceEdge: opts => {\n        const operation = replaceEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      replaceEdges: opts => {\n        const operation = replaceEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n    };\n\n    function sortMutationsByTransactionPosition<T>(\n      operations: Array<TIndexedOperationType>\n    ) {\n      return (sortBy(\n        operations,\n        operation => operation.position\n      ) as unknown) as T;\n    }\n\n    function getAllMutations(\n      operations: TOperationsByType\n    ): Array<DocumentNode> {\n      return [\n        ...getMutationsFromTransactionCreateOperations(\n          sortMutationsByTransactionPosition([\n            ...(operations.createNode as Array<\n              CreateNodeOperation & { position: number }\n            >),\n            ...(operations.createNodes as Array<\n              CreateNodesOperation & { position: number }\n            >),\n          ])\n        ),\n        ...getMutationsFromTransactionUpdateOperations(\n          sortMutationsByTransactionPosition([\n            ...(operations.updateNode as Array<\n              UpdateNodeOperation & { position: number }\n            >),\n            ...(operations.updateNodes as Array<\n              UpdateNodesOperation & { position: number }\n            >),\n          ])\n        ),\n        ...getMutationsFromTransactionDropOperations([\n          ...(operations.dropNode as Array<DropNodeOperation>),\n        ]),\n        ...getMutationsFromEdgeCreateOperations([\n          ...(operations.createEdge as Array<CreateEdgeOperation>),\n          ...(operations.createEdges as Array<CreateEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeDropOperations([\n          ...(operations.dropEdge as Array<DropEdgeOperation>),\n          ...(operations.dropEdges as Array<DropEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeReplaceOperations([\n          ...(operations.replaceEdge as Array<ReplaceEdgeOperation>),\n          ...(operations.replaceEdges as Array<ReplaceEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeUpdateOperations([\n          ...(operations.updateEdge as Array<UpdateEdgeOperation>),\n          ...(operations.updateEdges as Array<UpdateEdgesOperation>),\n        ]),\n      ];\n    }\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    /**\n     * Group operations by their SM operation name, sorted by position if applicable\n     */\n    function groupBySMOperationName(operations: TOperationsByType) {\n      const result = Object.entries(operations).reduce(\n        (acc, [_, operations]) => {\n          operations.forEach(\n            (operation: TIndexedOperationType | OperationType) => {\n              if (acc.hasOwnProperty(operation.smOperationName)) {\n                acc[operation.smOperationName] = [\n                  ...acc[operation.smOperationName],\n                  operation,\n                ];\n              } else {\n                acc[operation.smOperationName] = [operation];\n              }\n            }\n          );\n          return acc;\n        },\n        {} as Record<string, Array<any>>\n      );\n\n      Object.entries(result).forEach(([smOperationName, operations]) => {\n        result[smOperationName] = sortBy(\n          operations,\n          operation => operation.position\n        );\n      });\n\n      return result;\n    }\n\n    if (Array.isArray(callback)) {\n      return transactionGroup(callback);\n    }\n\n    const result = callback(context);\n\n    function handleSuccessCallbacks(opts: {\n      executionResult: TExecutionResult;\n      operationsByType: TOperationsByType;\n    }) {\n      const { executionResult, operationsByType } = opts;\n\n      const operationsBySMOperationName = groupBySMOperationName(\n        operationsByType\n      );\n\n      /**\n       * Loop through the operations, map the operation to each result sent back from SM,\n       * then pass the result into the callback if it exists\n       */\n      const executeCallbacksWithData = (executionResult: TExecutionResult) => {\n        executionResult.forEach(\n          (\n            result:\n              | {\n                  data: Record<string, any>;\n                }\n              | {\n                  data: Record<string, any>;\n                }[]\n          ) => {\n            // if executionResult is 2d array\n            if (Array.isArray(result)) {\n              executeCallbacksWithData(result);\n            } else {\n              const resultData = result.data;\n\n              Object.entries(operationsBySMOperationName).forEach(\n                ([smOperationName, operations]) => {\n                  if (resultData.hasOwnProperty(smOperationName)) {\n                    operations.forEach(operation => {\n                      // we only need to gather the data for node create/update operations\n                      if (\n                        smOperationName === 'CreateNodes' ||\n                        smOperationName === 'UpdateNodes'\n                      ) {\n                        const groupedResult = resultData[smOperationName];\n                        // for createNodes, execute callback on each individual node rather than top-level operation\n                        if (operation.hasOwnProperty('nodes')) {\n                          operation.nodes.forEach((node: any) => {\n                            if (node.hasOwnProperty('onSuccess')) {\n                              const operationResult =\n                                groupedResult[node.position - 1];\n\n                              node.onSuccess(operationResult);\n                            }\n                          });\n                        } else if (operation.hasOwnProperty('onSuccess')) {\n                          const operationResult =\n                            groupedResult[operation.position - 1];\n                          operation.onSuccess(operationResult);\n                        }\n                      }\n                    });\n                  }\n                }\n              );\n            }\n          }\n        );\n      };\n\n      executeCallbacksWithData(executionResult);\n\n      /**\n       * For all other operations, just invoke the callback with no args.\n       * Transactions will guarantee that all operations have succeeded, so this is safe to do\n       */\n      Object.entries(operationsBySMOperationName).forEach(\n        ([smOperationName, operations]) => {\n          if (\n            smOperationName !== 'CreateNodes' &&\n            smOperationName !== 'UpdateNodes'\n          ) {\n            operations.forEach(operation => {\n              if (operation.hasOwnProperty('onSuccess')) {\n                operation.onSuccess();\n              } else if (operation.hasOwnProperty('edges')) {\n                (operation.edges as CreateEdgesOperation['edges']).forEach(\n                  edgeOperation => {\n                    if (edgeOperation.hasOwnProperty('onSuccess')) {\n                      edgeOperation.onSuccess!();\n                    }\n                  }\n                );\n              }\n            });\n          }\n        }\n      );\n    }\n\n    async function execute() {\n      try {\n        if (typeof callback === 'function') {\n          if (result instanceof Promise) {\n            await result;\n          }\n        }\n        const mutations = getAllMutations(operationsByType);\n\n        const executionResult: TExecutionResult = await smJSInstance.gqlClient.mutate(\n          {\n            mutations,\n            token,\n          }\n        );\n\n        if (executionResult) {\n          handleSuccessCallbacks({\n            executionResult,\n            operationsByType,\n          });\n        }\n\n        return executionResult;\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    return {\n      operations: operationsByType,\n      execute,\n      callbackResult: result,\n    };\n\n    function transactionGroup(\n      transactions: Array<IPendingTransaction>\n    ): Omit<IPendingTransaction, 'callbackResult'> {\n      const asyncCallbacks = transactions\n        .filter(tx => tx.callbackResult instanceof Promise)\n        .map(({ callbackResult }) => callbackResult);\n\n      async function execute() {\n        try {\n          if (asyncCallbacks.length) {\n            await Promise.all(asyncCallbacks);\n          }\n\n          const allMutations = transactions.map(({ operations }) => {\n            return smJSInstance.gqlClient.mutate({\n              mutations: getAllMutations(operations),\n              token,\n            });\n          });\n\n          const executionResults: Array<TExecutionResult> = await Promise.all(\n            allMutations\n          );\n\n          if (executionResults) {\n            executionResults.forEach((result, idx) => {\n              handleSuccessCallbacks({\n                executionResult: result,\n                operationsByType: transactions[idx].operations,\n              });\n            });\n          }\n\n          return executionResults.flat();\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      return {\n        operations: operationsByType,\n        execute,\n      };\n    }\n  };\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\n\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\n\nexport type DropNodeOperation = {\n  type: 'dropNode';\n  smOperationName: 'DropNode';\n  id: string;\n  name?: string;\n  onSuccess?: () => any;\n};\n\nexport function dropNode(\n  operation: Omit<DropNodeOperation, 'type' | 'smOperationName'>\n): DropNodeOperation {\n  return {\n    type: 'dropNode',\n    smOperationName: 'DropNode',\n    ...operation,\n  };\n}\n\nexport function getMutationsFromTransactionDropOperations(\n  operations: Array<DropNodeOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n\n  const allDropNodeOperations: Array<{\n    id: string;\n    name?: string;\n  }> = operations.map(operation => {\n    if (operation.type === 'dropNode') {\n      return operation;\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  return allDropNodeOperations.map(operation => {\n    const name = getMutationNameFromOperations([operation], 'DropNode');\n\n    return gql`\n      mutation ${name} {\n        DropNode(nodeId: \"${operation.id}\")\n      }    \n    `;\n  });\n}\n","import {\n  JSON_TAG,\n  NULL_TAG,\n  parseJSONFromBE,\n  prepareValueForFE,\n} from './dataConversions';\nimport { SMNotCachedException, SMDataParsingException } from './exceptions';\nimport { PROPERTIES_QUERIED_FOR_ALL_NODES } from './queryDefinitionAdapters';\nimport {\n  SM_DATA_TYPES,\n  OBJECT_PROPERTY_SEPARATOR,\n  OBJECT_IDENTIFIER,\n} from './smDataTypes';\nimport {\n  ISMData,\n  SMDataDefaultFn,\n  NodeDO,\n  ISMNodeRepository,\n  DeepPartial,\n  GetExpectedNodeDataType,\n} from './types';\n\n/**\n * Returns an initialized instance of a repository for an SMNode\n */\nexport function RepositoryFactory<\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>\n>(opts: {\n  def: {\n    type: string;\n    properties: TNodeData;\n  };\n  DOClass: new (initialData?: Record<string, any>) => NodeDO;\n}): ISMNodeRepository {\n  // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\n  // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\n  // eslint-disable-next-line\n  // @ts-ignore\n  class Repository implements ISMNodeRepository {\n    private cached: Record<string, NodeDO> = {};\n\n    public onDataReceived(data: { id: string } & Record<string, any>) {\n      const cached = this.cached[data.id];\n\n      const parsedData = this.parseDataFromSM<TNodeData>(data);\n\n      if (cached) {\n        cached.onDataReceived(parsedData);\n      } else {\n        this.cached[data.id] = new opts.DOClass(parsedData);\n      }\n    }\n\n    public byId(id: string) {\n      const cached = this.cached[id];\n\n      if (!cached) {\n        throw new SMNotCachedException({\n          nodeType: opts.def.type,\n          id,\n        });\n      }\n\n      return cached;\n    }\n\n    public onNodeDeleted(id: string) {\n      delete this.cached[id];\n    }\n    /**\n     * This method takes data that comes in from SM and is about to be applied to this DO's instance. It needs to:\n     * 1) ignore data not specified in the smNode definition for this node\n     *     this is so that the querier in smDataContext can call onDataReceived on the DO with the data it receives from SM without having to ignore the relational aliases there\n     *     without doing this, we'd get errors about attempting to set a property on a DO which is read only\n     * 2) take objects spread into root properties and convert them to regular objects\n     *     for example, if we are trying to store `settings: { show: true }` in SM, what is actually stored in the DB is\n     *     settings__dot__show: 'true'\n     *     since all data must be a string (we don't need to worry about coercing strings to booleans or numbers though, that's handled by the smDataTypes)\n     */\n    private parseDataFromSM<\n      TNodeData extends Record<string, ISMData | SMDataDefaultFn>\n    >(\n      receivedData: any\n    ): { id: string } & DeepPartial<GetExpectedNodeDataType<TNodeData>> {\n      const oldStyleObjects: Record<string, any> = {};\n      return Object.keys(receivedData).reduce((parsed, key: string) => {\n        const isDataStoredOnAllNodes = PROPERTIES_QUERIED_FOR_ALL_NODES.includes(\n          key\n        );\n        if (isDataStoredOnAllNodes) {\n          return {\n            ...parsed,\n            [key]: receivedData[key],\n          };\n        }\n\n        // point 1) above\n        const isDataStoredOnTheNode = key.includes(OBJECT_PROPERTY_SEPARATOR)\n          ? Object.keys(opts.def.properties).includes(\n              key.split(OBJECT_PROPERTY_SEPARATOR)[0]\n            )\n          : Object.keys(opts.def.properties).includes(key);\n\n        if (!isDataStoredOnTheNode) return parsed;\n\n        const isObjectData =\n          key.includes(OBJECT_PROPERTY_SEPARATOR) ||\n          (opts.def.properties[key] as ISMData).type === SM_DATA_TYPES.object ||\n          (opts.def.properties[key] as ISMData).type ===\n            SM_DATA_TYPES.maybeObject;\n\n        const isArrayData = (() => {\n          if (isObjectData) {\n            return false;\n          }\n\n          const receivedDataValue = opts.def.properties[key];\n\n          const smDataType =\n            typeof receivedDataValue === 'function'\n              ? ((receivedDataValue as any)._default as ISMData).type\n              : (receivedData as ISMData).type;\n\n          return (\n            smDataType === SM_DATA_TYPES.array ||\n            smDataType === SM_DATA_TYPES.maybeArray\n          );\n        })();\n\n        // point 2 above\n        if (isObjectData) {\n          const [root, ...nests] = key.split(OBJECT_PROPERTY_SEPARATOR);\n\n          // it it was set to __NULL__ it means this\n          // node is using the old style of storing nested objects\n          if (receivedData[root] === NULL_TAG || receivedData[root] === null) {\n            parsed[root as keyof TNodeData] = null as any;\n            return parsed;\n          } else if (\n            typeof receivedData[root] === 'string' &&\n            receivedData[root].startsWith(JSON_TAG)\n          ) {\n            // https://tractiontools.atlassian.net/browse/TT-2905\n            // will ensure this would've been set to null if this object was updated\n            //\n            // this means 3 things\n            // 1 we can acquire all the data for this object from this one property\n            // 2 we have to ignore the \"null\" values coming in when we're querying for the new style propeties (root_nestedProperty)\n            // 3 we have to ensure we only return from this object data that was queried\n            //   otherwise we risk hitting the DO class with data that is not documented in the node definition, leading to errors\n            try {\n              oldStyleObjects[root] =\n                oldStyleObjects[root] || parseJSONFromBE(receivedData[root]);\n            } catch (e) {\n              throw new SMDataParsingException({\n                receivedData,\n                message: 'Could not parse json stored in old format',\n              });\n            }\n          }\n\n          if (oldStyleObjects[root]) {\n            parsed[root as keyof TNodeData] =\n              parsed[root] ||\n              (this.getOnlyQueriedData({\n                allDataReceived: receivedData,\n                dataPreviouslyParsedForThisObject: oldStyleObjects[root],\n                rootProp: root,\n              }) as any);\n\n            return parsed;\n          }\n\n          if (parsed[root] == null) {\n            parsed[root as keyof TNodeData] = {} as any;\n          }\n\n          this.nest({\n            nests,\n            root: parsed[root] as Record<string, any>,\n            val:\n              receivedData[key] === OBJECT_IDENTIFIER ? {} : receivedData[key],\n          });\n\n          return parsed;\n        } else if (isArrayData) {\n          parsed[key as keyof TNodeData] = prepareValueForFE(receivedData[key]);\n          return parsed;\n        } else {\n          parsed[key as keyof TNodeData] = receivedData[key];\n          return parsed;\n        }\n      }, {} as { id: string } & DeepPartial<GetExpectedNodeDataType<TNodeData>>);\n    }\n\n    private getOnlyQueriedData(opts: {\n      allDataReceived: Record<string, any>;\n      dataPreviouslyParsedForThisObject: Record<string, any>;\n      rootProp: string;\n    }) {\n      const newStylePropertiesQueriedForThisObject = Object.keys(\n        opts.allDataReceived\n      ).filter(key =>\n        key.startsWith(`${opts.rootProp}${OBJECT_PROPERTY_SEPARATOR}`)\n      );\n\n      return newStylePropertiesQueriedForThisObject.reduce((acc, prop) => {\n        const [root, ...nests] = prop.split(OBJECT_PROPERTY_SEPARATOR);\n        this.nest({\n          nests,\n          root: acc,\n          val: this.getDataForProp({\n            prop,\n            object: { [root]: opts.dataPreviouslyParsedForThisObject },\n          }),\n        });\n\n        return acc;\n      }, {} as Record<string, any>);\n    }\n\n    // with a \"prop\" in the format root__dot__nestedKey__dot__evenMoreNestedKey\n    // returns the correct value from an \"object\" of previously parsed data { root: { nestedKey: { evenMoreNestedKey: true } } }\n    private getDataForProp(opts: {\n      object: Record<string, any>;\n      prop: string;\n    }): any {\n      if (opts.object == null) {\n        return undefined; // the prop is not set on the object at all\n      }\n\n      if (opts.prop.includes(OBJECT_PROPERTY_SEPARATOR)) {\n        const [root, ...rest] = opts.prop.split(OBJECT_PROPERTY_SEPARATOR);\n        return this.getDataForProp({\n          object: opts.object[root],\n          prop: rest.join(OBJECT_PROPERTY_SEPARATOR),\n        });\n      }\n\n      return opts.object[opts.prop];\n    }\n\n    private nest(opts: {\n      nests: Array<string>;\n      root: Record<string, any>;\n      val: any;\n    }) {\n      if (opts.nests.length === 0) {\n        opts.root = opts.val;\n      } else if (opts.nests.length === 1) {\n        const nextNest = opts.nests[0];\n        opts.root[nextNest] = opts.val;\n      } else {\n        const [nextNest, ...remainingNests] = opts.nests;\n\n        if (opts.root[nextNest] == null) {\n          opts.root[nextNest] = null;\n        } else {\n          this.nest({\n            nests: remainingNests,\n            root: opts.root[nextNest],\n            val: opts.val,\n          });\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  return new Repository();\n}\n","import { getGQLCLient } from './gqlClient';\nimport { SMConfig } from './types';\n\nexport function getDefaultConfig(): SMConfig {\n  return {\n    gqlClient: getGQLCLient({\n      httpUrl: 'https://saasmaster.dev02.tt-devs.com/playground/..',\n      wsUrl: 'wss://saasmaster.dev02.tt-devs.com/',\n    }),\n  };\n}\n","import React from 'react';\nimport { convertQueryDefinitionToQueryInfo } from '../queryDefinitionAdapters';\nimport { QueryDefinitions, QueryDataReturn } from '../types';\n\nimport { SMContext } from './context';\n\nexport function useSubscription<TQueryDefinitions extends QueryDefinitions>(\n  queryDefinitions: TQueryDefinitions\n): { data: QueryDataReturn<TQueryDefinitions>; querying: boolean } {\n  const smContext = React.useContext(SMContext);\n\n  if (!smContext) {\n    throw Error(\n      'You must wrap your app with an SMProvider before using useSubscription.'\n    );\n  }\n\n  const obj = { stack: '' };\n  Error.captureStackTrace(obj, useSubscription);\n  if (obj.stack === '') {\n    // Should be supported in all browsers, but better safe than sorry\n    throw Error('Error.captureStackTrace not supported');\n  }\n  const subscriptionId = obj.stack.split('\\n')[1];\n  const preExistingContextForThisSubscription =\n    smContext.ongoingSubscriptionRecord[subscriptionId];\n\n  const [results, setResults] = React.useState<\n    QueryDataReturn<TQueryDefinitions> | undefined\n  >(preExistingContextForThisSubscription?.results);\n  const [error, setError] = React.useState<any>(\n    preExistingContextForThisSubscription?.error\n  );\n  const [querying, setQuerying] = React.useState<boolean>(\n    preExistingContextForThisSubscription?.querying != null\n      ? preExistingContextForThisSubscription?.querying\n      : true\n  );\n  React.useEffect(() => {\n    smContext.cancelCleanup(subscriptionId);\n    return () => {\n      smContext.scheduleCleanup(subscriptionId);\n    };\n  }, [smContext, subscriptionId]);\n\n  // We can not directly call \"setResults\" from this useState hook above within the subscriptions 'onData'\n  // because if this component unmounts due to fallback rendering then mounts again, we would be calling setResults on the\n  // state of the component rendered before the fallback occured.\n  // To avoid that, we keep a reference to the most up to date results setter in the subscription context\n  // and call that in \"onData\" instead.\n  smContext.updateSubscriptionInfo(subscriptionId, {\n    onResults: setResults,\n    onError: setError,\n    setQuerying: setQuerying,\n  });\n\n  const queryDefinitionHasBeenUpdated =\n    preExistingContextForThisSubscription?.queryInfo?.queryGQL != null &&\n    preExistingContextForThisSubscription.queryInfo.queryGQL !==\n      convertQueryDefinitionToQueryInfo({\n        queryDefinitions,\n        queryId: preExistingContextForThisSubscription.queryInfo.queryId,\n      }).queryGQL;\n  if (!preExistingContextForThisSubscription || queryDefinitionHasBeenUpdated) {\n    if (queryDefinitionHasBeenUpdated) {\n      preExistingContextForThisSubscription.unsub &&\n        preExistingContextForThisSubscription.unsub();\n    }\n\n    const queryTimestamp = new Date().valueOf();\n    setQuerying(true);\n    smContext.updateSubscriptionInfo(subscriptionId, {\n      querying: true,\n      lastQueryTimestamp: queryTimestamp,\n    });\n\n    const suspendPromise = smContext.smJSInstance\n      .subscribe(queryDefinitions, {\n        onData: ({ results: newResults }) => {\n          const contextForThisSub =\n            smContext.ongoingSubscriptionRecord[subscriptionId];\n          const thisQueryIsMostRecent =\n            contextForThisSub.lastQueryTimestamp === queryTimestamp;\n          if (thisQueryIsMostRecent) {\n            contextForThisSub.onResults &&\n              contextForThisSub.onResults(newResults);\n            smContext.updateSubscriptionInfo(subscriptionId, {\n              results: newResults,\n            });\n          }\n        },\n        onError: error => {\n          const contextForThisSub =\n            smContext.ongoingSubscriptionRecord[subscriptionId];\n          contextForThisSub.onError && contextForThisSub.onError(error);\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            error,\n          });\n        },\n        onSubscriptionInitialized: subscriptionCanceller => {\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            unsub: subscriptionCanceller,\n          });\n        },\n        onQueryInfoConstructed: queryInfo => {\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            queryInfo,\n          });\n        },\n      })\n      .finally(() => {\n        const contextForThisSub =\n          smContext.ongoingSubscriptionRecord[subscriptionId];\n        const thisQueryIsMostRecent =\n          contextForThisSub.lastQueryTimestamp === queryTimestamp;\n        if (thisQueryIsMostRecent) {\n          contextForThisSub.setQuerying && contextForThisSub.setQuerying(false);\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            suspendPromise: undefined,\n            querying: false,\n          });\n        }\n      });\n\n    if (!preExistingContextForThisSubscription) {\n      smContext.updateSubscriptionInfo(subscriptionId, { suspendPromise });\n      throw suspendPromise;\n    } else {\n      return { data: results, querying } as {\n        data: QueryDataReturn<TQueryDefinitions>;\n        querying: boolean;\n      };\n    }\n  } else if (preExistingContextForThisSubscription.suspendPromise) {\n    throw preExistingContextForThisSubscription.suspendPromise;\n  } else if (error) {\n    throw error;\n  } else {\n    return { data: results, querying } as {\n      data: QueryDataReturn<TQueryDefinitions>;\n      querying: boolean;\n    };\n  }\n}\n"],"names":["SMNotUpToDateException","opts","propName","nodeType","queryId","Error","SMNotUpToDateInComputedException","_Error2","computedPropName","SMNotCachedException","_Error3","id","SMDataTypeException","_Error4","dataType","value","SMDataTypeExplicitDefaultException","_Error5","SMDataParsingException","_Error6","message","JSON","stringify","receivedData","SMUnexpectedSubscriptionMessageException","exception","SM_DATA_TYPES","string","maybeString","number","maybeNumber","maybeBoolean","object","maybeObject","record","maybeRecord","array","maybeArray","SMData","type","parser","boxedValue","defaultValue","isOptional","String","_default","optional","parsed","Number","isNaN","error","process","env","NODE_ENV","console","throwLocallyLogInProd","boolean","undefined","val","SM_RELATIONAL_TYPES","byReference","children","parseJSONFromBE","jsonString","startsWith","JSON_TAG","parse","replace","PROPERTIES_QUERIED_FOR_ALL_NODES","getMapFnReturn","relationaFns","mapFnOpts","properties","relational","Object","keys","reduce","acc","key","forEach","data","map","mapFn","getQueriedProperties","mapFnReturn","smData","smRelational","isRootLevel","includes","push","nestedKey","getAllNodeProperties","nodeProperties","getIdsString","ids","join","getKeyValueFilterString","clause","entries","getSubscriptionGetNodeOptions","options","def","under","getSpaces","numberOfSpaces","Array","fill","getQueryPropertiesString","propsString","nestLevel","queryRecordEntry","relationalQueryRecord","alias","operation","relationalQueryRecordEntry","idProp","depth","getRelationalQueryString","convertQueryDefinitionToQueryInfo","queryRecord","queryDefinitions","queryDefinitionsAlias","queriedProps","nodeDef","queryDefinition","_isSMNodeDef","smComputed","getRelationalQueries","relationalQueries","relationalQuery","_smRelational","relationalQueriesWithinThisRelationalQuery","relationalType","length","underIds","filter","getQueryRecordFromQueryDefinition","queryGQLString","getSanitizedQueryId","isArray","getGetNodeOptions","getRootLevelQueryString","trim","subscriptionConfigs","subscriptionConfigsAcc","subscriptionName","extractNodeFromSubscriptionMessage","subscriptionMessage","node","description","extractOperationFromSubscriptionMessage","underId","gqlString","getQueryInfo","queryGQL","gql","subscriptionConfig","runtime","exports","Op","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","tryCatch","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","queryIdx","generateQuerier","smJSInstance","queryManager","getError","onError","stack","startStack","substring","indexOf","token","getToken","tokenName","gqlClient","query","batched","queryResult","results","qM","SMQueryManager","onQueryResult","getResults","e","onData","getMutationNameFromOperations","operations","fallback","operationNames","getEdgePermissionsString","permissions","view","edit","manage","terminate","addChild","convertEdgeCreationOperationToMutationArguments","edge","from","to","convertEdgeDropOperationToMutationArguments","convertEdgeReplaceOperationToMutationArguments","current","convertEdgeUpdateOperationToMutationArguments","convertNodeDataToSMPersistedData","nodeData","parsedData","childNodes","item","escapeText","prepareObjectForBE","parentKey","preparedKey","prepareForBE","text","convertCreateNodeOperationToCreateNodesMutationArguments","mutationArgs","convertUpdateNodeOperationToUpdateNodesMutationArguments","SMContext","React","createContext","getGQLCLient","gqlClientOpts","wsLink","WebSocketLink","uri","wsUrl","reconnect","nonBatchedLink","HttpLink","httpUrl","queryBatchLink","split","getContext","batchedQuery","BatchHttpLink","batchMax","batchInterval","mutationBatchLink","batchedMutation","MAX_SAFE_INTEGER","requestLink","definition","getMainDefinition","kind","getContextWithToken","headers","Authorization","authenticateSubscriptionDocument","documentBody","_opts$gql$loc","source","body","operationsThatRequireToken","some","documentBodyWithAuthTokensInjected","RegExp","authLink","ApolloLink","forward","Observable","observer","subscribe","bind","unsubscribe","baseClient","ApolloClient","link","cache","InMemoryCache","defaultOptions","watchQuery","fetchPolicy","errorPolicy","subscription","onMessage","mutate","all","mutations","mutation","require","SMJS","config","plugins","updateQueryManagerWithSubscriptionMessage","initSubs","unsub","subscriptionCancellers","cancel","mustAwaitQuery","messageQueue","onSubscriptionMessage","subscriptionAlias","onQueryInfoConstructed","skipInitialQuery","onSubscriptionInitialized","DOProxyGenerator","relationalResults","nodeSMComputed","computedAccessors","computedKey","computedFn","proxy","plugin","DOProxy","_plugin$DOProxy","computedDecorator","ProxyInstance","Proxy","getOwnPropertyDescriptor","target","allPropertiesQueried","get","newRelationalResults","smDataForThisProp","getNestedObjectWithNotUpToDateProtection","objectToReturn","smDataForThisObject","objectProp","parentObjectKey","isUpToDate","prop","allCachedData","createDOProxyGenerator","DOFactory","initialData","nodePropertiesOrSMData","_this","isObjectType","getDefaultData","getDefaultFnValue","defaultSMData","defaultFn","isArrayType","propValue","isRecordType","version","restReceivedData","newVersion","newData","parseReceivedData","extendPersistedWithNewlyReceivedData","_persistedData","extension","getParsedData","persistedData","defaultData","_defaults","propNameForThisObject","DO","_plugin$DO","onConstruct","DOInstance","parsedDataKey","initializeNodePropGettersAndSetters","initializeNodeComputedGetters","initializeNodeRelationalGetters","initializeNodeMutations","property","_this2","getSMData","propExistsInInitialData","_this3","_opts$defaultData2","_this4","_this5","setObjectProp","setArrayProp","setPrimitiveValueProp","computedData","computed","computedProp","_this6","setComputedProp","relationalData","relationalProp","_this7","setRelationalProp","relationalQueryGetter","mutationName","_this8","computedGetter","_this9","_plugin$DO2","createDOFactory","notifyRepositories","getNewStateFromQueryResult","queryRecordEntryForThisSubscription","action","path","updateProxiesAndStateFromSubscriptionMessage","idsOrIdInCurrentResult","getResultsFromState","resultsAcc","queryAlias","stateForThisAlias","idsOrId","proxyCache","dataForThisAlias","nodeRepository","repository","flatMap","onDataReceived","relationalAlias","relationalDataForThisAlias","dataEntry","resultingStateAcc","buildCacheEntry","buildProxyCacheEntryForNode","relationalState","relationalStateAcc","buildRelationalStateForNode","byId","proxyCacheAcc","nodeId","newCacheEntry","recursivelyUpdateProxyAndReturnNewCacheEntry","newRelationalData","getRelationalData","currentState","currentRelationalState","newRelationalState","queryRecordForThisAlias","currentStateForThisAlias","existingProxy","_currentStateForThisA","updateRelationalResults","relationalDataAcc","createSMQueryManager","transaction","callback","operationsByType","createNode","createNodes","updateNode","updateNodes","dropNode","createEdge","createEdges","dropEdge","dropEdges","replaceEdge","replaceEdges","updateEdge","updateEdges","createOperationsCount","updateOperationsCount","pushOperation","position","nodes","idx","smOperationName","edges","sortMutationsByTransactionPosition","sortBy","getAllMutations","allCreateNodeOperations","getMutationsFromTransactionCreateOperations","allUpdateNodeOperations","dropPropertiesMutations","updateNodeOperation","propertiesToNull","getPropertiesToNull","concat","getMutationsFromTransactionUpdateOperations","getMutationsFromTransactionDropOperations","getMutationsFromEdgeCreateOperations","getMutationsFromEdgeDropOperations","getMutationsFromEdgeReplaceOperations","getMutationsFromEdgeUpdateOperations","transactions","asyncCallbacks","tx","callbackResult","allMutations","executionResults","handleSuccessCallbacks","executionResult","flat","execute","transactionGroup","operationsBySMOperationName","groupBySMOperationName","executeCallbacksWithData","resultData","groupedResult","onSuccess","edgeOperation","createTransaction","DOClass","cached","parseDataFromSM","onNodeDeleted","oldStyleObjects","isObjectData","isArrayData","receivedDataValue","smDataType","root","nests","getOnlyQueriedData","allDataReceived","dataPreviouslyParsedForThisObject","rootProp","nest","prepareValueForFE","beData","prepared","getDataForProp","rest","nextNest","remainingNests","smMutations","tokens","setToken","props","useContext","ongoingSubscriptionRecord","useRef","cleanupTimeoutRecord","updateSubscriptionInfo","useCallback","subscriptionId","subInfo","scheduleCleanup","cleanup","existingContextSubscription","subscriptionTTLMs","setTimeout","cancelCleanup","clearTimeout","Provider","smJS","parsedBoxedValue","smArray","queryBuilderOpts","useSubscription","smContext","captureStackTrace","preExistingContextForThisSubscription","useState","setResults","setError","querying","setQuerying","useEffect","onResults","queryDefinitionHasBeenUpdated","queryInfo","queryTimestamp","Date","valueOf","lastQueryTimestamp","suspendPromise","newResults","contextForThisSub","subscriptionCanceller"],"mappings":"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"}