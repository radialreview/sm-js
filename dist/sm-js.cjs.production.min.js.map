{"version":3,"file":"sm-js.cjs.production.min.js","sources":["../src/consts.ts","../src/dataConversions.ts","../src/types.ts","../src/exceptions.ts","../src/smDataTypes.ts","../src/OptimisticUpdates.ts","../src/dataUtilities.ts","../node_modules/regenerator-runtime/runtime.js","../src/transaction/convertNodeDataToSMPersistedData.ts","../src/queryDefinitionAdapters.ts","../src/smQueriers.ts","../src/transaction/getMutationNameFromOperations.ts","../src/transaction/edges/utilities.ts","../src/transaction/edges/create.ts","../src/transaction/edges/drop.ts","../src/transaction/edges/replace.ts","../src/transaction/edges/update.ts","../src/transaction/create.ts","../src/react/context.tsx","../src/react/useSMSubscription.tsx","../src/gqlClient.ts","../src/transaction/update.ts","../src/index.ts","../src/DOProxyGenerator.ts","../src/DO.ts","../src/SMQueryManager.ts","../src/transaction/transaction.ts","../src/transaction/drop.ts","../src/Repository.ts","../src/config.ts"],"sourcesContent":["export const PROPERTIES_QUERIED_FOR_ALL_NODES = [\r\n  'id',\r\n  'version',\r\n  'lastUpdatedBy',\r\n  'type',\r\n];\r\n\r\nexport const RELATIONAL_UNION_QUERY_SEPARATOR = '__rU__';\r\n\r\nexport const DEFAULT_TOKEN_NAME = 'default';\r\n","export const JSON_TAG = '__JSON__';\r\nexport const NULL_TAG = '__NULL__';\r\n\r\nexport function parseJSONFromBE(jsonString: string) {\r\n  if (!jsonString.startsWith(JSON_TAG)) {\r\n    throw Error(`parseJSONFromBE - invalid json received:\\n${jsonString}`);\r\n  }\r\n\r\n  // convert string array into js array\r\n  if (jsonString.startsWith(`${JSON_TAG}[`)) {\r\n    return JSON.parse(jsonString.replace('__JSON__', ''));\r\n  }\r\n\r\n  // Allow new line text (\\n to \\\\n)\r\n  // replacing prevents JSON.parse to complaining\r\n  return JSON.parse(jsonString.replace(JSON_TAG, '').replace(/\\n/g, '\\\\n'));\r\n}\r\n\r\nexport function prepareValueForFE(value: any): any {\r\n  if (value === NULL_TAG) {\r\n    return null;\r\n  } else if (value === 'true' || value === 'false') {\r\n    return value === 'true';\r\n  } else if (typeof value === 'string' && value.startsWith(JSON_TAG)) {\r\n    return parseJSONFromBE(value);\r\n  } else if (Array.isArray(value)) {\r\n    return value.map(entry => {\r\n      if (typeof entry === 'object') {\r\n        return prepareValueForFE(entry);\r\n      } else {\r\n        return entry;\r\n      }\r\n    });\r\n  } else if (value != null && typeof value === 'object') {\r\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n    return prepareForFE(value);\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\nexport function prepareForFE(beData: Record<string, any>) {\r\n  return Object.keys(beData).reduce((prepared, key) => {\r\n    const value = beData[key];\r\n    return {\r\n      ...prepared,\r\n      [key]: prepareValueForFE(value),\r\n    };\r\n  }, {} as Record<string, any>);\r\n}\r\n","import { createDOFactory } from './DO';\r\nimport { createDOProxyGenerator } from './DOProxyGenerator';\r\nimport { generateQuerier, generateSubscriber } from './smQueriers';\r\nimport { createSMQueryManager } from './SMQueryManager';\r\nimport { createTransaction } from './transaction/transaction';\r\n\r\nexport type BOmit<T, K extends keyof T> = T extends any ? Omit<T, K> : never;\r\n\r\nexport type Maybe<T> = T | null;\r\n\r\nexport type IsMaybe<Type> = null extends Type ? true : false\r\n\r\nexport type SMDataDefaultFn = (_default: any) => ISMData;\r\n\r\nexport type DocumentNode = import('@apollo/client/core').DocumentNode;\r\n\r\nexport type SMPlugin = {\r\n  DO?: {\r\n    onConstruct?: (opts: { DOInstance: NodeDO; parsedDataKey: string }) => void;\r\n    computedDecorator?: <\r\n      TReturnType,\r\n      TComputedFn extends (data: Record<string, any>) => TReturnType\r\n    >(opts: {\r\n      DOInstance: NodeDO;\r\n      computedFn: TComputedFn;\r\n    }) => () => TReturnType;\r\n  };\r\n  DOProxy?: {\r\n    computedDecorator?: <\r\n      TReturnType,\r\n      TComputedFn extends (data: Record<string, any>) => TReturnType\r\n    >(opts: {\r\n      ProxyInstance: IDOProxy;\r\n      computedFn: TComputedFn;\r\n    }) => () => TReturnType;\r\n  };\r\n};\r\n\r\nexport type SMConfig = {\r\n  gqlClient: ISMGQLClient;\r\n  plugins?: Array<SMPlugin>;\r\n};\r\n\r\nexport interface ISMGQLClient {\r\n  query(opts: {\r\n    gql: DocumentNode;\r\n    token: string;\r\n    batched?: boolean;\r\n  }): Promise<any>;\r\n  subscribe(opts: {\r\n    gql: DocumentNode;\r\n    token: string;\r\n    onMessage: (message: Record<string, any>) => void;\r\n    onError: (error: any) => void;\r\n  }): SubscriptionCanceller;\r\n  mutate(opts: { mutations: Array<DocumentNode>; token: string }): Promise<any>;\r\n}\r\n\r\nexport interface ISMQueryManager {\r\n  onQueryResult(opts: { queryResult: any; queryId: string }): void;\r\n  onSubscriptionMessage(opts: {\r\n    node: Record<string, any>;\r\n    operation: {\r\n      action: 'UpdateNode' | 'DeleteNode' | 'InsertNode';\r\n      path: string;\r\n    };\r\n    queryId: string;\r\n    subscriptionAlias: string;\r\n  }): void;\r\n  getResults: () => Record<string, any>;\r\n}\r\n\r\nexport type QueryReturn<TQueryDefinitions extends QueryDefinitions> = {\r\n  data: QueryDataReturn<TQueryDefinitions>;\r\n  error: any;\r\n};\r\n\r\nexport type QueryOpts<TQueryDefinitions extends QueryDefinitions> = {\r\n  onData?: (info: { results: QueryDataReturn<TQueryDefinitions> }) => void;\r\n  // When onError is provided, we pass it any errors encountered instead of throwing them.\r\n  // This is by design, for consistency with the interface of sm.subscribe\r\n  onError?: (...args: any) => void;\r\n  queryId?: string;\r\n  batched?: boolean;\r\n};\r\n\r\nexport type SubscriptionOpts<TQueryDefinitions extends QueryDefinitions> = {\r\n  onData: (info: { results: QueryDataReturn<TQueryDefinitions> }) => void;\r\n  // To catch an error in a subscription, you must provide an onError handler,\r\n  // since we resolve this promise as soon as the subscriptions are initialized and the query is resolved (if it wasn't skipped)\r\n  //\r\n  // This means you can use the try/catch syntax try { await sm.subscription } catch (e) {}\r\n  // to catch errors querying or initializing subscriptions.\r\n  //\r\n  // However, when onError is given, errors will no longer be thrown\r\n  // They will instead all be passed to the onError handler\r\n  onError?: (...args: any) => void;\r\n  // Allow subscriptions to be cancelled immediately after \"subscribe\" is called, and before the initial query resolves\r\n  onSubscriptionInitialized?: (\r\n    subscriptionCanceller: SubscriptionCanceller\r\n  ) => void;\r\n  onQueryInfoConstructed?: (queryInfo: {\r\n    queryGQL: DocumentNode;\r\n    queryId: string;\r\n  }) => void;\r\n  skipInitialQuery?: boolean;\r\n  queryId?: string;\r\n  batched?: boolean;\r\n};\r\n\r\nexport type SubscriptionCanceller = () => void;\r\nexport type SubscriptionMeta = { unsub: SubscriptionCanceller; error: any };\r\nexport interface ISMJS {\r\n  getToken(opts: { tokenName: string }): string;\r\n  setToken(opts: { tokenName: string; token: string }): void;\r\n  clearTokens(): void\r\n  query: ReturnType<typeof generateQuerier>\r\n  subscribe: ReturnType<typeof generateSubscriber>\r\n  transaction: ReturnType<typeof createTransaction>\r\n  gqlClient: ISMGQLClient;\r\n  plugins: Array<SMPlugin> | undefined;\r\n  DOProxyGenerator: ReturnType<typeof createDOProxyGenerator>\r\n  DOFactory: ReturnType<typeof createDOFactory>\r\n  SMQueryManager:ReturnType<typeof createSMQueryManager>\r\n\r\n  def<\r\n    TNodeType extends string,\r\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n    TNodeComputedData extends Record<string, any>,\r\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\r\n    TNodeMutations extends Record<\r\n      string,\r\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\r\n    >\r\n  >(\r\n    def: NodeDefArgs<\r\n      TNodeType,\r\n      TNodeData,\r\n      TNodeComputedData,\r\n      TNodeRelationalData,\r\n      TNodeMutations\r\n    >\r\n  ): ISMNode<TNodeType, TNodeData, TNodeComputedData, TNodeRelationalData, TNodeMutations>;\r\n}\r\n\r\nexport type NodeDefArgs<\r\n  TNodeType extends string,\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n  TNodeComputedData extends Record<string, any>,\r\n  TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\r\n  TNodeMutations extends Record<string, /*NodeMutationFn<TNodeData, any>*/NodeMutationFn>\r\n> = {\r\n  type: TNodeType;\r\n  properties: TNodeData;\r\n  computed?: NodeComputedFns<TNodeData, TNodeComputedData>;\r\n  relational?: NodeRelationalFns<TNodeRelationalData>;\r\n  mutations?: TNodeMutations;\r\n};\r\n\r\n/**\r\n * The interface implemented by each smData type (like smData.string, smData.boolean)\r\n */\r\nexport interface ISMData<\r\n  TParsedValue = any,\r\n  TSMValue = any,\r\n  /**\r\n   * only defined for object and array types\r\n   *\r\n   * for arrays is the smData type of each item in that array\r\n   * for objects is a record of strings to smData (matching the structure the smData.object received as an argument)\r\n   */\r\n  TBoxedValue extends\r\n    | ISMData\r\n    | SMDataDefaultFn\r\n    | Record<string, ISMData | SMDataDefaultFn>\r\n    | undefined = any\r\n> {\r\n  type: string;\r\n  parser(smValue: TSMValue): TParsedValue;\r\n  boxedValue: TBoxedValue;\r\n  defaultValue: Maybe<TParsedValue>;\r\n  isOptional: boolean;\r\n}\r\n\r\nexport type SMDataEnum<Enum extends string | number | null> = ISMData<\r\n  Enum,\r\n  Enum,\r\n  undefined\r\n>;\r\n\r\n/**\r\n * Utility to extract the parsed value of an SMData type\r\n */\r\nexport type GetSMDataType<TSMData extends ISMData | SMDataDefaultFn> = TSMData extends ISMData<\r\n  infer TParsedValue\r\n>\r\n  ? TParsedValue\r\n  : TSMData extends SMDataDefaultFn\r\n    ? TSMData extends (_: any) => ISMData<infer TParsedValue>\r\n      ? TParsedValue\r\n      : never\r\n  : never\r\n\r\ntype GetSMBoxedValue<\r\n  TSMData extends ISMData<any, any, Record<string, ISMData>> | SMDataDefaultFn\r\n> = \r\n  TSMData extends ISMData<any, any, infer TBoxedValue> \r\n    ? TBoxedValue \r\n    : TSMData extends (_: any) => ISMData<any,any, infer TBoxedValue>\r\n    ? TBoxedValue\r\n: never;\r\n\r\nexport type GetParsedValueTypeFromDefaultFn<\r\n  TDefaultFn extends (_default: any) => ISMData\r\n> = TDefaultFn extends (_default: any) => ISMData<infer TParsedValue, any, any>\r\n  ? TParsedValue\r\n  : never;\r\n\r\n  /**\r\n   * Utility to extract the resulting data type from the properties definition of a node\r\n   * for example\r\n   * \r\n   * {\r\n   *   flag: boolean(false), // boolean and string types from sm-js\r\n   *   name: string\r\n   * }\r\n   * \r\n   * will return\r\n   * \r\n   * {\r\n   *   flag: boolean, // boolean and string native types from TS\r\n   *   name: string\r\n   * }\r\n   */\r\nexport type GetResultingDataTypeFromProperties<TProperties extends Record<string, ISMData | SMDataDefaultFn>> =  {\r\n  [key in keyof TProperties]:\r\n    TProperties[key] extends ISMData<infer TParsedValue, any, infer TBoxedValue>\r\n      ? TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\r\n        ? IsMaybe<TParsedValue> extends true\r\n          ? Maybe<GetAllAvailableNodeDataType<TBoxedValue, {}>>\r\n          : GetAllAvailableNodeDataType<TBoxedValue, {}>\r\n        : TParsedValue extends Array<infer TArrayItemType>\r\n          ? IsMaybe<TParsedValue> extends true\r\n            ? Maybe<Array<TArrayItemType>>\r\n            : Array<TArrayItemType>\r\n          : TParsedValue\r\n      : TProperties[key] extends SMDataDefaultFn\r\n        ? GetParsedValueTypeFromDefaultFn<TProperties[key]>\r\n        : never;\r\n}\r\n\r\nexport type GetResultingDataTypeFromNodeDefinition<TSMNode extends ISMNode> = TSMNode extends ISMNode<any, infer TProperties> ? GetResultingDataTypeFromProperties<TProperties> : never\r\n\r\n/**\r\n * Utility to extract the expected data type of a node based on its' properties and computed data\r\n * For data resulting from property definitions only, use GetResultingDataTypeFromProperties\r\n */\r\nexport type GetAllAvailableNodeDataType<\r\n  TSMData extends Record<string, ISMData | SMDataDefaultFn>,\r\n  TComputedData extends Record<string, any>\r\n> = GetResultingDataTypeFromProperties<TSMData> & TComputedData;\r\n\r\n/**\r\n * Takes in any object and returns a Partial of that object type\r\n * for nested objects, those will also be turned into partials\r\n */\r\nexport type DeepPartial<ObjectType extends Record<string, any>> = Partial<\r\n  {\r\n    [Key in keyof ObjectType]: ObjectType[Key] extends Maybe<Array<any>>\r\n      ? ObjectType[Key]\r\n      : ObjectType[Key] extends Maybe<Record<string, any>>\r\n      ? ObjectType[Key] extends null\r\n        ? Maybe<DeepPartial<ObjectType[Key]>>\r\n        : DeepPartial<ObjectType[Key]>\r\n      : ObjectType[Key];\r\n  }\r\n>;\r\n\r\ntype IsArray<Thing extends any, Y = true, N = false> = Thing extends Array<any> ? Y : N\r\n\r\ntype IsObject<TObject extends Record<string,any>, Y = true, N = false> =\r\n  IsArray<TObject> extends true\r\n    ? false\r\n    : TObject extends Record<string, any>\r\n      ? Y\r\n      : N\r\n\r\n/**\r\n * Note: this is used solely for obtaining the keys in an object converted to the dot notation\r\n * it was not possible to have the correct value types be mapped over, which is why all values are \"never\"\r\n */\r\ntype ConvertToRootLevelDotNotation<TObject extends Record<string, any>, TPrefix extends string = ''> = \r\n  // object properties\r\n  {\r\n    [TKey in keyof TObject\r\n      // skip values that aren't objects, those get handled below so this is easier to read\r\n      as IsObject<TObject[TKey]> extends true\r\n        // TS forces us to do this check, otherwise it thinks key may be a symbol\r\n        ? TKey extends string\r\n          // don't want to prefix the property at all if a prefix was not provided (we're at the top level and haven't called this type recursively)\r\n          ? TPrefix extends ''\r\n            ? keyof ConvertToRootLevelDotNotation<TObject[TKey], TKey>\r\n            // otherwise TPrefix every property with the prefix\r\n            : keyof ConvertToRootLevelDotNotation<TObject[TKey], `${TPrefix}.${TKey}`>\r\n          : never\r\n        : never\r\n    ]: never\r\n  }\r\n  &\r\n  // primitive properties\r\n  {\r\n    [TKey in keyof TObject\r\n    // objects get their keys mapped above\r\n      as IsObject<TObject[TKey]> extends true\r\n        ? never\r\n        // arrays are not searchable\r\n        : IsArray<TObject[TKey]> extends true\r\n          ? never\r\n          : TPrefix extends ''\r\n            ? TKey\r\n            : TKey extends string\r\n              ? `${TPrefix}.${TKey}`\r\n              : never\r\n    ]: never\r\n  }\r\n\r\ntype ValidReferenceIdProp<TObject extends Record<string,any>> = keyof ConvertToRootLevelDotNotation<TObject>\r\n\r\n/**\r\n * Returns a union of all valid idReference props from a node's data type\r\n * excluding properties which are arrays\r\n * and converting nested properties to dot notation\r\n * \r\n * For example, if a node's data is\r\n * {\r\n *  string: string\r\n *  object: {\r\n *    nestedString: string\r\n *    nestedObject: {\r\n *      nestedNestedBoolean: boolean\r\n *    }\r\n *  }\r\n *  arr: []\r\n * }\r\n * \r\n * The resulting valid id references would be 'string' | 'object.nestedString' | 'object.nestedObject.nestedNestedBoolean'\r\n */\r\nexport type ValidReferenceIdPropFromNode<TSMNode extends ISMNode> = ValidReferenceIdProp<GetResultingDataTypeFromNodeDefinition<TSMNode>>\r\n\r\n/**\r\n * A record that lives on each instance of a DOProxy to determine\r\n * if each data property on that DO is currently guaranteed to be up to date.\r\n * Any property that is read while not being up to date throws a run-time error to ensure the devs never use outdated data mistakenly\r\n */\r\nexport type UpToDateData<\r\n  TNodeData extends Record<string, ISMData>\r\n> = DeepPartial<\r\n  {\r\n    [Key in keyof TNodeData]: TNodeData[Key] extends ISMData<Maybe<Array<any>>>\r\n      ? boolean\r\n      : TNodeData[Key] extends ISMData<any, any, infer TBoxedValue>\r\n      ? TBoxedValue extends Record<string, ISMData>\r\n        ? UpToDateData<TBoxedValue>\r\n        : boolean\r\n      : boolean;\r\n  }\r\n>;\r\n\r\n/**\r\n * These methods are called automatically when using this lib's public methods like \"useSMData\"\r\n */\r\nexport interface IDOMethods {\r\n  /**\r\n   * Called when we get data from SM for this particular DO instance, found by its id\r\n   */\r\n  onDataReceived(data: Record<string, any>, opts?: {__unsafeIgnoreVersion?: boolean}): void;\r\n}\r\n\r\nexport interface IDOAccessors {\r\n  id: string\r\n  version: number\r\n  lastUpdatedBy: string\r\n  persistedData: Record<string,any>\r\n}\r\n\r\nexport type NodeDO = Record<string, any> & IDOMethods & IDOAccessors;\r\n\r\nexport type NodeComputedFns<\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n  TNodeComputedData extends Record<string, any>\r\n> = {\r\n  [key in keyof TNodeComputedData]: (\r\n    data: GetAllAvailableNodeDataType<TNodeData, TNodeComputedData>\r\n  ) => TNodeComputedData[key];\r\n};\r\n\r\nexport type NodeRelationalFns<\r\n  TNodeRelationalData extends NodeRelationalQueryBuilderRecord\r\n> = {\r\n  [key in keyof TNodeRelationalData]: () => TNodeRelationalData[key];\r\n};\r\n\r\nexport type NodeMutationFn<\r\n  // TNodeData,\r\n  // TAdditionalOpts extends Record<string, any>\r\n> = (\r\n  // opts: SMNodeMutationOpts<TNodeData> & TAdditionalOpts\r\n  ) => Promise<any>;\r\n\r\nexport interface ISMNode<\r\n  TNodeType extends string = any,\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn> = {},\r\n  TNodeComputedData extends Record<string, any> = {},\r\n  TNodeRelationalData extends NodeRelationalQueryBuilderRecord = {},\r\n  TNodeMutations extends Record<string, /*NodeMutationFn<TNodeData, any>*/NodeMutationFn> = {},\r\n  TNodeComputedFns = NodeComputedFns<TNodeData, TNodeComputedData>,\r\n  TNodeDO = NodeDO\r\n> {\r\n  _isSMNodeDef: true;\r\n  smData: TNodeData;\r\n  smComputed?: TNodeComputedFns;\r\n  smRelational?: NodeRelationalFns<TNodeRelationalData>;\r\n  smMutations?: TNodeMutations;\r\n  type: TNodeType;\r\n  repository: ISMNodeRepository;\r\n  do: new (data?: Record<string, any>) => TNodeDO;\r\n}\r\n\r\n/**\r\n * These inform the library how to query for data that is related to the node type we're building.\r\n * So, for example, if a user has meetings under them, one of the user's relational data properties is \"meetings\", which will be \"IChildren\".\r\n * This teaches the library how to interpret a query that asks for the user's meetings.\r\n */\r\nexport type NodeRelationalQueryBuilder<TOriginNode extends ISMNode> =\r\n  | IByReferenceQueryBuilder<TOriginNode, ISMNode>\r\n  | IChildrenQueryBuilder<TOriginNode>;\r\n\r\nexport type NodeRelationalQuery<TOriginNode extends ISMNode> =\r\n  | IChildrenQuery<TOriginNode, any>\r\n  | IByReferenceQuery<TOriginNode, any, any>;\r\n\r\n\r\nexport type ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord extends ISMNode | Maybe<ISMNode> | Record<string, ISMNode> | Maybe<Record<string,ISMNode>>> =\r\n  TTargetNodeOrTargetNodeRecord extends ISMNode\r\n  ? {\r\n      map: MapFnForNode<NonNullable<TTargetNodeOrTargetNodeRecord>>;\r\n  }\r\n  : TTargetNodeOrTargetNodeRecord extends Record<string, ISMNode>\r\n    ? {\r\n      [Tkey in keyof TTargetNodeOrTargetNodeRecord]: { map: MapFnForNode<TTargetNodeOrTargetNodeRecord[Tkey]> }\r\n    }\r\n    : never\r\nexport interface IByReferenceQueryBuilder<\r\n  TOriginNode extends ISMNode,\r\n  TTargetNodeOrTargetNodeRecord extends ISMNode | Maybe<ISMNode> | Record<string, ISMNode> | Maybe<Record<string,ISMNode>>\r\n> {\r\n  <TQueryBuilderOpts extends ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord>>(\r\n    queryBuilderOpts: TQueryBuilderOpts\r\n  ): IByReferenceQuery<TOriginNode, TTargetNodeOrTargetNodeRecord, TQueryBuilderOpts>;\r\n}\r\n\r\n\r\nexport enum SM_DATA_TYPES {\r\n  string = 's',\r\n  maybeString = 'mS',\r\n  number = 'n',\r\n  maybeNumber = 'mN',\r\n  boolean = 'b',\r\n  maybeBoolean = 'mB',\r\n  object = 'o',\r\n  maybeObject = 'mO',\r\n  record = 'r',\r\n  maybeRecord = 'mR',\r\n  array = 'a',\r\n  maybeArray = 'mA',\r\n}\r\n\r\nexport enum SM_RELATIONAL_TYPES {\r\n  byReference = 'bR',\r\n  children = 'bP'\r\n}\r\nexport interface IByReferenceQuery<\r\n  TOriginNode extends ISMNode,\r\n  TTargetNodeOrTargetNodeRecord extends ISMNode | Maybe<ISMNode> | Record<string, ISMNode> | Maybe<Record<string,ISMNode>>,\r\n  TQueryBuilderOpts extends ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord>\r\n> {\r\n  _smRelational: SM_RELATIONAL_TYPES.byReference;\r\n  idProp: ValidReferenceIdPropFromNode<TOriginNode>;\r\n  queryBuilderOpts: TQueryBuilderOpts\r\n  def: TTargetNodeOrTargetNodeRecord\r\n}\r\n\r\nexport interface IChildrenQueryBuilder<TSMNode extends ISMNode> {\r\n  <TMapFn extends MapFnForNode<TSMNode>>(opts: {\r\n    map: TMapFn;\r\n    pagination?: ISMQueryPagination;\r\n  }): IChildrenQuery<TSMNode, TMapFn>;\r\n}\r\n\r\nexport interface IChildrenQuery<\r\n  TSMNode extends ISMNode,\r\n  TMapFn extends MapFnForNode<TSMNode>\r\n> {\r\n  _smRelational: SM_RELATIONAL_TYPES.children;\r\n  def: TSMNode;\r\n  filtersAndPagination?: ISMQueryPagination;\r\n  map: TMapFn;\r\n  pagination?: ISMQueryPagination;\r\n  depth?: number;\r\n}\r\n\r\nexport interface ISMQueryPagination {}\r\n\r\nexport type NodeRelationalQueryBuilderRecord = Record<\r\n  string,\r\n  // the tsignore here is necessary\r\n  // because the generic that NodeRelationalQueryBuilder needs is\r\n  // the node definition for the origin of the relational queries\r\n  // which when defining a node, is the node being defined\r\n  // attempting to replicate the node here would always end up in a loop\r\n  // since we need the relational data to construct a node\r\n  // and need the node to construct the relational data (without this ts ignore)\r\n  // @ts-ignore\r\n  NodeRelationalQueryBuilder\r\n>;\r\n\r\nexport interface ISMNodeRepository {\r\n  byId(id: string): NodeDO;\r\n  onDataReceived(data: { id: string } & Record<string, any>): void;\r\n  onNodeDeleted(id: string): void;\r\n}\r\n\r\n/**\r\n * Returns the valid filter for a node\r\n * excluding properties which are arrays and records\r\n * and including properties which are nested in objects\r\n */\r\nexport type ValidFilterForNode<TSMNode extends ISMNode> = DeepPartial<{\r\n  [\r\n    TKey in keyof ExtractNodeData<TSMNode> as\r\n      ExtractNodeData<TSMNode>[TKey] extends ISMData<infer TSMDataParsedValueType, any, infer TBoxedValue>\r\n        ? IsArray<TSMDataParsedValueType> extends true\r\n          ? never\r\n          : TBoxedValue extends undefined \r\n            ? TKey\r\n            : TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\r\n              ? TKey\r\n              : never\r\n        : ExtractNodeData<TSMNode>[TKey] extends SMDataDefaultFn\r\n          ? IsArray<GetParsedValueTypeFromDefaultFn<ExtractNodeData<TSMNode>[TKey]>> extends true\r\n            ? never\r\n            : TKey\r\n          : TKey  \r\n  ]: TKey extends keyof GetResultingDataTypeFromNodeDefinition<TSMNode>\r\n    ? GetResultingDataTypeFromNodeDefinition<TSMNode>[TKey]\r\n    : never\r\n}>\r\n\r\nexport type QueryDefinitionTarget =\r\n  | { underIds: Array<string>, depth?: number }\r\n  | { depth: number }\r\n  | { id: string }\r\n  | { ids: Array<string> }\r\n    \r\n// The config needed by a query to get one or multiple nodes of a single type\r\nexport type QueryDefinition<\r\n  TSMNode extends ISMNode,\r\n  TMapFn extends MapFnForNode<TSMNode> | undefined,\r\n  TQueryDefinitionTarget extends QueryDefinitionTarget\r\n> = { \r\n  def: TSMNode;\r\n  map: TMapFn;\r\n  filter?: ValidFilterForNode<TSMNode>\r\n  target?: TQueryDefinitionTarget\r\n  tokenName?: string\r\n};\r\n\r\n// A query takes a record where you can specify aliases for each node type you're querying (including 2 aliases for different sets of the same node type)\r\n//\r\n// example:\r\n//  usersTodos: sm.queryDefinition({\r\n//    def: todo,\r\n//    under: [authenticatedUser.id],\r\n//    map: ({ id }) => ({ id })\r\n//  }),\r\n//  meetingTodos: sm.queryDefinition({\r\n//    def: todo,\r\n//    under: [meeting.id],\r\n//    map: ({ id } => ({ id })\r\n//  })\r\n//\r\n// adding params to QueryDefinition here breaks the return type of a query function, since the TNodeData and TNodeComputedData types being infered\r\n// in QueryDefinition would no longer be infered correctly. This would result in \"any\" types being returned for the query result, or implicit anys in the query fn definition\r\n// strangely, if we simply tell TS to ignore the error it works perfectly\r\n// eslint-disable-next-line\r\n// @ts-ignore\r\nexport type QueryDefinitions = Record<string, QueryDefinition | ISMNode>;\r\n\r\nexport type UseSubscriptionQueryDefinitionOpts = {doNotSuspend?: boolean}\r\n\r\nexport type UseSubscriptionQueryDefinition<\r\n  TSMNode extends ISMNode,\r\n  TMapFn extends MapFnForNode<TSMNode> | undefined,\r\n  TQueryDefinitionTarget extends QueryDefinitionTarget,\r\n  TUseSubscriptionQueryDefinitionOpts extends UseSubscriptionQueryDefinitionOpts\r\n> = QueryDefinition<TSMNode, TMapFn, TQueryDefinitionTarget> & {useSubOpts?: TUseSubscriptionQueryDefinitionOpts}\r\n// adding params to UseSubscriptionQueryDefinition here breaks the return type of a query function, since the TNodeData and TNodeComputedData types being infered\r\n// in UseSubscriptionQueryDefinition would no longer be infered correctly. This would result in \"any\" types being returned for the query result, or implicit anys in the query fn definition\r\n// strangely, if we simply tell TS to ignore the error it works perfectly\r\n// eslint-disable-next-line\r\n// @ts-ignore\r\nexport type UseSubscriptionQueryDefinitions = Record<string,  UseSubscriptionQueryDefinition | ISMNode>\r\n\r\nexport type QueryDataReturn<TQueryDefinitions extends QueryDefinitions> = {\r\n  [Key in keyof TQueryDefinitions]: GetResultingDataFromQueryDefinition<TQueryDefinitions[Key]>\r\n  \r\n};\r\n\r\nexport type GetResultingDataFromQueryDefinition<TQueryDefinition extends QueryDefinition<any,any,any> | ISMNode> = TQueryDefinition extends {\r\n  map: MapFn<any, any, any>;\r\n}\r\n  ? /**\r\n     * full query definition provided, with a map fn\r\n     */\r\n    TQueryDefinition extends { def: infer TSMNode; map: infer TMapFn }\r\n    ? TSMNode extends ISMNode\r\n      ? TMapFn extends MapFnForNode<TSMNode>\r\n        ? TQueryDefinition extends { target?: { id: string } }\r\n          ? ExtractQueriedDataFromMapFn<TMapFn, TSMNode>\r\n          : Array<ExtractQueriedDataFromMapFn<TMapFn, TSMNode>>\r\n        : never\r\n      : never\r\n    : never\r\n  : TQueryDefinition extends { def: ISMNode } // full query definition provided, but map function omitted // return the entirety of the node's data\r\n  ? TQueryDefinition extends { def: infer TSMNode }\r\n    ? TSMNode extends ISMNode\r\n      ? TQueryDefinition extends { target?: { id: string } }\r\n        ? GetAllAvailableNodeDataType<ExtractNodeData<TSMNode>, ExtractNodeComputedData<TSMNode>>\r\n        : Array<\r\n            GetAllAvailableNodeDataType<ExtractNodeData<TSMNode>, ExtractNodeComputedData<TSMNode>> \r\n          >\r\n      : never\r\n    : never\r\n  : TQueryDefinition extends ISMNode\r\n  ? /**\r\n     * shorthand syntax used, only a node definition was provided\r\n     */\r\n    Array<\r\n      GetAllAvailableNodeDataType<ExtractNodeData<TQueryDefinition>, ExtractNodeComputedData<TQueryDefinition>>\r\n    >\r\n  : never;\r\n\r\nexport type UseSubscriptionReturn<\r\n  TQueryDefinitions extends UseSubscriptionQueryDefinitions\r\n> = {\r\n  data: {\r\n    [key in keyof TQueryDefinitions]:\r\n      TQueryDefinitions[key] extends { useSubOpts?:{ doNotSuspend: true } }\r\n          ? Maybe<GetResultingDataFromQueryDefinition<TQueryDefinitions[key]>>\r\n          : GetResultingDataFromQueryDefinition<TQueryDefinitions[key]>\r\n  },\r\n  querying: boolean,\r\n  error: any\r\n}\r\n  \r\nexport type MapFnForNode<TSMNode extends ISMNode> = MapFn<\r\n  ExtractNodeData<TSMNode>,\r\n  ExtractNodeComputedData<TSMNode>,\r\n  ExtractNodeRelationalData<TSMNode>\r\n>;\r\n\r\nexport type MapFn<\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n  TNodeComputedData,\r\n  TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\r\n> = (\r\n  data: GetMapFnArgs<ISMNode<any, TNodeData, TNodeComputedData, TNodeRelationalData>>\r\n) => RequestedData<TNodeData, TNodeComputedData>;\r\n\r\nexport type GetMapFnArgs<\r\n  TSMNode extends ISMNode,\r\n> = TSMNode extends ISMNode<any, infer TNodeData, any, infer TNodeRelationalData>\r\n  ? {\r\n    [key in keyof TNodeData]: \r\n      TNodeData[key] extends ISMData<Maybe<Array<any>>>\r\n        ? TNodeData[key]\r\n        : TNodeData[key] extends ISMData<\r\n            any,\r\n            any,\r\n            Record<string, ISMData | SMDataDefaultFn>\r\n          >\r\n        // allows querying a partial of an object within a node\r\n        ? <TMapFn extends MapFn<GetSMBoxedValue<TNodeData[key]>, {}, {}>>(opts: {\r\n            map: TMapFn;\r\n          }) => TMapFn\r\n        : TNodeData[key];\r\n    } &\r\n      TNodeRelationalData\r\n  : never;\r\n\r\n// The accepted type for a map fn return\r\n// validates that the engineer is querying data that exists on the nodes\r\n// which gives us typo prevention :)\r\ntype RequestedData<\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n  TNodeComputedData extends Record<string, any>,\r\n  // TS-TYPE-TEST-1 making this a partial seems to cause TS to not throw errors when a random property is put into a map fn return with a bogus value\r\n  // this will likely lead to developers misusing the query function (such as forgetting to define a map function for a relational query)\r\n> = Partial<{\r\n      [Key in\r\n        keyof TNodeData\r\n        | keyof TNodeComputedData\r\n       ]: Key extends keyof TNodeData\r\n        ? TNodeData[Key] extends ISMData<Maybe<Array<any>>>\r\n          ? TNodeData[Key]\r\n          : TNodeData[Key] extends ISMData<Maybe<Record<string, any>>> // Allows querying partials of nested objects\r\n          ? MapFn<GetSMDataType<TNodeData[Key]>, {}, {}> // {} because there should be no computed data or relational data for objects nested in nodes\r\n          : TNodeData[Key]\r\n        : Key extends keyof TNodeComputedData   \r\n        ? TNodeComputedData[Key] \r\n        : never;\r\n  } | {}>\r\n\r\n\r\n// A generic to extract the resulting data based on a map fn\r\nexport type ExtractQueriedDataFromMapFn<\r\n  TMapFn extends MapFnForNode<TSMNode>,\r\n  TSMNode extends ISMNode\r\n> = { type: TSMNode['type'] }\r\n  & ExtractQueriedDataFromMapFnReturn<ReturnType<TMapFn>, TSMNode>\r\n  & ExtractNodeComputedData<TSMNode>;\r\n\r\n// From the return of a map fn, get the type of data that will be returned by that portion of the query, aka the expected response from the API\r\ntype ExtractQueriedDataFromMapFnReturn<\r\n  TMapFnReturn,\r\n  TSMNode extends ISMNode\r\n> = {\r\n  [Key in keyof TMapFnReturn]:\r\n    // when we passed through a relational property without specifying a mapFn\r\n    TMapFnReturn[Key] extends NodeRelationalQueryBuilder<any>\r\n    ? never\r\n    :\r\n    TMapFnReturn[Key] extends IByReferenceQuery<any,any,any>\r\n    ? ExtractQueriedDataFromByReferenceQuery<TMapFnReturn[Key]>\r\n    :\r\n    TMapFnReturn[Key] extends IChildrenQuery<any, any>\r\n    ? ExtractQueriedDataFromChildrenQuery<TMapFnReturn[Key]>  \r\n    :\r\n    TMapFnReturn[Key] extends MapFnForNode<TSMNode>\r\n    ? ExtractQueriedDataFromMapFn<TMapFnReturn[Key], TSMNode>  \r\n    :\r\n    // when we're querying data on the node we used as the \"def\"\r\n    TMapFnReturn[Key] extends ISMData | SMDataDefaultFn\r\n    ? GetSMDataType<TMapFnReturn[Key]>\r\n    :\r\n    // when we passed through an object property without specifying a mapFn\r\n    TMapFnReturn[Key] extends (opts: {map: MapFn<infer TBoxedValue,any,any>}) => MapFn<any, any, any>\r\n    ? GetResultingDataTypeFromProperties<TBoxedValue>\r\n    :\r\n    // when we're querying data inside a nested object\r\n    TMapFnReturn[Key] extends MapFn<any, any, any>\r\n    ? ExtractQueriedDataFromMapFn<TMapFnReturn[Key], TSMNode>\r\n    :\r\n    never;\r\n};\r\n\r\ntype ExtractQueriedDataFromChildrenQuery<\r\n  TChildrenQuery extends IChildrenQuery<any, any>\r\n> = TChildrenQuery extends IChildrenQuery<infer TSMNode, infer TMapFn>\r\n  ? Array<ExtractQueriedDataFromMapFn<TMapFn, TSMNode>>\r\n  : never;\r\n\r\n// Without this,ExtractQueriedDataFromByReferenceQuery and ExtractResultsUnionFromReferenceBuilder somehow cause a loop\r\n// even though ExtractQueriedDataFromByReferenceQuery does not call ExtractResultsUnionFromReferenceBuilder unless it's dealing with a record of node definitions (union representation)\r\n// borrowed this solution from this article\r\n// https://www.angularfix.com/2022/01/why-am-i-getting-instantiation-is.html\r\n// relavant github discussions:\r\n// https://github.com/microsoft/TypeScript/issues/34933\r\n// https://github.com/microsoft/TypeScript/pull/44997\r\n// https://github.com/microsoft/TypeScript/pull/45025\r\ntype Prev = [never, 0, 1];\r\n\r\ntype ExtractQueriedDataFromByReferenceQuery<\r\n  TByReferenceQuery extends IByReferenceQuery<any, any, any>,\r\n  D extends Prev[number] = 1\r\n> = \r\n  [D] extends [never] ? never :\r\n  TByReferenceQuery extends IByReferenceQuery<infer TOriginNode, infer TTargetNodeOrTargetNodeRecord, infer TQueryBuilderOpts>\r\n    ? IsMaybe<TTargetNodeOrTargetNodeRecord> extends true\r\n      ? TTargetNodeOrTargetNodeRecord extends ISMNode\r\n        ? TQueryBuilderOpts extends { map: MapFnForNode<NonNullable<TTargetNodeOrTargetNodeRecord>> }\r\n          ? Maybe<ExtractQueriedDataFromMapFn<TQueryBuilderOpts['map'], NonNullable<TTargetNodeOrTargetNodeRecord>>>\r\n          : never\r\n        : TTargetNodeOrTargetNodeRecord extends Record<string, ISMNode>\r\n          ? TQueryBuilderOpts extends { [key in keyof TTargetNodeOrTargetNodeRecord]: {map: MapFnForNode<TTargetNodeOrTargetNodeRecord[key]>} }\r\n            ? Maybe<ExtractResultsUnionFromReferenceBuilder<TOriginNode, TTargetNodeOrTargetNodeRecord, TQueryBuilderOpts, Prev[D]>>\r\n            : never\r\n          : never\r\n      : TTargetNodeOrTargetNodeRecord extends ISMNode\r\n        ? TQueryBuilderOpts extends { map: MapFnForNode<TTargetNodeOrTargetNodeRecord> }\r\n          ? ExtractQueriedDataFromMapFn<TQueryBuilderOpts['map'], TTargetNodeOrTargetNodeRecord>\r\n          : never\r\n        : TTargetNodeOrTargetNodeRecord extends Record<string, ISMNode>\r\n        ? TQueryBuilderOpts extends { [key in keyof TTargetNodeOrTargetNodeRecord]: {map: MapFnForNode<TTargetNodeOrTargetNodeRecord[key]>} }\r\n            ? ExtractResultsUnionFromReferenceBuilder<TOriginNode, TTargetNodeOrTargetNodeRecord, TQueryBuilderOpts, Prev[D]>\r\n            : never\r\n          : never\r\n    : never\r\n\r\ntype ExtractResultsUnionFromReferenceBuilder<\r\n  TOriginNode extends ISMNode,\r\n  TTargetNodeOrTargetNodeRecord extends Record<string, ISMNode>,\r\n  TQueryBuilderOpts extends ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord>,\r\n  D extends Prev[number]\r\n> = ExtractObjectValues<{\r\n  [key in keyof TQueryBuilderOpts]:\r\n      key extends keyof TTargetNodeOrTargetNodeRecord \r\n        ? TQueryBuilderOpts[key] extends ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord[key]>\r\n          ?\r\n            ExtractQueriedDataFromByReferenceQuery<\r\n              IByReferenceQuery<\r\n                TOriginNode,\r\n                TTargetNodeOrTargetNodeRecord[key],\r\n                // says this doesn't satisfy the constraint of ByReferenceQueryBuilderOpts<TTargetNodeOrTargetNodeRecord[key]>\r\n                // but it does, and it works anyway\r\n                // @ts-ignore\r\n                { map: TQueryBuilderOpts[key]['map'] }\r\n               >,\r\n               D\r\n            >\r\n          : never\r\n        : never\r\n}>\r\n\r\ntype ExtractObjectValues<TObject extends Record<string,any>> = TObject extends Record<string, infer TValueType> ? TValueType : never\r\n\r\nexport type ExtractNodeData<TSMNode extends ISMNode> = TSMNode extends ISMNode<\r\n  any,\r\n  infer TNodeData\r\n>\r\n  ? TNodeData\r\n  : never;\r\n\r\ntype ExtractNodeComputedData<TSMNode extends ISMNode> = TSMNode extends ISMNode<\r\n  any,\r\n  any,\r\n  infer TNodeComputedData\r\n>\r\n  ? TNodeComputedData\r\n  : never;\r\n\r\ntype ExtractNodeRelationalData<\r\n  TSMNode extends ISMNode\r\n> = TSMNode extends ISMNode<any, any, any, infer TNodeRelationalData>\r\n  ? TNodeRelationalData\r\n  : never;\r\n\r\n// type ExtractNodeMutations<TSMNode extends ISMNode> = TSMNode extends ISMNode<\r\n//   any,\r\n//   any,\r\n//   any,\r\n//   infer TNodeMutations\r\n// >\r\n//   ? TNodeMutations\r\n//   : never;\r\n\r\n/**\r\n * a record of all the queries identified in this query definitions\r\n * looks something like this\r\n *\r\n * {\r\n *   // alias\r\n *   usersTodos: {\r\n *     // the SMNode we're querying\r\n *     def: todo,\r\n *     // id used as under\r\n *     under: ['some-id-I-want-to-get-children-for'],\r\n *     // ^ could have under or ids, not both\r\n *     ids: ['some-specific-node-id-im-trying-to-query'],\r\n *     // properties being queried on this todo, Array<keyof Todo>\r\n *     properties: ['id', 'task'],\r\n *     // relational data being queried\r\n *     relational: {\r\n *       // alias for the relational query result\r\n *       assignee: {\r\n *         // the SM node for the relational data we're querying\r\n *         def: user,\r\n *         properties: ['firstName', 'lastName'],\r\n *\r\n *         // if the todo node defines the assignee as being a \"child\" of a todo (meaning there would have to be a V edge from todo to user).\r\n *         // This would also return an array of users, instead of a single user in that case.\r\n *         children: true,\r\n *         // OR if the todo node defines the assignee as being stored with a foreign key (in todo.assigneeId)\r\n *         byReference: true, idProp: 'assigneeId',\r\n *       }\r\n *     }\r\n *   })\r\n * }\r\n */\r\nexport type BaseQueryRecordEntry = {\r\n  def: ISMNode;\r\n  properties: Array<string>;\r\n  relational?: Record<string, RelationalQueryRecordEntry>;\r\n};\r\n\r\nexport type QueryRecordEntry = BaseQueryRecordEntry &\r\n  (\r\n    | { underIds: Array<string>; depth?: number }\r\n    | { ids: Array<string> }\r\n    | { id: string }\r\n  );\r\n\r\nexport type RelationalQueryRecordEntry =\r\n  | (BaseQueryRecordEntry & { children: true; depth?: number }) // will use GetChildren to query this data\r\n  | (BaseQueryRecordEntry & { byReference: true; idProp: string }); // will use GetReference to query this data\r\n\r\nexport type QueryRecord = Record<string, QueryRecordEntry>;\r\n\r\n// export type SMNodeRequestUpdate<TNodeData> = (opts: {\r\n//   payload: DeepPartial<TNodeData>;\r\n//   // updateNode: (opts: IUpdateNodeOpts<TNodeData>) => void;\r\n// }) => Promise<void>;\r\n\r\n// type SMNodeMutationOpts<TNodeData> = {\r\n//   // nodeData: TNodeData;\r\n//   // createNode(): void;\r\n//   // createEdge(opts: ICreateEdgeOpts): void;\r\n//   // deleteNode(opts: IDeleteNodeOpts): void;\r\n//   // deleteEdge(opts: IDeleteEdgeOpts): void;\r\n//   // updateNode(opts: IUpdateNodeOpts<TNodeData>): void;\r\n//   // requestUpdate: SMNodeRequestUpdate<TNodeData>;\r\n// };\r\n\r\nexport interface IDOProxy {\r\n  updateRelationalResults(\r\n    newRelationalResults: Maybe<Record<string, IDOProxy | Array<IDOProxy>>>\r\n  ): void;\r\n}\r\n","// thrown when any property on the DO is accessed but is not marked as upToDate\r\n// by calling DO.setUpToDateData({ [propName]: true })\r\n// or DO.setUpToDateData({ nested: { [propName]: true } })\r\n// this is done automatically by smData fetchers, smQuery and smSubscribe\r\n// so this error should only occur when data is accessed but was never queried or is not currently being subscribed to (is cached only)\r\nexport class SMNotUpToDateException extends Error {\r\n  public propName: string;\r\n\r\n  constructor(opts: { propName: string; nodeType: string; queryId: string }) {\r\n    super(\r\n      `SMNotUpToDate exception - The property \"${opts.propName}\" on the DO for the node type ${opts.nodeType} was read but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\r\n    );\r\n    this.propName = opts.propName;\r\n  }\r\n}\r\n\r\nexport class SMNotUpToDateInComputedException extends Error {\r\n  constructor(opts: {\r\n    computedPropName: string;\r\n    propName: string;\r\n    nodeType: string;\r\n    queryId: string;\r\n  }) {\r\n    super(\r\n      `SMNotUpToDateInComputed exception - The property \"${opts.propName}\" on the DO for the node type \"${opts.nodeType}\" was read for the computed property \"${opts.computedPropName}\" but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\r\n    );\r\n  }\r\n}\r\n\r\nexport class SMNotCachedException extends Error {\r\n  constructor(opts: { nodeType: string; id: string }) {\r\n    super(\r\n      `SMNotCached exception - Attempted to get the node with the type \"${opts.nodeType}\" and id \"${opts.id}\" but it was not cached.`\r\n    );\r\n  }\r\n}\r\n\r\nexport class SMDataTypeException extends Error {\r\n  constructor(opts: { dataType: string; value: any }) {\r\n    super(\r\n      `SMDataType exception - the data type ${opts.dataType} received a bad value. Value: \"${opts.value}\"`\r\n    );\r\n  }\r\n}\r\n\r\nexport class SMDataTypeExplicitDefaultException extends Error {\r\n  constructor(opts: { dataType: string }) {\r\n    super(\r\n      `SMDataTypeExplicitDefaultException - the data type ${opts.dataType} requires setting an explicit default value for non-optional properties`\r\n    );\r\n  }\r\n}\r\n\r\nexport class SMDataParsingException extends Error {\r\n  constructor(opts: { receivedData: any; message: string }) {\r\n    super(\r\n      `SMDataParsing exception - ${opts.message}\\nData: ${JSON.stringify(\r\n        opts.receivedData,\r\n        null,\r\n        2\r\n      )}.`\r\n    );\r\n  }\r\n}\r\n\r\nexport class SMUnexpectedSubscriptionMessageException extends Error {\r\n  public exception: {\r\n    subscriptionMessage: Record<string, any>;\r\n    description: string;\r\n  };\r\n\r\n  constructor(exception: {\r\n    subscriptionMessage: Record<string, any>;\r\n    description: string;\r\n  }) {\r\n    super(\r\n      `SMUnexpectedSubscriptionMessage exception - unexpected subscription message received`\r\n    );\r\n    this.exception = exception;\r\n  }\r\n}\r\n\r\nexport class SMUnexpectedQueryResultException extends Error {\r\n  public exception: {\r\n    queryRecord: Record<string, any>;\r\n    resultData: Record<string, any>;\r\n  };\r\n\r\n  constructor(exception: {\r\n    queryRecord: Record<string, any>;\r\n    resultData: Record<string, any>;\r\n  }) {\r\n    super(\r\n      `SMUnexpectedQueryResult exception - unexpected query result received`\r\n    );\r\n    this.exception = exception;\r\n  }\r\n}\r\n\r\nexport function throwLocallyLogInProd(error: Error) {\r\n  if (process?.env?.NODE_ENV !== 'production') {\r\n    throw error;\r\n  } else {\r\n    console.error(error);\r\n  }\r\n}\r\n","import {\r\n  SMDataTypeException,\r\n  SMDataTypeExplicitDefaultException,\r\n  throwLocallyLogInProd,\r\n} from './exceptions';\r\nimport {\r\n  GetResultingDataTypeFromProperties,\r\n  GetSMDataType,\r\n  IByReferenceQueryBuilder,\r\n  IChildrenQueryBuilder,\r\n  ISMData,\r\n  ISMNode,\r\n  ISMQueryPagination,\r\n  MapFnForNode,\r\n  Maybe,\r\n  QueryDefinitionTarget,\r\n  SMDataDefaultFn,\r\n  ValidReferenceIdPropFromNode,\r\n  SM_DATA_TYPES,\r\n  SM_RELATIONAL_TYPES,\r\n  ByReferenceQueryBuilderOpts,\r\n  UseSubscriptionQueryDefinitionOpts,\r\n  UseSubscriptionQueryDefinition,\r\n} from './types';\r\n\r\nexport class SMData<\r\n  TParsedValue,\r\n  TSMValue,\r\n  TBoxedValue extends\r\n    | ISMData\r\n    | SMDataDefaultFn\r\n    | Record<string, ISMData | SMDataDefaultFn>\r\n    | undefined\r\n> implements ISMData<TParsedValue, TSMValue, TBoxedValue> {\r\n  type: SM_DATA_TYPES;\r\n  parser: (smValue: TSMValue) => TParsedValue;\r\n  boxedValue: TBoxedValue;\r\n  defaultValue: Maybe<TParsedValue>;\r\n  isOptional: boolean;\r\n\r\n  constructor(opts: {\r\n    type: SM_DATA_TYPES;\r\n    parser: (smValue: TSMValue) => TParsedValue;\r\n    boxedValue?: TBoxedValue;\r\n    defaultValue?: TParsedValue;\r\n    isOptional: boolean;\r\n  }) {\r\n    this.type = opts.type;\r\n    this.parser = opts.parser;\r\n    this.boxedValue = opts.boxedValue as TBoxedValue;\r\n    this.defaultValue = opts.defaultValue ?? null;\r\n    this.isOptional = opts.isOptional;\r\n  }\r\n}\r\n\r\n/**\r\n * smData serve 2 purposes:\r\n * 1) they convert strings from SM into their real types (objects, strings, numbers, booleans)\r\n * 2) they serve as a way for TS to infer the data type of the node based on the smData types used,\r\n */\r\n\r\nexport const string = <TStringType extends string = string>(\r\n  defaultValue: TStringType\r\n) =>\r\n  new SMData<TStringType, TStringType, undefined>({\r\n    type: SM_DATA_TYPES.string,\r\n    parser: value =>\r\n      value != null\r\n        ? ((String(value) as unknown) as TStringType)\r\n        : (value as TStringType),\r\n    defaultValue,\r\n    isOptional: false,\r\n  });\r\n\r\nstring._default = string('');\r\n\r\nstring.optional = new SMData<Maybe<string>, Maybe<string>, undefined>({\r\n  type: SM_DATA_TYPES.maybeString,\r\n  parser: value => (value != null ? String(value) : value),\r\n  isOptional: true,\r\n});\r\n\r\nexport const number = (\r\n  defaultValue: number\r\n): SMData<number, string, undefined> =>\r\n  new SMData<number, string, undefined>({\r\n    type: SM_DATA_TYPES.number,\r\n    parser: value => {\r\n      const parsed = Number(value);\r\n\r\n      if (isNaN(parsed)) {\r\n        throwLocallyLogInProd(\r\n          new SMDataTypeException({\r\n            dataType: SM_DATA_TYPES.number,\r\n            value,\r\n          })\r\n        );\r\n        return number._default.defaultValue as number;\r\n      }\r\n\r\n      return parsed;\r\n    },\r\n    defaultValue,\r\n    isOptional: false,\r\n  }) as SMData<number, string, undefined>;\r\n\r\nnumber._default = number(0);\r\n\r\nnumber.optional = new SMData<Maybe<number>, Maybe<string>, undefined>({\r\n  type: SM_DATA_TYPES.maybeNumber,\r\n  parser: value => {\r\n    if (value != null) {\r\n      return Number(value);\r\n    }\r\n    return value;\r\n  },\r\n  isOptional: true,\r\n});\r\n\r\nexport const boolean = <TDefaultValue extends boolean>(\r\n  defaultValue?: TDefaultValue\r\n) => {\r\n  if (defaultValue === undefined) {\r\n    return (new SMDataTypeExplicitDefaultException({\r\n      dataType: SM_DATA_TYPES.boolean,\r\n    }) as unknown) as ISMData<boolean, string | boolean, undefined>;\r\n  }\r\n\r\n  return new SMData<boolean, string | boolean, undefined>({\r\n    type: SM_DATA_TYPES.boolean,\r\n    parser: value => {\r\n      if (value === 'true' || value === true) {\r\n        return true;\r\n      } else if (value === 'false' || value === false) {\r\n        return false;\r\n      } else {\r\n        throw new SMDataTypeException({\r\n          dataType: SM_DATA_TYPES.boolean,\r\n          value: value,\r\n        });\r\n      }\r\n    },\r\n    defaultValue,\r\n    isOptional: false,\r\n  }) as TDefaultValue extends undefined\r\n    ? Error\r\n    : ISMData<boolean, string | boolean, undefined>;\r\n};\r\n// need this in order to trigger an error when a user doesn't provide a default\r\n//@ts-ignore\r\nboolean._default = boolean();\r\n\r\nboolean.optional = new SMData<\r\n  Maybe<boolean>,\r\n  Maybe<string | boolean>,\r\n  undefined\r\n>({\r\n  type: SM_DATA_TYPES.maybeBoolean,\r\n  parser: value => {\r\n    if (value == null) return value;\r\n\r\n    if (value === 'true' || value === true) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  },\r\n  isOptional: true,\r\n});\r\n\r\ntype ObjectSMDataType = {\r\n  <TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>>(\r\n    boxedValue: TBoxedValue\r\n  ): SMData<\r\n    GetResultingDataTypeFromProperties<TBoxedValue>,\r\n    GetResultingDataTypeFromProperties<TBoxedValue>,\r\n    TBoxedValue\r\n  >;\r\n  _default: any;\r\n  optional: <TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>>(\r\n    boxedValue: TBoxedValue\r\n  ) => SMData<\r\n    Maybe<GetResultingDataTypeFromProperties<TBoxedValue>>,\r\n    Maybe<GetResultingDataTypeFromProperties<TBoxedValue>>,\r\n    TBoxedValue\r\n  >;\r\n};\r\n\r\nexport const object: ObjectSMDataType = boxedValue =>\r\n  new SMData({\r\n    type: SM_DATA_TYPES.object,\r\n    /**\r\n     * Doesn't need to do any parsing on the data to convert strings to their real types\r\n     * That's done by the DO class's \"objectDataSetter\" method\r\n     */\r\n    parser: val => val,\r\n    boxedValue,\r\n    isOptional: false,\r\n  });\r\n\r\nobject._default = null;\r\n\r\nobject.optional = boxedValue =>\r\n  new SMData({\r\n    type: SM_DATA_TYPES.maybeObject,\r\n    /**\r\n     * Doesn't need to do any parsing on the data to convert strings to their real types\r\n     * That's done by the DO class's \"objectDataSetter\" method\r\n     */\r\n    parser: val => val,\r\n    boxedValue,\r\n    isOptional: true,\r\n  });\r\n\r\nexport const record = <\r\n  TKey extends string,\r\n  TBoxedValue extends ISMData | SMDataDefaultFn\r\n>(\r\n  boxedValue: TBoxedValue\r\n) => {\r\n  const parsedBoxedValue: TBoxedValue =\r\n    // will be a function if no explicit default set\r\n    typeof boxedValue === 'function'\r\n      ? ((boxedValue as any)._default as TBoxedValue)\r\n      : (boxedValue as TBoxedValue);\r\n\r\n  return new SMData<\r\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\r\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\r\n    TBoxedValue\r\n  >({\r\n    type: SM_DATA_TYPES.record,\r\n    parser: val => val,\r\n    boxedValue: boxedValue as typeof parsedBoxedValue,\r\n    isOptional: false,\r\n    defaultValue: {} as Record<string, any>,\r\n  });\r\n};\r\n\r\nrecord.optional = <TBoxedValue extends ISMData | SMDataDefaultFn>(\r\n  boxedValue: TBoxedValue\r\n) => {\r\n  const parsedBoxedValue: ISMData =\r\n    // will be a function if no explicit default set\r\n    typeof boxedValue === 'function'\r\n      ? ((boxedValue as any)._default as ISMData)\r\n      : (boxedValue as ISMData);\r\n\r\n  return new SMData<\r\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\r\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\r\n    typeof parsedBoxedValue\r\n  >({\r\n    type: SM_DATA_TYPES.maybeRecord,\r\n    parser: val => val,\r\n    boxedValue: parsedBoxedValue,\r\n    isOptional: true,\r\n    defaultValue: null,\r\n  });\r\n};\r\n\r\nrecord._default = null as any;\r\n\r\nexport const array = <TBoxedValue extends ISMData | SMDataDefaultFn>(\r\n  boxedValue: TBoxedValue\r\n) => {\r\n  const parsedBoxedValue: TBoxedValue =\r\n    // will be a function if no explicit default set\r\n    typeof boxedValue === 'function'\r\n      ? ((boxedValue as any)._default as TBoxedValue)\r\n      : (boxedValue as TBoxedValue);\r\n\r\n  function smArray(defaultValue: Array<GetSMDataType<TBoxedValue>>) {\r\n    return new SMData<\r\n      Array<GetSMDataType<TBoxedValue>>,\r\n      Array<GetSMDataType<TBoxedValue>>,\r\n      TBoxedValue\r\n    >({\r\n      type: SM_DATA_TYPES.array,\r\n      parser: value => value,\r\n      boxedValue: parsedBoxedValue,\r\n      defaultValue,\r\n      isOptional: false,\r\n    });\r\n  }\r\n\r\n  smArray.optional = new SMData<\r\n    Maybe<Array<GetSMDataType<TBoxedValue>>>,\r\n    Maybe<Array<GetSMDataType<TBoxedValue>>>,\r\n    TBoxedValue\r\n  >({\r\n    type: SM_DATA_TYPES.maybeArray,\r\n    parser: value => value,\r\n    boxedValue: parsedBoxedValue,\r\n    isOptional: true,\r\n  });\r\n\r\n  smArray._default = smArray([]);\r\n\r\n  return smArray;\r\n};\r\n\r\nexport const reference = <\r\n  TOriginNode extends ISMNode,\r\n  TTargetNodeOrTargetNodeRecord extends\r\n    | ISMNode\r\n    | Maybe<ISMNode>\r\n    | Record<string, ISMNode>\r\n    | Maybe<Record<string, ISMNode>>\r\n>(opts: {\r\n  def: NonNullable<TTargetNodeOrTargetNodeRecord>;\r\n  idProp: ValidReferenceIdPropFromNode<TOriginNode>;\r\n}) => {\r\n  return (<\r\n    TQueryBuilderOpts extends ByReferenceQueryBuilderOpts<\r\n      TTargetNodeOrTargetNodeRecord\r\n    >\r\n  >(\r\n    queryBuilderOpts: TQueryBuilderOpts\r\n  ) => {\r\n    return {\r\n      ...opts,\r\n      idProp: (opts.idProp as string).replaceAll(\r\n        '.',\r\n        OBJECT_PROPERTY_SEPARATOR\r\n      ) as ValidReferenceIdPropFromNode<TOriginNode>,\r\n      _smRelational: SM_RELATIONAL_TYPES.byReference,\r\n      queryBuilderOpts,\r\n    };\r\n  }) as IByReferenceQueryBuilder<TOriginNode, TTargetNodeOrTargetNodeRecord>;\r\n};\r\n\r\nexport const children = <TSMNode extends ISMNode>(opts: {\r\n  def: TSMNode;\r\n  depth?: number;\r\n}) => {\r\n  return ((queryBuilderOpts: {\r\n    map: MapFnForNode<TSMNode>;\r\n    pagination: ISMQueryPagination;\r\n  }) => {\r\n    return {\r\n      ...opts,\r\n      _smRelational: SM_RELATIONAL_TYPES.children,\r\n      map: queryBuilderOpts.map,\r\n      depth: opts.depth,\r\n    };\r\n  }) as IChildrenQueryBuilder<TSMNode>;\r\n};\r\n\r\nexport const OBJECT_PROPERTY_SEPARATOR = '__dot__';\r\n\r\nexport const OBJECT_IDENTIFIER = '__object__';\r\n\r\n// HACK ALERT! Exists only to make TS work the way we need it\r\n// It makes it possible to accept multiple node types within a record of query definitions, without losing type safety\r\n// See this for a simplified example https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBBwYHMA8ARAhlXAFQE8AHAUwD4AKFMNdALkQHkBbGKTASQGUYw6ADbkAwqgw58RMlQA0iAOQB9ZTADOJCr1zByAVXXlCACzET0AMXDR4YAIT3FlAJTM+A4efqS8BLVSIAN4AUIiIAE7kUCARSEEAdEl0DHIqapqyOnqGxmbiPlY2sAiOisxQESDkiAC+IfUhAlDkEcC4EDXchHAAJnB+uMFhiDC9zOqVniME6gDWE1OCDSEhdJOIUH0D0u49-YOIALzBo+NKAIwATADMigqzC0r9m2aIveTkvYp1q1CyiAAitUIsRLGApP5ZJRjohqL1dohBgEXMcYQAFXARWC4ISQmQUSirZqtdqdRAeQQiAoMfEBGGhcLhdIaALZAxGUzeBjWSAlBxOCpVchyEbhBEEZjI2SipmIACOIOIzGBrTBEOlhJWTTALTaHS6AFkQEJYDSMMNwgBtObkZWISYRTwAXXc-Cp3MkuDAxCJjXWUEQbGIADk+uRBu5jaaYOb0LDGYgQEYIpptupmInxYitgdpLKmYq1cxqEEzg9cPM6qijjDS+XNpW5tWRrUC7ihPs4BnkBZS2L3jntoMC+Ei6CS2WxhWq7Ua3Wp70Z82562XCsgA\r\nexport function queryDefinition<\r\n  TSMNode extends ISMNode,\r\n  TMapFn extends MapFnForNode<TSMNode> | undefined,\r\n  TQueryDefinitionTarget extends QueryDefinitionTarget,\r\n  TUseSubscriptionOpts extends UseSubscriptionQueryDefinitionOpts\r\n>(\r\n  queryDefinition: UseSubscriptionQueryDefinition<\r\n    TSMNode,\r\n    TMapFn,\r\n    TQueryDefinitionTarget,\r\n    TUseSubscriptionOpts\r\n  >\r\n) {\r\n  return queryDefinition;\r\n}\r\n","import { deepClone } from './dataUtilities';\r\nimport { Maybe, NodeDO } from './types';\r\n\r\n/**\r\n * This class is responsible for handling all logic pertaining optimistic updates.\r\n *\r\n * It works by intercepting all incoming messages about nodes that the user queries or is subscribed to\r\n * Then, it also intercepts requests to updateNode and updateNodes within a transaction\r\n *\r\n * It optimistically updates the state at the DO level, while also keeping track of known persisted states\r\n * (the ones that derived from messages received by the node repository)\r\n *\r\n * You might wonder, why keep track of all persisted states, rather than just the persisted state at the time of the last update request?\r\n *\r\n * I'll answer that with a question:\r\n * If we call updateNode/updateNodes several times with the same node id, and get a message about a version older than the last update, how do we deal with that?\r\n *   We could ignore it, since it will likely be overwritten by the update in flight, but this seems risky because we can't assume that the update will be successful. Ignoring that incoming update could lead to stale states if the request does fail.\r\n *   We could also apply it, since we know it's data that's been persisted in SM. This would likely lead to UX feeling janky. For example, if a user is typing into an input and we're sending debounced updates to SM\r\n *      and with each update optimistically updating our in memory cache (the DO), but also applying incoming persisted states, the value being displayed for that field would change erratically.\r\n *\r\n * I believe a fix for this is to keep applying only optimistic updates to in memory cache if there is any in flight request, while keeping track of all received persisted states\r\n * We short circuit the repository's onDataReceived so it no longer updates the DO, if any updates are in flight. Instead, it only tells the OptimisticUpdatesOrchestrator that there is a new persisted state.\r\n * If a single update request fails, and there are no other updates in flight, revert to the last persisted state. Decrease number of in flight requests.\r\n * If an update request in a group of update requests fails, and there are other updates in flight to SM, decrease number of in flight requests. Don't revert to last persisted state, since this would cause the erratic behavior described above.\r\n * If an update request succeeds (solo or in a group), simply decrease number of in flight requests.\r\n *\r\n * Once the number of in flight requests reaches 0, the repository would no longer get short circuited.\r\n *\r\n * Then, we can decide how to update the state on the DO, by leaving it at the newest optimistic update state\r\n *\r\n * We would stop capturing persisted data in OptimisticUpdatesOrchestrator for this particular node (which we identify by its id),\r\n * and delete any persisted data for that node that is currently cached in the OptimisticUpdatesOrchestrator to avoid memory leaks.\r\n */\r\nexport class OptimisticUpdatesOrchestrator {\r\n  private DOsById: Record<string, NodeDO> = {};\r\n  private lastKnownPersistedDataById: Record<string, Record<string, any>> = {};\r\n  private inFlightRequestsById: Record<\r\n    string,\r\n    Array<{ rollbackState: Record<string, any> }>\r\n  > = {};\r\n\r\n  public onDOConstructed = (DO: NodeDO) => {\r\n    if (!DO.id) throw Error('No id found in DO');\r\n    this.DOsById[DO.id] = DO;\r\n  };\r\n\r\n  public onDODeleted = (DO: NodeDO) => {\r\n    if (!DO.id) throw Error('No id found in DO');\r\n    delete this.DOsById[DO.id];\r\n    delete this.lastKnownPersistedDataById[DO.id];\r\n  };\r\n\r\n  public onPersistedDataReceived = (opts: {\r\n    data: { id: string; version: number; lastUpdatedBy: string } & Record<\r\n      string,\r\n      any\r\n    >;\r\n    applyUpdateToDO: () => void;\r\n  }) => {\r\n    const nodeId = opts.data.id;\r\n\r\n    // this is how we short circuit ths repository\r\n    // read comment above this class to understand why\r\n    if (this.inFlightRequestsById[nodeId]) {\r\n      this.lastKnownPersistedDataById[nodeId] = opts.data;\r\n    } else {\r\n      opts.applyUpdateToDO();\r\n    }\r\n  };\r\n\r\n  public onUpdateRequested = (update: {\r\n    id: string;\r\n    payload: Record<string, any>;\r\n  }) => {\r\n    const DO = this.getDOById(update.id);\r\n    // No DO found in cache means we're likely in a unit test, or possible the node was dropped right as the update was request\r\n    // Better to simply do nothing than to throw an error here.\r\n    if (!DO)\r\n      return {\r\n        onUpdateSuccessful: () => {},\r\n        onUpdateFailed: () => {},\r\n      };\r\n\r\n    const rollbackState = {\r\n      // persisted data gets extended on the node, so cloning it here so it doesn't get mutated by an incoming update\r\n      ...deepClone(DO.persistedData),\r\n      version: DO.version,\r\n      lastUpdatedBy: DO.lastUpdatedBy,\r\n    };\r\n\r\n    if (!this.inFlightRequestsById[update.id]) {\r\n      // before any in flight requests go out, we know that the persisted data on a DO is truly persisted\r\n      this.lastKnownPersistedDataById[update.id] = rollbackState;\r\n      this.inFlightRequestsById[update.id] = [{ rollbackState }];\r\n    } else {\r\n      // if requests are in flight, the \"persisted\" data on a DO may actually originate from an optimistic update\r\n      // this is simply to avoid introducing optimistic update logic in the DO class.\r\n      // in that case, the true persisted state will be intercepted from the repository by \"onPersistedDataReceived\" above\r\n      this.inFlightRequestsById[update.id].push({ rollbackState });\r\n    }\r\n\r\n    const updateIdx = this.inFlightRequestsById[update.id].length - 1;\r\n\r\n    const currentVersion = Number(DO.version);\r\n    const newVersion = currentVersion + 1;\r\n\r\n    DO.onDataReceived({ ...update.payload, version: newVersion });\r\n\r\n    return {\r\n      onUpdateFailed: () => {\r\n        this.handleUpdateFailed({ updateIdx, id: update.id });\r\n      },\r\n      onUpdateSuccessful: () => {\r\n        this.handleUpdateSuccessful({ updateIdx, id: update.id });\r\n      },\r\n    };\r\n  };\r\n\r\n  private handleUpdateFailed(opts: { updateIdx: number; id: string }) {\r\n    const inFlightRequestsForThisNode = this.inFlightRequestsById[opts.id];\r\n    const wasLastTriggeredUpdate =\r\n      inFlightRequestsForThisNode.length === opts.updateIdx + 1;\r\n    if (wasLastTriggeredUpdate) {\r\n      const DO = this.getDOById(opts.id);\r\n      if (!DO) return;\r\n      const hasPreviousInFlightUpdate = inFlightRequestsForThisNode.length > 1;\r\n      if (hasPreviousInFlightUpdate) {\r\n        const previousInFlightRollbackState =\r\n          inFlightRequestsForThisNode[inFlightRequestsForThisNode.length - 1]\r\n            .rollbackState;\r\n        DO.onDataReceived(previousInFlightRollbackState, {\r\n          // __unsafeIgnoreVersion should used by OptimisticUpdatesOrchestrator ONLY\r\n          // it allows setting the data on the DO to a version older than the last optimistic update\r\n          // so that we can revert on a failed request\r\n          __unsafeIgnoreVersion: true,\r\n        });\r\n      } else {\r\n        DO.onDataReceived(this.lastKnownPersistedDataById[opts.id], {\r\n          // __unsafeIgnoreVersion should used by OptimisticUpdatesOrchestrator ONLY\r\n          // it allows setting the data on the DO to a version older than the last optimistic update\r\n          // so that we can revert on a failed request\r\n          __unsafeIgnoreVersion: true,\r\n        });\r\n        inFlightRequestsForThisNode.splice(opts.updateIdx, 1);\r\n      }\r\n    }\r\n\r\n    inFlightRequestsForThisNode.splice(opts.updateIdx, 1);\r\n\r\n    this.cleanupIfNoInFlightRequests(opts.id);\r\n  }\r\n\r\n  private handleUpdateSuccessful(opts: { updateIdx: number; id: string }) {\r\n    const inFlightRequestsForThisNode = this.inFlightRequestsById[opts.id];\r\n    inFlightRequestsForThisNode.splice(opts.updateIdx, 1);\r\n    this.cleanupIfNoInFlightRequests(opts.id);\r\n  }\r\n\r\n  private getDOById(id: string): Maybe<NodeDO> {\r\n    const DO = this.DOsById[id];\r\n    return DO;\r\n  }\r\n\r\n  private cleanupIfNoInFlightRequests(id: string) {\r\n    if (!this.inFlightRequestsById[id].length) {\r\n      delete this.lastKnownPersistedDataById[id];\r\n      delete this.inFlightRequestsById[id];\r\n    }\r\n  }\r\n}\r\n","import { isArray, isObject } from 'lodash';\r\n\r\n/**\r\n * Clones an object or array. Recurses into nested objects and arrays for deep clones.\r\n */\r\nexport function deepClone<T extends Record<string, any> | Array<any>>(\r\n  obj: T\r\n): T {\r\n  if (typeof obj !== 'object' || obj === null || obj === undefined) {\r\n    return obj; // return the value if obj is not an object\r\n  }\r\n\r\n  if (Array.isArray(obj)) {\r\n    const outputArray = ([] as unknown) as T;\r\n\r\n    obj.forEach((item: any) => outputArray.push(deepClone(item)));\r\n\r\n    return outputArray;\r\n  } else {\r\n    const outputObject = ({} as unknown) as T;\r\n    for (const key in obj) {\r\n      outputObject[key] = deepClone(obj[key]);\r\n    }\r\n\r\n    return outputObject;\r\n  }\r\n}\r\n\r\n// clear an object (and nested objects)\r\n// by deleting all of its props\r\nexport function clearObject(opts: { object: Record<string, any> }) {\r\n  Object.keys(opts.object).forEach(objectProp => {\r\n    if (typeof opts.object[objectProp] === 'object') {\r\n      clearObject({ object: opts.object[objectProp] });\r\n    } else {\r\n      delete opts.object[objectProp];\r\n    }\r\n  });\r\n}\r\n\r\n// extend an object by mutating its props in place\r\n// based on the values received in \"extension\"\r\nexport function extend(opts: {\r\n  object: Record<string, any>;\r\n  extension: Record<string, any>;\r\n  deleteKeysNotInExtension: boolean;\r\n  extendNestedObjects: boolean;\r\n}) {\r\n  const handledExtensionProps: Array<string> = [];\r\n\r\n  // first loop over every key in the object to extend and\r\n  // 1) if opts.deleteKeysNotInExtension, delete properties not in the extension object, whilst avoiding deleting nested objects within the object we're extending\r\n  //    - clear those objects by deleting all properties instead\r\n  // 2) copy properties that did get included in the extension value to the object being extended, whilst avoiding altering the reference to a nested object\r\n  //    - extend those nested objects by calling this function recursively instead\r\n  Object.keys(opts.object).forEach(objectProp => {\r\n    const extensionValue = opts.extension[objectProp];\r\n\r\n    if (extensionValue === undefined) {\r\n      if (!opts.deleteKeysNotInExtension) return;\r\n\r\n      if (\r\n        opts.object[objectProp] != null &&\r\n        typeof opts.object[objectProp] === 'object'\r\n      ) {\r\n        clearObject({ object: opts.object[objectProp] });\r\n      } else {\r\n        delete opts.object[objectProp];\r\n      }\r\n    } else {\r\n      handledExtensionProps.push(objectProp);\r\n\r\n      if (\r\n        extensionValue != null &&\r\n        typeof extensionValue === 'object' &&\r\n        !Array.isArray(extensionValue)\r\n      ) {\r\n        if (opts.extendNestedObjects) {\r\n          opts.object[objectProp] = opts.object[objectProp] || {};\r\n          extend({\r\n            object: opts.object[objectProp] || {},\r\n            extension: extensionValue,\r\n            deleteKeysNotInExtension: opts.deleteKeysNotInExtension,\r\n            extendNestedObjects: true,\r\n          });\r\n        } else {\r\n          opts.object[objectProp] = extensionValue;\r\n        }\r\n      } else {\r\n        opts.object[objectProp] = extensionValue;\r\n      }\r\n    }\r\n  });\r\n\r\n  // then loop over every key in the extension that hasn't yet been handled in the loop above\r\n  Object.keys(opts.extension)\r\n    .filter(key => !handledExtensionProps.includes(key))\r\n    .forEach(extensionProp => {\r\n      const extensionValue = opts.extension[extensionProp];\r\n\r\n      if (\r\n        extensionValue != null &&\r\n        typeof extensionValue === 'object' &&\r\n        !Array.isArray(extensionValue)\r\n      ) {\r\n        if (opts.extendNestedObjects) {\r\n          opts.object[extensionProp] = opts.object[extensionProp] || {};\r\n          extend({\r\n            object: opts.object[extensionProp],\r\n            extension: extensionValue,\r\n            deleteKeysNotInExtension: opts.deleteKeysNotInExtension,\r\n            extendNestedObjects: true,\r\n          });\r\n        } else {\r\n          opts.object[extensionProp] = extensionValue;\r\n        }\r\n      } else {\r\n        opts.object[extensionProp] = extensionValue;\r\n      }\r\n    });\r\n}\r\n\r\n/**\r\n * Returns all the keys of the object in a dot(.) separate format.\r\n *\r\n * Example.\r\n *\r\n * ```\r\n * getFlattenedObjectKeys({\r\n *  user: {\r\n *    firstName: 'John',\r\n *    lastName: 'Doe',\r\n *    meetings: [1,2,3],\r\n *    company: {\r\n *      name: 'Acme'\r\n *    }\r\n *  }\r\n * })\r\n * ```\r\n *\r\n * will return\r\n * ```\r\n * ['user.firstName', 'user.lastName', 'user.meetings', 'user.company.name']\r\n * ```\r\n *\r\n * Note: This won't flatten any array values\r\n *\r\n * @param obj - Object to flatten\r\n */\r\nexport function getFlattenedObjectKeys(obj: Record<string, any>) {\r\n  const valuesByKeyPath = [];\r\n  for (const prop in obj) {\r\n    if (!obj.hasOwnProperty(prop)) continue;\r\n\r\n    // Exclude array values to prevent returning keys with array indexes\r\n    if (isObject(obj[prop]) && !isArray(obj[prop]) && obj[prop] !== null) {\r\n      const flatObject: any = getFlattenedObjectKeys(obj[prop]);\r\n      for (let idx = 0; idx < flatObject.length; idx++) {\r\n        valuesByKeyPath.push(`${prop}.${flatObject[idx]}`);\r\n      }\r\n    } else {\r\n      valuesByKeyPath.push(prop);\r\n    }\r\n  }\r\n  return valuesByKeyPath;\r\n}\r\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { OBJECT_IDENTIFIER, OBJECT_PROPERTY_SEPARATOR } from '../smDataTypes';\r\nimport { Maybe } from '../types';\r\nimport { AdditionalEdgeProperties } from './edges/types';\r\n\r\nexport const JSON_TAG = '__JSON__';\r\n\r\n/**\r\n * Takes the json representation of a node's data and prepares it to be sent to SM\r\n *\r\n * @param nodeData an object with arbitrary data\r\n * @returns stringified params ready for mutation\r\n */\r\nexport function convertNodeDataToSMPersistedData(\r\n  nodeData: Record<string, any>,\r\n  opts?: { skipBooleanStringWrapping?: boolean }\r\n): string {\r\n  const parsedData = prepareForBE(nodeData);\r\n\r\n  const stringified = Object.entries(parsedData).reduce(\r\n    (acc, [key, value], i) => {\r\n      if (i > 0) {\r\n        acc += '\\n';\r\n      }\r\n      if (key === 'childNodes' || key === 'additionalEdges') {\r\n        return acc + `${key}: [\\n{\\n${value.join('\\n}\\n{\\n')}\\n}\\n]`;\r\n      }\r\n\r\n      const shouldBeRawBoolean =\r\n        (value === 'true' || value === 'false') &&\r\n        !!opts?.skipBooleanStringWrapping;\r\n\r\n      return (\r\n        acc +\r\n        `${key}: ${value === null || shouldBeRawBoolean ? value : `\"${value}\"`}`\r\n      );\r\n    },\r\n    ``\r\n  );\r\n  return stringified;\r\n}\r\n\r\nfunction escapeText(text: string): string {\r\n  return text\r\n    .replace(/\\\\/g, '\\\\\\\\')\r\n    .replace(/\"/g, '\\\\\"')\r\n    .replace(/\\n/g, '\\\\n');\r\n}\r\n\r\n/**\r\n * Takes an object node value and flattens it to be sent to SM\r\n *\r\n * @param obj an object with arbitrary data\r\n * @param parentKey if the value is a nested object, the key of the parent is passed in order to prepend it to the child key\r\n * @param omitObjectIdentifier skip including __object__ for identifying parent objects,\r\n *  used to construct filters since there we don't care what the parent property is set to\r\n * @returns a flat object where the keys are of \"key__dot__value\" syntax\r\n *\r\n * For example:\r\n * ```typescript\r\n * const obj = {settings: {schedule: {day: 'Monday'} } }\r\n *  const result = prepareValueForBE(obj)\r\n * ```\r\n * The result will be:\r\n *  ```typescript\r\n *  {\r\n * settings: '__object__',\r\n * settings__dot__schedule: '__object__',\r\n * settings__dot__schedule__dot__day: 'Monday',\r\n * }\r\n * ```\r\n */\r\nexport function prepareObjectForBE(\r\n  obj: Record<string, any>,\r\n  opts?: {\r\n    parentKey?: string;\r\n    omitObjectIdentifier?: boolean;\r\n  }\r\n) {\r\n  return Object.entries(obj).reduce((acc, [key, val]) => {\r\n    const preparedKey = opts?.parentKey\r\n      ? `${opts.parentKey}${OBJECT_PROPERTY_SEPARATOR}${key}`\r\n      : key;\r\n\r\n    if (typeof val === 'object' && val != null) {\r\n      if (!opts || !opts.omitObjectIdentifier) {\r\n        acc[preparedKey] = OBJECT_IDENTIFIER;\r\n      }\r\n      acc = {\r\n        ...acc,\r\n        ...prepareObjectForBE(val, { ...opts, parentKey: preparedKey }),\r\n      };\r\n    } else {\r\n      acc[preparedKey] = val;\r\n    }\r\n    return acc;\r\n  }, {} as Record<string, any>);\r\n}\r\n\r\nfunction convertPropertyToBE(opts: {\r\n  key: string;\r\n  value: any;\r\n}): Record<string, Maybe<string | boolean>> {\r\n  if (opts.value === null) {\r\n    return { [opts.key]: null };\r\n  } else if (Array.isArray(opts.value)) {\r\n    return {\r\n      [opts.key]: `${JSON_TAG}${escapeText(JSON.stringify(opts.value))}`,\r\n    };\r\n  } else if (typeof opts.value === 'object') {\r\n    return prepareObjectForBE({ [opts.key]: opts.value });\r\n  } else if (typeof opts.value === 'string') {\r\n    return { [opts.key]: escapeText(opts.value) };\r\n  } else if (\r\n    typeof opts.value === 'boolean' ||\r\n    typeof opts.value === 'number'\r\n  ) {\r\n    if (typeof opts.value === 'number' && isNaN(opts.value)) {\r\n      return { [opts.key]: null };\r\n    }\r\n    return { [opts.key]: String(opts.value) };\r\n  } else {\r\n    throw Error(\r\n      `I don't yet know how to handle feData of type \"${typeof opts.value}\"`\r\n    );\r\n  }\r\n}\r\n\r\nfunction convertEdgeDirectionNames(edgeItem: AdditionalEdgeProperties) {\r\n  if (edgeItem.hasOwnProperty('to')) {\r\n    const { to, ...restOfEdgeItem } = edgeItem;\r\n\r\n    return {\r\n      ...restOfEdgeItem,\r\n      targetId: to,\r\n    };\r\n  } else if (edgeItem.hasOwnProperty('from')) {\r\n    const { from, ...restOfEdgeItem } = edgeItem;\r\n\r\n    return {\r\n      ...restOfEdgeItem,\r\n      sourceId: edgeItem.from,\r\n    };\r\n  }\r\n  throw new Error('convertEdgeDirectionNames - received invalid data');\r\n}\r\n\r\nfunction prepareForBE(obj: Record<string, any>) {\r\n  return Object.entries(obj).reduce((acc, [key, value]) => {\r\n    if (key === 'childNodes') {\r\n      if (!Array.isArray(value)) {\r\n        throw new Error(`\"childNodes\" is supposed to be an array`);\r\n      }\r\n\r\n      return {\r\n        ...acc,\r\n        childNodes: value.map(item => convertNodeDataToSMPersistedData(item)),\r\n      };\r\n    }\r\n\r\n    if (key === 'additionalEdges') {\r\n      if (!Array.isArray(value)) {\r\n        throw new Error(`\"additionalEdges\" is supposed to be an array`);\r\n      }\r\n      return {\r\n        ...acc,\r\n        additionalEdges: value.map(item =>\r\n          convertNodeDataToSMPersistedData(convertEdgeDirectionNames(item), {\r\n            skipBooleanStringWrapping: true,\r\n          })\r\n        ),\r\n      };\r\n    }\r\n\r\n    return {\r\n      ...acc,\r\n      ...convertPropertyToBE({ key, value }),\r\n    };\r\n  }, {} as Record<string, any>);\r\n}\r\n","import { gql } from '@apollo/client/core';\r\nimport { OBJECT_PROPERTY_SEPARATOR } from './smDataTypes';\r\nimport { SMUnexpectedSubscriptionMessageException } from './exceptions';\r\nimport {\r\n  NodeRelationalFns,\r\n  NodeRelationalQueryBuilderRecord,\r\n  MapFn,\r\n  ISMData,\r\n  NodeRelationalQuery,\r\n  ISMNode,\r\n  NodeComputedFns,\r\n  RelationalQueryRecordEntry,\r\n  BaseQueryRecordEntry,\r\n  IByReferenceQuery,\r\n  QueryDefinitions,\r\n  QueryRecord,\r\n  QueryRecordEntry,\r\n  ValidFilterForNode,\r\n  SM_DATA_TYPES,\r\n  SM_RELATIONAL_TYPES,\r\n  ByReferenceQueryBuilderOpts,\r\n} from './types';\r\nimport { prepareObjectForBE } from './transaction/convertNodeDataToSMPersistedData';\r\nimport {\r\n  PROPERTIES_QUERIED_FOR_ALL_NODES,\r\n  RELATIONAL_UNION_QUERY_SEPARATOR,\r\n} from './consts';\r\n\r\n/**\r\n * Relational fns are specified when creating an smNode as fns that return a NodeRelationalQueryBuilder\r\n * so they can be evaluated lazily to avoid dependency loops between nodes related to each other.\r\n *\r\n * This fn executs those fns at query time, and returns a record of relational query builders\r\n */\r\nfunction getRelationalQueryBuildersFromRelationalFns(\r\n  relationaFns?: NodeRelationalFns<any>\r\n) {\r\n  if (!relationaFns) return {};\r\n\r\n  return Object.keys(relationaFns).reduce((acc, key) => {\r\n    acc[key] = relationaFns[key]();\r\n\r\n    return acc;\r\n  }, {} as NodeRelationalQueryBuilderRecord);\r\n}\r\n\r\nfunction getMapFnReturn(opts: {\r\n  mapFn: MapFn<any, any, any>;\r\n  properties: Record<string, ISMData>;\r\n  relational?: NodeRelationalFns<any>;\r\n}) {\r\n  const mapFnOpts: Record<string, any> = {\r\n    ...opts.properties,\r\n    ...getRelationalQueryBuildersFromRelationalFns(opts.relational),\r\n  };\r\n\r\n  Object.keys(opts.properties).forEach(key => {\r\n    const data = opts.properties[key] as ISMData;\r\n\r\n    if (\r\n      data.type === SM_DATA_TYPES.object ||\r\n      data.type === SM_DATA_TYPES.maybeObject\r\n    ) {\r\n      mapFnOpts[key] = (opts: { map: MapFn<any, any, any> }) => opts.map;\r\n    }\r\n  });\r\n\r\n  return opts.mapFn(mapFnOpts) as Record<\r\n    string,\r\n    ISMData | MapFn<any, any, any> | NodeRelationalQuery<ISMNode>\r\n  >;\r\n}\r\n\r\n/**\r\n * The functions in this file are responsible for translating queryDefinitionss to gql documents\r\n * only function that should be needed outside this file is convertQueryDefinitionToQueryInfo\r\n * other fns are exported for testing purposes only\r\n */\r\nfunction getQueriedProperties(opts: {\r\n  queryId: string;\r\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\r\n  smData: Record<string, any>;\r\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\r\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\r\n  // this optional arg is only true the first time this fn is called\r\n  // and is used to ensure we also query nested data that was stored in the old format (stringified json)\r\n  isRootLevel?: true;\r\n}): Array<string> {\r\n  const mapFnReturn = getMapFnReturn({\r\n    mapFn: opts.mapFn,\r\n    properties: opts.smData,\r\n    relational: opts.smRelational,\r\n  });\r\n\r\n  /**\r\n   * a mapFnReturn will be null when the dev returns an object type in a map fn, but does not specify a map fn for that object\r\n   * for example:\r\n   *\r\n   * map: ({ settings }) => ({\r\n   *   settings: settings\r\n   * })\r\n   *\r\n   * instead of\r\n   *\r\n   * map: ({ settings }) => ({\r\n   *   settings: settings({\r\n   *     map: ({ flagEnabled }) => ({ flagEnabled })\r\n   *   })\r\n   * })\r\n   *\r\n   * in this case, we just assume they want to query the entire object\r\n   */\r\n  return Object.keys(mapFnReturn || opts.smData).reduce(\r\n    (acc, key) => {\r\n      const isData = !!opts.smData[key];\r\n\r\n      if (!isData) return acc;\r\n\r\n      // we always query these properties, can ignore any explicit requests for it\r\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\r\n        return acc;\r\n      }\r\n\r\n      const data = opts.smData[key] as ISMData;\r\n      if (\r\n        data.type === SM_DATA_TYPES.object ||\r\n        data.type === SM_DATA_TYPES.maybeObject\r\n      ) {\r\n        // query for any data stored in old format (stringified json at the root of the node)\r\n        acc.push(key);\r\n\r\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\r\n        acc.push(\r\n          ...getQueriedProperties({\r\n            queryId: opts.queryId,\r\n            mapFn: (mapFnReturn && typeof mapFnReturn[key] === 'function'\r\n              ? mapFnReturn[key]\r\n              : () => null) as MapFn<any, any, any>,\r\n            smData: (data.boxedValue as unknown) as Record<string, ISMData>,\r\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\r\n        );\r\n\r\n        return acc;\r\n      }\r\n\r\n      return [...acc, key];\r\n    },\r\n    opts.isRootLevel\r\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\r\n      : ([] as Array<string>)\r\n  );\r\n}\r\n\r\nfunction getAllNodeProperties(opts: {\r\n  nodeProperties: Record<string, ISMData>;\r\n  isRootLevel: boolean;\r\n}) {\r\n  return Object.keys(opts.nodeProperties).reduce(\r\n    (acc, key) => {\r\n      // we are already querying these properties, can ignore any explicit requests for it\r\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\r\n        return acc;\r\n      }\r\n\r\n      const data = opts.nodeProperties[key] as ISMData;\r\n      if (\r\n        data.type === SM_DATA_TYPES.object ||\r\n        data.type === SM_DATA_TYPES.maybeObject\r\n      ) {\r\n        // query for any data stored in old format (stringified json at the root of the node)\r\n        acc.push(key);\r\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\r\n        acc.push(\r\n          ...getAllNodeProperties({\r\n            nodeProperties: opts.nodeProperties[key].boxedValue as Record<\r\n              string,\r\n              ISMData\r\n            >,\r\n            isRootLevel: false,\r\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\r\n        );\r\n        return acc;\r\n      }\r\n\r\n      return [...acc, key];\r\n    },\r\n    opts.isRootLevel\r\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\r\n      : ([] as Array<string>)\r\n  );\r\n}\r\n\r\nfunction getRelationalQueries(opts: {\r\n  queryId: string;\r\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\r\n  smData: Record<string, any>;\r\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\r\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\r\n}): Record<string, RelationalQueryRecordEntry> | undefined {\r\n  const mapFnReturn = getMapFnReturn({\r\n    mapFn: opts.mapFn,\r\n    properties: opts.smData,\r\n    relational: opts.smRelational,\r\n  });\r\n\r\n  const relationalQueries = Object.keys(mapFnReturn).reduce((acc, key) => {\r\n    const isData = !!opts.smData[key];\r\n    const isComputed = opts.smComputed ? !!opts.smComputed[key] : false;\r\n\r\n    if (isData || isComputed) {\r\n      return acc;\r\n    } else {\r\n      const relationalQuery = mapFnReturn[key] as NodeRelationalQuery<ISMNode>;\r\n\r\n      /**\r\n       * happens when a map function for a relational query returns all the data for that node\r\n       * example:\r\n       *\r\n       * users: queryDefinition({\r\n       *   def: userNode,\r\n       *   map: ({ todos }) => ({\r\n       *     todos: todos({\r\n       *       map: (allTodoData) => allTodoData\r\n       *     })\r\n       *   })\r\n       * })\r\n       *\r\n       * this function will receive any relational properties in the todo node in the return of the map fn for that todo\r\n       * but they will be functions, instead of the expected objects\r\n       */\r\n      if (typeof relationalQuery === 'function') {\r\n        return acc;\r\n      }\r\n\r\n      if (relationalQuery._smRelational == null) {\r\n        throw Error(\r\n          `getRelationalQueries - the key \"${key}\" is not a data property, not a computed property and does not contain a relational query.`\r\n        );\r\n      }\r\n\r\n      if (relationalQuery._smRelational === SM_RELATIONAL_TYPES.byReference) {\r\n        if (\r\n          'map' in relationalQuery.queryBuilderOpts &&\r\n          typeof relationalQuery.queryBuilderOpts.map === 'function'\r\n        ) {\r\n          // non union\r\n          const queryBuilderOpts = relationalQuery.queryBuilderOpts as ByReferenceQueryBuilderOpts<\r\n            ISMNode\r\n          >;\r\n          addRelationalQueryRecord({\r\n            _smRelational: relationalQuery._smRelational,\r\n            key,\r\n            def: relationalQuery.def,\r\n            mapFn: queryBuilderOpts.map,\r\n          });\r\n        } else {\r\n          // union\r\n          const queryBuilderOpts = relationalQuery.queryBuilderOpts as ByReferenceQueryBuilderOpts<\r\n            Record<string, ISMNode>\r\n          >;\r\n          Object.keys(queryBuilderOpts).forEach(unionType => {\r\n            addRelationalQueryRecord({\r\n              _smRelational: relationalQuery._smRelational,\r\n              key: `${key}${RELATIONAL_UNION_QUERY_SEPARATOR}${unionType}`,\r\n              def: relationalQuery.def[unionType],\r\n              mapFn: queryBuilderOpts[unionType].map,\r\n            });\r\n          });\r\n        }\r\n      } else if (\r\n        relationalQuery._smRelational === SM_RELATIONAL_TYPES.children\r\n      ) {\r\n        addRelationalQueryRecord({\r\n          _smRelational: relationalQuery._smRelational,\r\n          key,\r\n          def: relationalQuery.def,\r\n          mapFn: relationalQuery.map,\r\n        });\r\n      } else {\r\n        throw Error(\r\n          // @ts-expect-error relationalQuery is currently a never case here, since both existing types are being checked above\r\n          `The relational query type ${relationalQuery._smRelational} is not valid`\r\n        );\r\n      }\r\n\r\n      function addRelationalQueryRecord(queryRecord: {\r\n        _smRelational: SM_RELATIONAL_TYPES;\r\n        def: ISMNode;\r\n        mapFn: (data: any) => any;\r\n        key: string;\r\n      }) {\r\n        const relationalQueryRecord: BaseQueryRecordEntry = {\r\n          def: queryRecord.def,\r\n          properties: getQueriedProperties({\r\n            queryId: opts.queryId,\r\n            mapFn: queryRecord.mapFn,\r\n            smData: queryRecord.def.smData,\r\n            smComputed: queryRecord.def.smComputed,\r\n            smRelational: queryRecord.def.smRelational,\r\n            isRootLevel: true,\r\n          }),\r\n        };\r\n\r\n        const relationalQueriesWithinThisRelationalQuery = getRelationalQueries(\r\n          {\r\n            queryId: opts.queryId,\r\n            mapFn: queryRecord.mapFn,\r\n            smData: queryRecord.def.smData,\r\n            smComputed: queryRecord.def.smComputed,\r\n            smRelational: queryRecord.def.smRelational,\r\n          }\r\n        );\r\n\r\n        if (relationalQueriesWithinThisRelationalQuery) {\r\n          relationalQueryRecord.relational = relationalQueriesWithinThisRelationalQuery;\r\n        }\r\n\r\n        const relationalType = queryRecord._smRelational;\r\n        if (relationalType === SM_RELATIONAL_TYPES.byReference) {\r\n          (relationalQueryRecord as RelationalQueryRecordEntry & {\r\n            byReference: true;\r\n          }).byReference = true;\r\n          (relationalQueryRecord as RelationalQueryRecordEntry & {\r\n            idProp: string;\r\n          }).idProp = (relationalQuery as IByReferenceQuery<\r\n            ISMNode,\r\n            any,\r\n            any\r\n          >).idProp;\r\n        } else if (relationalType === SM_RELATIONAL_TYPES.children) {\r\n          (relationalQueryRecord as RelationalQueryRecordEntry & {\r\n            children: true;\r\n          }).children = true;\r\n          if ('depth' in relationalQuery) {\r\n            (relationalQueryRecord as RelationalQueryRecordEntry & {\r\n              depth?: number;\r\n            }).depth = relationalQuery.depth;\r\n          }\r\n        } else {\r\n          throw Error(`relationalType \"${relationalType}\" is not valid.`);\r\n        }\r\n\r\n        acc[\r\n          queryRecord.key\r\n        ] = relationalQueryRecord as RelationalQueryRecordEntry;\r\n      }\r\n\r\n      return acc;\r\n    }\r\n  }, {} as Record<string, RelationalQueryRecordEntry>);\r\n\r\n  if (Object.keys(relationalQueries).length === 0) return undefined;\r\n  return relationalQueries;\r\n}\r\n\r\nexport function getQueryRecordFromQueryDefinition(opts: {\r\n  queryId: string;\r\n  queryDefinitions: QueryDefinitions;\r\n}) {\r\n  const queryRecord: QueryRecord = {};\r\n\r\n  Object.keys(opts.queryDefinitions).forEach(queryDefinitionsAlias => {\r\n    const queryDefinition = opts.queryDefinitions[queryDefinitionsAlias];\r\n\r\n    let queriedProps;\r\n    let nodeDef;\r\n    let relational;\r\n    if (queryDefinition._isSMNodeDef) {\r\n      // shorthand syntax where the dev only specified a node defition, nothing else\r\n      nodeDef = queryDefinition as ISMNode;\r\n      queriedProps = getAllNodeProperties({\r\n        nodeProperties: nodeDef.smData,\r\n        isRootLevel: true,\r\n      });\r\n    } else {\r\n      nodeDef = queryDefinition.def;\r\n      if (queryDefinition.map) {\r\n        queriedProps = getQueriedProperties({\r\n          mapFn: queryDefinition.map,\r\n          queryId: opts.queryId,\r\n          smData: queryDefinition.def.smData,\r\n          smComputed: queryDefinition.def.smComputed,\r\n          smRelational: queryDefinition.def.smRelational,\r\n          isRootLevel: true,\r\n        });\r\n        relational = getRelationalQueries({\r\n          mapFn: queryDefinition.map,\r\n          queryId: opts.queryId,\r\n          smData: nodeDef.smData,\r\n          smComputed: nodeDef.smComputed,\r\n          smRelational: nodeDef.smRelational,\r\n        });\r\n      } else {\r\n        queriedProps = getAllNodeProperties({\r\n          nodeProperties: nodeDef.smData,\r\n          isRootLevel: true,\r\n        });\r\n      }\r\n    }\r\n\r\n    const queryRecordEntry = {\r\n      def: nodeDef,\r\n      properties: queriedProps,\r\n      relational,\r\n    };\r\n\r\n    if (queryDefinition.target) {\r\n      if ('ids' in queryDefinition.target) {\r\n        if (\r\n          (queryDefinition.target.ids as Array<string>).some(\r\n            id => typeof id !== 'string'\r\n          )\r\n        ) {\r\n          throw Error('Invalid id in target.ids');\r\n        }\r\n\r\n        (queryRecordEntry as QueryRecordEntry & { ids: Array<string> }).ids =\r\n          queryDefinition.target.ids;\r\n      }\r\n      if ('id' in queryDefinition.target) {\r\n        if (typeof queryDefinition.target.id !== 'string') {\r\n          throw Error('Invalid id in target.id');\r\n        }\r\n\r\n        (queryRecordEntry as QueryRecordEntry & { id: string }).id =\r\n          queryDefinition.target.id;\r\n      }\r\n      if ('underIds' in queryDefinition.target) {\r\n        if (\r\n          (queryDefinition.target.underIds as Array<string>).some(\r\n            id => typeof id !== 'string'\r\n          )\r\n        ) {\r\n          throw Error('Invalid id in target.underIds');\r\n        }\r\n\r\n        (queryRecordEntry as QueryRecordEntry & {\r\n          underIds: Array<string>;\r\n        }).underIds = queryDefinition.target.underIds;\r\n      }\r\n      if (queryDefinition.target.depth) {\r\n        (queryRecordEntry as QueryRecordEntry & { depth?: string }).depth =\r\n          queryDefinition.target.depth;\r\n      }\r\n    }\r\n\r\n    if ('filter' in queryDefinition) {\r\n      (queryRecordEntry as QueryRecordEntry & { filter: any }).filter =\r\n        queryDefinition.filter;\r\n    }\r\n\r\n    queryRecord[queryDefinitionsAlias] = queryRecordEntry as QueryRecordEntry;\r\n  });\r\n  return queryRecord;\r\n}\r\n\r\nfunction getIdsString(ids: Array<string>) {\r\n  return `[${ids.map(id => `\"${id}\"`).join(',')}]`;\r\n}\r\n\r\nexport function getKeyValueFilterString<TSMNode extends ISMNode>(\r\n  filter: ValidFilterForNode<TSMNode>\r\n) {\r\n  const convertedToDotFormat = prepareObjectForBE(filter, {\r\n    omitObjectIdentifier: true,\r\n  });\r\n  return `{${Object.entries(convertedToDotFormat).reduce(\r\n    (acc, [key, value], idx, entries) => {\r\n      acc += `${key}: ${value == null ? null : `\"${String(value)}\"`}`;\r\n      if (idx < entries.length - 1) {\r\n        acc += `, `;\r\n      }\r\n      return acc;\r\n    },\r\n    ''\r\n  )}}`;\r\n}\r\n\r\nfunction getGetNodeOptions<TSMNode extends ISMNode>(opts: {\r\n  def: TSMNode;\r\n  underIds?: Array<string>;\r\n  depth?: number;\r\n  filter?: ValidFilterForNode<TSMNode>;\r\n}) {\r\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\r\n\r\n  if (opts.underIds) {\r\n    options.push(`underIds: [${opts.underIds.map(id => `\"${id}\"`).join(',')}]`);\r\n  }\r\n\r\n  if (opts.depth !== null && opts.depth !== undefined) {\r\n    options.push(`depth: ${opts.depth}`);\r\n  }\r\n\r\n  if (opts.filter !== null && opts.filter !== undefined) {\r\n    options.push(`filter: ${getKeyValueFilterString(opts.filter)}`);\r\n  }\r\n\r\n  return options.join(', ');\r\n}\r\n\r\n// subscriptions use a slightly different set of arguments for now\r\n// https://tractiontools.atlassian.net/secure/RapidBoard.jspa?rapidView=53&projectKey=SMT&modal=detail&selectedIssue=SMT-636\r\nfunction getSubscriptionGetNodeOptions(opts: {\r\n  def: ISMNode;\r\n  under?: string;\r\n  depth?: number;\r\n}) {\r\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\r\n\r\n  if (opts.under) {\r\n    options.push(`underIds: [\"${opts.under}\"]`);\r\n  }\r\n\r\n  // @TODO uncomment when subscriptions support depth params\r\n  // if (opts.depth != null) {\r\n  //   options.push(`depth: ${opts.depth}`)\r\n  // }\r\n\r\n  return options.join(', ');\r\n}\r\n\r\nfunction getSpaces(numberOfSpaces: number) {\r\n  return new Array(numberOfSpaces).fill(' ').join('');\r\n}\r\n\r\nfunction getQueryPropertiesString(opts: {\r\n  queryRecordEntry: QueryRecordEntry | RelationalQueryRecordEntry;\r\n  nestLevel: number;\r\n}) {\r\n  let propsString = `\\n${getSpaces((opts.nestLevel + 2) * 2)}`;\r\n  propsString += opts.queryRecordEntry.properties.join(\r\n    `,\\n${getSpaces((opts.nestLevel + 2) * 2)}`\r\n  );\r\n\r\n  if (opts.queryRecordEntry.relational) {\r\n    propsString +=\r\n      (propsString !== '' ? ',' : '') +\r\n      getRelationalQueryString({\r\n        relationalQueryRecord: opts.queryRecordEntry.relational,\r\n        nestLevel: opts.nestLevel + 2,\r\n      });\r\n  }\r\n\r\n  return propsString;\r\n}\r\n\r\nfunction getRelationalQueryString(opts: {\r\n  relationalQueryRecord: Record<string, RelationalQueryRecordEntry>;\r\n  nestLevel: number;\r\n}) {\r\n  return Object.keys(opts.relationalQueryRecord).reduce((acc, alias) => {\r\n    const relationalQueryRecordEntry = opts.relationalQueryRecord[alias];\r\n\r\n    let operation: string;\r\n\r\n    if ('byReference' in relationalQueryRecordEntry) {\r\n      operation = `GetReferences(propertyNames: \"${relationalQueryRecordEntry.idProp}\")`;\r\n    } else if ('children' in relationalQueryRecordEntry) {\r\n      const depthString =\r\n        'depth' in relationalQueryRecordEntry\r\n          ? relationalQueryRecordEntry.depth !== undefined\r\n            ? `,depth: ${relationalQueryRecordEntry.depth}`\r\n            : ''\r\n          : '';\r\n      operation = `GetChildren(type: \"${relationalQueryRecordEntry.def.type}\"${depthString})`;\r\n    } else {\r\n      throw Error(\r\n        `relationalQueryRecordEntry is invalid\\n${JSON.stringify(\r\n          relationalQueryRecordEntry,\r\n          null,\r\n          2\r\n        )}`\r\n      );\r\n    }\r\n\r\n    return (\r\n      acc +\r\n      `\\n${getSpaces(opts.nestLevel * 2)}${alias}: ${operation} {` +\r\n      getQueryPropertiesString({\r\n        queryRecordEntry: relationalQueryRecordEntry,\r\n        nestLevel: opts.nestLevel,\r\n      }) +\r\n      `\\n${getSpaces(opts.nestLevel * 2)}}`\r\n    );\r\n  }, '');\r\n}\r\n\r\nfunction getRootLevelQueryString(\r\n  opts: {\r\n    alias: string;\r\n  } & QueryRecordEntry\r\n) {\r\n  let operation: string;\r\n  if ('ids' in opts) {\r\n    operation = `GetNodesByIdNew(ids: ${getIdsString(opts.ids)})`;\r\n  } else if ('id' in opts) {\r\n    operation = `GetNodesByIdNew(ids: ${getIdsString([opts.id])})`;\r\n  } else {\r\n    operation = `GetNodesNew(${getGetNodeOptions(opts)})`;\r\n  }\r\n\r\n  return (\r\n    `${opts.alias}: ${operation} {` +\r\n    `${getQueryPropertiesString({ queryRecordEntry: opts, nestLevel: 1 })}` +\r\n    `\\n${getSpaces(4)}}`\r\n  );\r\n}\r\n\r\nexport type SubscriptionConfig = {\r\n  alias: string;\r\n  gqlString: string;\r\n  extractNodeFromSubscriptionMessage: (\r\n    subscriptionMessage: Record<string, any>\r\n  ) => any;\r\n  extractOperationFromSubscriptionMessage: (\r\n    subscriptionMessage: Record<string, any>\r\n  ) => any;\r\n};\r\n\r\nexport function getQueryInfo(opts: {\r\n  queryDefinitions: QueryDefinitions;\r\n  queryId: string;\r\n}) {\r\n  const queryRecord: QueryRecord = getQueryRecordFromQueryDefinition(opts);\r\n  const queryGQLString = `\r\n    query ${getSanitizedQueryId({ queryId: opts.queryId })} {\r\n        ${Object.keys(queryRecord)\r\n          .map(alias =>\r\n            getRootLevelQueryString({\r\n              alias,\r\n              ...queryRecord[alias],\r\n            })\r\n          )\r\n          .join('\\n    ')}\r\n    }\r\n  `.trim();\r\n\r\n  const subscriptionConfigs: Array<SubscriptionConfig> = Object.keys(\r\n    queryRecord\r\n  ).reduce((subscriptionConfigsAcc, alias) => {\r\n    const subscriptionName = getSanitizedQueryId({\r\n      queryId: opts.queryId + '_' + alias,\r\n    });\r\n    const queryRecordEntry = queryRecord[alias];\r\n\r\n    let operations: Array<string>;\r\n    if ('ids' in queryRecordEntry) {\r\n      operations = [\r\n        `GetNodesById(ids: ${getIdsString(\r\n          queryRecordEntry.ids\r\n        )}, monitorChildEvents: true)`,\r\n      ];\r\n    } else if ('id' in queryRecordEntry) {\r\n      operations = [\r\n        `GetNodesById(ids: ${getIdsString([\r\n          queryRecordEntry.id,\r\n        ])}, monitorChildEvents: true)`,\r\n      ];\r\n    } else if ('underIds' in queryRecordEntry) {\r\n      operations = queryRecordEntry.underIds.map(underId => {\r\n        return `GetNodesNew(${getSubscriptionGetNodeOptions({\r\n          ...queryRecordEntry,\r\n          under: underId,\r\n        })}, monitorChildEvents: true)`;\r\n      });\r\n    } else {\r\n      operations = [\r\n        `GetNodesNew(${getSubscriptionGetNodeOptions(\r\n          queryRecordEntry\r\n        )}, monitorChildEvents: true)`,\r\n      ];\r\n    }\r\n\r\n    const gqlStrings = operations.map(operation => {\r\n      return `\r\n    subscription ${subscriptionName} {\r\n      ${alias}: ${operation} {\r\n        node {\r\n          ${getQueryPropertiesString({ queryRecordEntry, nestLevel: 5 })}\r\n        }\r\n        operation { action, path }\r\n      }\r\n    }\r\n        `.trim();\r\n    });\r\n\r\n    function extractNodeFromSubscriptionMessage(\r\n      subscriptionMessage: Record<string, any>\r\n    ) {\r\n      if (!subscriptionMessage[alias].node) {\r\n        throw new SMUnexpectedSubscriptionMessageException({\r\n          subscriptionMessage,\r\n          description: 'No \"node\" found in message',\r\n        });\r\n      }\r\n\r\n      return subscriptionMessage[alias].node;\r\n    }\r\n\r\n    function extractOperationFromSubscriptionMessage(\r\n      subscriptionMessage: Record<string, any>\r\n    ) {\r\n      if (!subscriptionMessage[alias].operation) {\r\n        throw new SMUnexpectedSubscriptionMessageException({\r\n          subscriptionMessage,\r\n          description: 'No \"operation\" found in message',\r\n        });\r\n      }\r\n\r\n      return subscriptionMessage[alias].operation;\r\n    }\r\n\r\n    gqlStrings.forEach(gqlString => {\r\n      subscriptionConfigsAcc.push({\r\n        alias,\r\n        gqlString,\r\n        extractNodeFromSubscriptionMessage,\r\n        extractOperationFromSubscriptionMessage,\r\n      });\r\n    });\r\n\r\n    return subscriptionConfigsAcc;\r\n  }, [] as Array<SubscriptionConfig>);\r\n\r\n  return {\r\n    subscriptionConfigs: subscriptionConfigs,\r\n    queryGQLString,\r\n    queryRecord,\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a queryDefinitions into a gql doc that can be sent to the gqlClient\r\n * Returns a queryRecord for easily deduping requests based on the data that is being requested\r\n * Can later also be used to build a diff to request only the necessary data\r\n * taking into account the previous query record to avoid requesting data already in memory\r\n */\r\nexport function convertQueryDefinitionToQueryInfo(opts: {\r\n  queryDefinitions: QueryDefinitions;\r\n  queryId: string;\r\n}) {\r\n  const { queryGQLString, subscriptionConfigs, queryRecord } = getQueryInfo(\r\n    opts\r\n  );\r\n\r\n  return {\r\n    queryGQL: gql(queryGQLString),\r\n    subscriptionConfigs: subscriptionConfigs.map(subscriptionConfig => ({\r\n      ...subscriptionConfig,\r\n      gql: gql(subscriptionConfig.gqlString),\r\n    })),\r\n    queryRecord,\r\n  };\r\n}\r\n\r\nfunction getSanitizedQueryId(opts: { queryId: string }): string {\r\n  return opts.queryId.replace(/-/g, '_');\r\n}\r\n","import { DEFAULT_TOKEN_NAME } from './consts';\r\nimport {\r\n  convertQueryDefinitionToQueryInfo,\r\n  SubscriptionConfig,\r\n} from './queryDefinitionAdapters';\r\nimport {\r\n  ISMJS,\r\n  ISMQueryManager,\r\n  QueryDefinitions,\r\n  QueryOpts,\r\n  QueryReturn,\r\n  QueryDataReturn,\r\n  SubscriptionOpts,\r\n  SubscriptionMeta,\r\n  SubscriptionCanceller,\r\n  QueryDefinition,\r\n} from './types';\r\n\r\nlet queryIdx = 0;\r\n\r\nfunction splitQueryDefinitionsByToken<\r\n  TQueryDefinitions extends QueryDefinitions\r\n>(queryDefinitions: TQueryDefinitions): Record<string, QueryDefinitions> {\r\n  return Object.entries(queryDefinitions).reduce(\r\n    (\r\n      split,\r\n      [alias, queryDefinition]: [string, QueryDefinition<any, any, any>]\r\n    ) => {\r\n      split[queryDefinition.tokenName || DEFAULT_TOKEN_NAME] =\r\n        split[queryDefinition.tokenName || DEFAULT_TOKEN_NAME] || {};\r\n      split[queryDefinition.tokenName || DEFAULT_TOKEN_NAME][\r\n        alias\r\n      ] = queryDefinition;\r\n\r\n      return split;\r\n    },\r\n    {} as Record<string, QueryDefinitions>\r\n  );\r\n}\r\n\r\n/**\r\n * Declared as a factory function so that \"subscribe\" can generate its own querier which shares the same query manager\r\n * Which ensures that the socket messages are applied to the correct base set of results\r\n */\r\nexport function generateQuerier({\r\n  smJSInstance,\r\n  queryManager,\r\n}: {\r\n  smJSInstance: ISMJS;\r\n  queryManager?: ISMQueryManager;\r\n}) {\r\n  return async function query<TQueryDefinitions extends QueryDefinitions>(\r\n    queryDefinitions: TQueryDefinitions,\r\n    opts?: QueryOpts<TQueryDefinitions>\r\n  ): Promise<QueryReturn<TQueryDefinitions>> {\r\n    const startStack = new Error().stack as string;\r\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\r\n\r\n    function getError(error: any, stack?: string) {\r\n      // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\r\n      error.stack =\r\n        `\\n` +\r\n        (stack || error.stack) +\r\n        '\\n' +\r\n        startStack.substring(startStack.indexOf('\\n') + 1);\r\n\r\n      return error;\r\n    }\r\n\r\n    function getToken(tokenName: string) {\r\n      const token = smJSInstance.getToken({ tokenName });\r\n\r\n      if (!token) {\r\n        throw new Error(\r\n          `No token registered with the name \"${tokenName}\".\\n` +\r\n            'Please register this token prior to using it with sm.setToken({ tokenName, token })) '\r\n        );\r\n      }\r\n\r\n      return token;\r\n    }\r\n\r\n    const queryDefinitionsSplitByToken = splitQueryDefinitionsByToken(\r\n      queryDefinitions\r\n    );\r\n\r\n    async function performQueries() {\r\n      const allResults = await Promise.all(\r\n        Object.entries(queryDefinitionsSplitByToken).map(\r\n          ([tokenName, queryDefinitions]) => {\r\n            const { queryGQL } = convertQueryDefinitionToQueryInfo({\r\n              queryDefinitions,\r\n              queryId,\r\n            });\r\n\r\n            return smJSInstance.gqlClient.query({\r\n              gql: queryGQL,\r\n              token: getToken(tokenName),\r\n              batched: opts?.batched,\r\n            });\r\n          }\r\n        )\r\n      );\r\n\r\n      return allResults.reduce((acc, resultsForToken) => {\r\n        return {\r\n          ...acc,\r\n          ...resultsForToken,\r\n        };\r\n      }, {});\r\n    }\r\n\r\n    try {\r\n      const results = await performQueries();\r\n\r\n      const qM =\r\n        queryManager ||\r\n        new smJSInstance.SMQueryManager(\r\n          convertQueryDefinitionToQueryInfo({\r\n            queryDefinitions,\r\n            queryId,\r\n          }).queryRecord\r\n        );\r\n      try {\r\n        qM.onQueryResult({ queryId, queryResult: results });\r\n      } catch (e) {\r\n        const error = getError(\r\n          new Error(`Error applying query results`),\r\n          (e as any).stack\r\n        );\r\n\r\n        if (opts?.onError) {\r\n          opts.onError(error);\r\n          return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      return {\r\n        data: qM.getResults() as QueryDataReturn<TQueryDefinitions>,\r\n        error: undefined,\r\n      };\r\n    } catch (e) {\r\n      const error = getError(\r\n        new Error(`Error querying data`),\r\n        (e as any).stack\r\n      );\r\n      if (opts?.onError) {\r\n        opts.onError(error);\r\n        return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport function generateSubscriber(smJSInstance: ISMJS) {\r\n  return async function subscribe<\r\n    TQueryDefinitions extends QueryDefinitions,\r\n    TSubscriptionOpts extends SubscriptionOpts<TQueryDefinitions>\r\n  >(\r\n    queryDefinitions: TQueryDefinitions,\r\n    opts: TSubscriptionOpts\r\n  ): Promise<\r\n    TSubscriptionOpts extends { skipInitialQuery: true }\r\n      ? SubscriptionMeta\r\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta\r\n  > {\r\n    type ReturnType = TSubscriptionOpts extends {\r\n      skipInitialQuery: true;\r\n    }\r\n      ? SubscriptionMeta\r\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta;\r\n\r\n    // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\r\n    const startStack = new Error().stack as string;\r\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\r\n    const { queryGQL, queryRecord } = convertQueryDefinitionToQueryInfo({\r\n      queryDefinitions,\r\n      queryId,\r\n    });\r\n\r\n    opts.onQueryInfoConstructed &&\r\n      opts.onQueryInfoConstructed({ queryGQL, queryId });\r\n\r\n    function getError(error: any, stack?: any) {\r\n      // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\r\n      error.stack =\r\n        '\\n' +\r\n        (stack || error.stack) +\r\n        '\\n' +\r\n        startStack.substring(startStack.indexOf('\\n') + 1);\r\n\r\n      return error;\r\n    }\r\n\r\n    const queryManager = new smJSInstance.SMQueryManager(queryRecord);\r\n\r\n    function updateQueryManagerWithSubscriptionMessage(data: {\r\n      message: Record<string, any>;\r\n      subscriptionConfig: SubscriptionConfig;\r\n    }) {\r\n      let node;\r\n      let operation;\r\n      try {\r\n        node = data.subscriptionConfig.extractNodeFromSubscriptionMessage(\r\n          data.message\r\n        );\r\n        operation = data.subscriptionConfig.extractOperationFromSubscriptionMessage(\r\n          data.message\r\n        );\r\n        queryManager.onSubscriptionMessage({\r\n          node,\r\n          operation,\r\n          queryId: queryId,\r\n          subscriptionAlias: data.subscriptionConfig.alias,\r\n        });\r\n      } catch (e) {\r\n        const error = getError(\r\n          new Error(`Error applying subscription message`),\r\n          (e as any).stack\r\n        );\r\n\r\n        if (opts.onError) {\r\n          opts.onError(error);\r\n        } else {\r\n          console.error(error);\r\n        }\r\n      }\r\n    }\r\n\r\n    function getToken(tokenName: string) {\r\n      const token = smJSInstance.getToken({ tokenName });\r\n\r\n      if (!token) {\r\n        throw new Error(\r\n          `No token registered with the name \"${tokenName}\".\\n` +\r\n            'Please register this token prior to using it with sm.setToken({ tokenName, token })) '\r\n        );\r\n      }\r\n\r\n      return token;\r\n    }\r\n\r\n    let subscriptionCancellers: Array<SubscriptionCanceller> = [];\r\n    // Subscriptions are initialized immediately, rather than after the query resolves, to prevent an edge case where an update to a node happens\r\n    // while the data for that node is being transfered from SM to the client. This would result in a missed update.\r\n    // However, we must be careful to not call opts.onData with any subscription messages before the query resolves,\r\n    // because a subscription message only includes info about the node that changed, not all data being subscribed to,\r\n    // which means the consumer of this API would receive and incomplete data set in this edge case.\r\n    // This flag prevents that, by short-circuiting opts.onData in subscription messages, if the query has not resolved\r\n    let mustAwaitQuery = !opts.skipInitialQuery;\r\n    const messageQueue: Array<{\r\n      message: Record<string, any>;\r\n      subscriptionConfig: SubscriptionConfig;\r\n    }> = [];\r\n    function initSubs() {\r\n      const queryDefinitionsSplitByToken = splitQueryDefinitionsByToken(\r\n        queryDefinitions\r\n      );\r\n\r\n      Object.entries(queryDefinitionsSplitByToken).forEach(\r\n        ([tokenName, queryDefinitions]) => {\r\n          const { subscriptionConfigs } = convertQueryDefinitionToQueryInfo({\r\n            queryDefinitions,\r\n            queryId,\r\n          });\r\n\r\n          subscriptionCancellers.push(\r\n            ...subscriptionConfigs.map(subscriptionConfig => {\r\n              return smJSInstance.gqlClient.subscribe({\r\n                gql: subscriptionConfig.gql,\r\n                token: getToken(tokenName),\r\n                onMessage: message => {\r\n                  if (mustAwaitQuery) {\r\n                    messageQueue.push({ message, subscriptionConfig });\r\n                    return;\r\n                  }\r\n\r\n                  updateQueryManagerWithSubscriptionMessage({\r\n                    message,\r\n                    subscriptionConfig,\r\n                  });\r\n\r\n                  // @TODO When called with skipInitialQuery, results should be null\r\n                  // and we should simply expose a \"delta\" from the message\r\n                  // probably don't need a query manager in that case either.\r\n                  opts.onData({\r\n                    results: queryManager.getResults() as QueryDataReturn<\r\n                      TQueryDefinitions\r\n                    >,\r\n                  });\r\n                },\r\n                onError: e => {\r\n                  // Can never throw here. The dev consuming this would have no way of catching it\r\n                  // To catch an error in a subscription they must provide onError\r\n                  const error = getError(\r\n                    new Error(`Error in a subscription message`),\r\n                    e.stack\r\n                  );\r\n\r\n                  if (opts.onError) {\r\n                    opts.onError(error);\r\n                  } else {\r\n                    console.error(error);\r\n                  }\r\n                },\r\n              });\r\n            })\r\n          );\r\n        }\r\n      );\r\n    }\r\n\r\n    function unsub() {\r\n      subscriptionCancellers.forEach(cancel => cancel());\r\n    }\r\n\r\n    try {\r\n      initSubs();\r\n      opts.onSubscriptionInitialized && opts.onSubscriptionInitialized(unsub);\r\n    } catch (e) {\r\n      const error = getError(\r\n        new Error(`Error initializating subscriptions`),\r\n        (e as any).stack\r\n      );\r\n\r\n      if (opts?.onError) {\r\n        opts.onError(error);\r\n        return { data: {}, unsub, error } as ReturnType;\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    if (opts.skipInitialQuery) {\r\n      return { unsub } as ReturnType;\r\n    } else {\r\n      const query = generateQuerier({ smJSInstance, queryManager });\r\n      try {\r\n        // this query method will post its results to the queryManager declared above\r\n        await query(queryDefinitions, {\r\n          queryId: opts.queryId,\r\n          batched: opts.batched,\r\n        });\r\n      } catch (e) {\r\n        const error = getError(\r\n          new Error(`Error querying initial data set`),\r\n          (e as any).stack\r\n        );\r\n\r\n        if (opts?.onError) {\r\n          opts.onError(error);\r\n          return { data: {}, unsub, error } as ReturnType;\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      if (mustAwaitQuery) {\r\n        mustAwaitQuery = false;\r\n        messageQueue.forEach(updateQueryManagerWithSubscriptionMessage);\r\n        messageQueue.length = 0;\r\n      }\r\n\r\n      const data = queryManager.getResults() as QueryDataReturn<\r\n        TQueryDefinitions\r\n      >;\r\n\r\n      opts.onData({ results: data as QueryDataReturn<TQueryDefinitions> });\r\n\r\n      return { data, unsub, error: null } as ReturnType;\r\n    }\r\n  };\r\n}\r\n","export function getMutationNameFromOperations(\r\n  operations: Array<{ name?: string }>,\r\n  fallback: string\r\n) {\r\n  const operationNames = operations\r\n    .filter(operation => 'name' in operation && !!operation.name)\r\n    .map(operation => {\r\n      if ('name' in operation) {\r\n        return operation.name;\r\n      } else {\r\n        throw Error('Expected an operation name here');\r\n      }\r\n    });\r\n\r\n  if (operationNames.length) {\r\n    return operationNames.join('__');\r\n  }\r\n\r\n  return fallback;\r\n}\r\n","import { EdgePermissions } from './types';\r\n\r\nexport function getEdgePermissionsString(permissions: EdgePermissions): string {\r\n  return `\r\n    view: ${permissions.view ? 'true' : 'false'},\r\n    edit: ${permissions.edit ? 'true' : 'false'},\r\n    manage: ${permissions.manage ? 'true' : 'false'},\r\n    terminate: ${permissions.terminate ? 'true' : 'false'},\r\n    addChild: ${permissions.addChild ? 'true' : 'false'}\r\n  `;\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\r\nimport {\r\n  CreateEdgeOperation,\r\n  CreateEdgeOpts,\r\n  CreateEdgesOperation,\r\n  EdgeProperties,\r\n} from './types';\r\nimport { getEdgePermissionsString } from './utilities';\r\n\r\nexport function createEdge(edge: CreateEdgeOpts): CreateEdgeOperation {\r\n  return {\r\n    type: 'createEdge',\r\n    ...edge,\r\n    smOperationName: 'AttachEdge',\r\n  };\r\n}\r\n\r\nexport function createEdges(\r\n  edges: CreateEdgesOperation['edges']\r\n): CreateEdgesOperation {\r\n  return {\r\n    type: 'createEdges',\r\n    smOperationName: 'AttachEdge',\r\n    edges,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromEdgeCreateOperations(\r\n  operations: Array<CreateEdgeOperation | CreateEdgesOperation>\r\n): Array<DocumentNode> {\r\n  return operations.flatMap(operation => {\r\n    if (operation.type === 'createEdge') {\r\n      return convertEdgeCreationOperationToMutationArguments({\r\n        ...operation.edge,\r\n        name: operation.name,\r\n      });\r\n    } else if (operation.type === 'createEdges') {\r\n      return operation.edges.map(({ edge }) =>\r\n        convertEdgeCreationOperationToMutationArguments(edge)\r\n      );\r\n    }\r\n    throw Error(`Operation not recognized: \"${operation}\"`);\r\n  });\r\n}\r\n\r\nfunction convertEdgeCreationOperationToMutationArguments(\r\n  opts: EdgeProperties & { name?: string }\r\n): DocumentNode {\r\n  const edge = `{\\ntype: \"${opts.type || 'access'}\",${getEdgePermissionsString(\r\n    opts.permissions\r\n  )}}`;\r\n  const name = getMutationNameFromOperations([opts], 'CreateEdge');\r\n\r\n  return gql`\r\n    mutation ${name} {\r\n        AttachEdge(\r\n            newSourceId: \"${opts.from}\"\r\n            targetId: \"${opts.to}\"\r\n            edge: ${edge}\r\n        )\r\n    }`;\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\r\nimport {\r\n  DropEdgeOpts,\r\n  DropEdgeOperation,\r\n  DropEdgeProperties,\r\n  DropEdgesOperation,\r\n} from './types';\r\n\r\nexport function dropEdge(edge: DropEdgeOpts): DropEdgeOperation {\r\n  return {\r\n    type: 'dropEdge',\r\n    smOperationName: 'DropEdge',\r\n    ...edge,\r\n  };\r\n}\r\n\r\nexport function dropEdges(edges: Array<DropEdgeOpts>): DropEdgesOperation {\r\n  return {\r\n    type: 'dropEdges',\r\n    smOperationName: 'DropEdge',\r\n    edges,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromEdgeDropOperations(\r\n  operations: Array<DropEdgeOperation | DropEdgesOperation>\r\n): Array<DocumentNode> {\r\n  return operations.flatMap(operation => {\r\n    if (operation.type === 'dropEdge') {\r\n      return convertEdgeDropOperationToMutationArguments({\r\n        ...operation.edge,\r\n        name: operation.name,\r\n      });\r\n    } else if (operation.type === 'dropEdges') {\r\n      return operation.edges.map(operation =>\r\n        convertEdgeDropOperationToMutationArguments({\r\n          ...operation.edge,\r\n          name: operation.name,\r\n        })\r\n      );\r\n    }\r\n\r\n    throw Error(`Operation not recognized: \"${operation}\"`);\r\n  });\r\n}\r\n\r\nfunction convertEdgeDropOperationToMutationArguments(\r\n  opts: DropEdgeProperties & { name?: string }\r\n): DocumentNode {\r\n  const name = getMutationNameFromOperations([opts], 'DropEdge');\r\n\r\n  return gql`\r\n    mutation ${name} {\r\n        DropEdge(\r\n            sourceId: \"${opts.from}\"\r\n            targetId: \"${opts.to}\"\r\n            edgeType: \"${opts.type || 'access'}\"\r\n        )\r\n    }`;\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\r\nimport {\r\n  ReplaceEdgeOperation,\r\n  ReplaceEdgeOpts,\r\n  ReplaceEdgeProperties,\r\n  ReplaceEdgesOperation,\r\n} from './types';\r\nimport { getEdgePermissionsString } from './utilities';\r\n\r\nexport function replaceEdge(edge: ReplaceEdgeOpts): ReplaceEdgeOperation {\r\n  return {\r\n    type: 'replaceEdge',\r\n    smOperationName: 'ReplaceEdge',\r\n    ...edge,\r\n  };\r\n}\r\n\r\nexport function replaceEdges(\r\n  edges: Array<{\r\n    edge: ReplaceEdgeProperties & { name?: string };\r\n    onSuccess?: () => any;\r\n  }>\r\n): ReplaceEdgesOperation {\r\n  return {\r\n    type: 'replaceEdges',\r\n    smOperationName: 'ReplaceEdge',\r\n    edges,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromEdgeReplaceOperations(\r\n  operations: Array<ReplaceEdgeOperation | ReplaceEdgesOperation>\r\n): Array<DocumentNode> {\r\n  return operations.flatMap(operation => {\r\n    if (operation.type === 'replaceEdge') {\r\n      return convertEdgeReplaceOperationToMutationArguments({\r\n        ...operation.edge,\r\n        name: operation.name,\r\n      });\r\n    } else if (operation.type === 'replaceEdges') {\r\n      return operation.edges.map(({ edge }) =>\r\n        convertEdgeReplaceOperationToMutationArguments(edge)\r\n      );\r\n    }\r\n    throw Error(`Operation not recognized: \"${operation}\"`);\r\n  });\r\n}\r\n\r\nfunction convertEdgeReplaceOperationToMutationArguments(\r\n  opts: ReplaceEdgeProperties & { name?: string }\r\n): DocumentNode {\r\n  const name = getMutationNameFromOperations([opts], 'ReplaceEdge');\r\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\r\n    opts.permissions\r\n  )}}`;\r\n\r\n  return gql`\r\n    mutation ${name} {\r\n        ReplaceEdge(\r\n            currentSourceId: \"${opts.current}\"\r\n            newSourceId: \"${opts.from}\"\r\n            targetId: \"${opts.to}\"\r\n            edge: ${edge}\r\n        )\r\n    }`;\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\r\nimport {\r\n  EdgeProperties,\r\n  UpdateEdgeOperation,\r\n  UpdateEdgeOpts,\r\n  UpdateEdgesOperation,\r\n} from './types';\r\nimport { getEdgePermissionsString } from './utilities';\r\n\r\nexport function updateEdge(edge: UpdateEdgeOpts): UpdateEdgeOperation {\r\n  return {\r\n    type: 'updateEdge',\r\n    smOperationName: 'UpdateEdge',\r\n    ...edge,\r\n  };\r\n}\r\n\r\nexport function updateEdges(\r\n  edges: Array<{\r\n    edge: EdgeProperties & { name?: string };\r\n    onSuccess?: () => any;\r\n  }>\r\n): UpdateEdgesOperation {\r\n  return {\r\n    type: 'updateEdges',\r\n    smOperationName: 'UpdateEdge',\r\n    edges,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromEdgeUpdateOperations(\r\n  operations: Array<UpdateEdgeOperation | UpdateEdgesOperation>\r\n): Array<DocumentNode> {\r\n  return operations.flatMap(operation => {\r\n    if (operation.type === 'updateEdge') {\r\n      return convertEdgeUpdateOperationToMutationArguments({\r\n        ...operation.edge,\r\n        name: operation.name,\r\n      });\r\n    } else if (operation.type === 'updateEdges') {\r\n      return operation.edges.map(({ edge }) =>\r\n        convertEdgeUpdateOperationToMutationArguments(edge)\r\n      );\r\n    }\r\n\r\n    throw Error(`Operation not recognized: \"${operation}\"`);\r\n  });\r\n}\r\n\r\nfunction convertEdgeUpdateOperationToMutationArguments(\r\n  opts: EdgeProperties & { name?: string }\r\n): DocumentNode {\r\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\r\n    opts.permissions\r\n  )}}`;\r\n  const name = getMutationNameFromOperations([opts], 'UpdateEdge');\r\n\r\n  return gql`\r\n    mutation ${name} {\r\n        UpdateEdge(\r\n            sourceId: \"${opts.from}\"\r\n            targetId: \"${opts.to}\"\r\n            edge: ${edge}\r\n        )\r\n    }`;\r\n}\r\n","import { gql } from '@apollo/client/core';\r\nimport { ISMNode } from '..';\r\n\r\nimport {\r\n  DocumentNode,\r\n  DeepPartial,\r\n  GetResultingDataTypeFromNodeDefinition,\r\n} from '../types';\r\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\r\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\r\nimport { RequiredNodeDataForCreate, OptionalNodeDataForCreate } from './types';\r\n\r\nexport type CreateNodesOperation = {\r\n  type: 'createNodes';\r\n  smOperationName: 'CreateNodes';\r\n  nodes: Array<{\r\n    data: RequiredNodeDataForCreate &\r\n      Partial<OptionalNodeDataForCreate> &\r\n      Record<string, any>;\r\n    under?: string | Array<string>;\r\n    position?: number;\r\n    onSuccess?: (data: any) => any;\r\n  }>;\r\n  name?: string;\r\n};\r\n\r\nexport function createNodes(\r\n  operation: Omit<CreateNodesOperation, 'type' | 'smOperationName'>\r\n): CreateNodesOperation {\r\n  return {\r\n    type: 'createNodes',\r\n    smOperationName: 'CreateNodes',\r\n    ...operation,\r\n  };\r\n}\r\n\r\nexport type CreateNodeOperation<\r\n  TSMNode extends ISMNode = ISMNode<any, Record<string, any>>\r\n> = {\r\n  type: 'createNode';\r\n  smOperationName: 'CreateNodes';\r\n  data: RequiredNodeDataForCreate &\r\n    Partial<OptionalNodeDataForCreate> &\r\n    // when creating a node, all we need is a deep partial of all the node's data\r\n    // since, at query time, sm-js will fill any properties which were not provided on create\r\n    DeepPartial<GetResultingDataTypeFromNodeDefinition<TSMNode>>;\r\n  under?: string | Array<string>;\r\n  name?: string;\r\n  position?: number;\r\n  onSuccess?: (data: any) => any;\r\n};\r\n\r\nexport function createNode<\r\n  TSMNode extends ISMNode = ISMNode<any, Record<string, any>>\r\n>(\r\n  operation: Omit<CreateNodeOperation<TSMNode>, 'type' | 'smOperationName'>\r\n): CreateNodeOperation<TSMNode> {\r\n  return {\r\n    type: 'createNode',\r\n    smOperationName: 'CreateNodes',\r\n    ...operation,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromTransactionCreateOperations(\r\n  operations: Array<CreateNodeOperation | CreateNodesOperation>\r\n): Array<DocumentNode> {\r\n  if (!operations.length) return [];\r\n  const allCreateNodeOperations: Array<{\r\n    data: RequiredNodeDataForCreate;\r\n    under?: string | Array<string>;\r\n  }> = operations.flatMap(operation => {\r\n    if (operation.type === 'createNode') {\r\n      return operation;\r\n    } else if (operation.type === 'createNodes') {\r\n      return operation.nodes;\r\n    } else {\r\n      throw Error(`Operation not recognized: \"${operation}\"`);\r\n    }\r\n  });\r\n\r\n  const name = getMutationNameFromOperations(operations, 'CreateNodes');\r\n\r\n  // For now, returns a single mutation\r\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\r\n  return [\r\n    gql`\r\n      mutation ${name} {\r\n        CreateNodes(\r\n          createOptions: [\r\n            ${allCreateNodeOperations\r\n              .map(convertCreateNodeOperationToCreateNodesMutationArguments)\r\n              .join('\\n')}\r\n          ] \r\n        ) {\r\n          id\r\n        }\r\n      }\r\n    `,\r\n  ];\r\n}\r\n\r\nfunction convertCreateNodeOperationToCreateNodesMutationArguments(operation: {\r\n  data: RequiredNodeDataForCreate;\r\n  under?: string | Array<string>;\r\n}): string {\r\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation.data);\r\n  let mutationArgs: Array<string> = [\r\n    `node: {\r\n        ${dataToPersistInSM}\r\n      }`,\r\n  ];\r\n\r\n  if (operation.under) {\r\n    const value =\r\n      typeof operation.under === 'string'\r\n        ? `[\"${operation.under}\"]`\r\n        : `[\"${operation.under.join('\", \"')}\"]`;\r\n\r\n    mutationArgs.push(`underIds: ${value}`);\r\n  }\r\n\r\n  return `{\r\n    ${mutationArgs.join('\\n')}\r\n  }`;\r\n}\r\n","import React from 'react';\r\nimport { SubscriptionCanceller, ISMJS, DocumentNode } from '../types';\r\nexport interface ISMContextSubscription {\r\n  results?: any;\r\n  error?: any;\r\n  querying?: boolean;\r\n  unsub?: SubscriptionCanceller;\r\n  suspendPromise?: Promise<any>;\r\n  onResults?: (newResults: any) => void;\r\n  onError?: (newError: any) => void;\r\n  setQuerying?: (querying: boolean) => void;\r\n  queryInfo?: { queryGQL: DocumentNode; queryId: string };\r\n  lastQueryTimestamp?: number;\r\n}\r\n\r\nexport interface ISMContext {\r\n  smJSInstance: ISMJS;\r\n  ongoingSubscriptionRecord: Record<string, ISMContextSubscription>;\r\n  updateSubscriptionInfo: (\r\n    subscriptionId: string,\r\n    subInfo: Partial<ISMContextSubscription>\r\n  ) => void;\r\n  scheduleCleanup: (subscriptionId: string) => void;\r\n  cancelCleanup: (subscriptionId: string) => void;\r\n}\r\n\r\nexport const SMContext = React.createContext<ISMContext>(\r\n  (undefined as unknown) as ISMContext\r\n);\r\n\r\nexport const SMProvider = (props: {\r\n  children: React.ReactNode;\r\n  smJS: ISMJS;\r\n  subscriptionTTLMs?: number;\r\n}) => {\r\n  const existingContext = React.useContext(SMContext);\r\n\r\n  if (existingContext) {\r\n    throw Error(\r\n      'Another instance of an SMProvider was already detected higher up the render tree.\\nHaving multiple instances of SMProviders is not supported and may lead to unexpected results.'\r\n    );\r\n  }\r\n\r\n  const ongoingSubscriptionRecord = React.useRef<\r\n    Record<string, ISMContextSubscription>\r\n  >({});\r\n  const cleanupTimeoutRecord = React.useRef<Record<string, NodeJS.Timeout>>({});\r\n\r\n  const updateSubscriptionInfo: ISMContext['updateSubscriptionInfo'] = React.useCallback(\r\n    (subscriptionId, subInfo) => {\r\n      ongoingSubscriptionRecord.current[subscriptionId] = {\r\n        ...ongoingSubscriptionRecord.current[subscriptionId],\r\n        ...subInfo,\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  const scheduleCleanup: ISMContext['scheduleCleanup'] = React.useCallback(\r\n    subscriptionId => {\r\n      function cleanup() {\r\n        const existingContextSubscription =\r\n          ongoingSubscriptionRecord.current[subscriptionId];\r\n        if (existingContextSubscription) {\r\n          existingContextSubscription.unsub &&\r\n            existingContextSubscription.unsub();\r\n          delete ongoingSubscriptionRecord.current[subscriptionId];\r\n        }\r\n      }\r\n\r\n      if (props.subscriptionTTLMs != null) {\r\n        cleanupTimeoutRecord.current[subscriptionId] = setTimeout(\r\n          cleanup,\r\n          props.subscriptionTTLMs\r\n        );\r\n      } else {\r\n        cleanup();\r\n      }\r\n    },\r\n    [props.subscriptionTTLMs]\r\n  );\r\n\r\n  const cancelCleanup: ISMContext['cancelCleanup'] = React.useCallback(\r\n    subscriptionId => {\r\n      clearTimeout(cleanupTimeoutRecord.current[subscriptionId]);\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <SMContext.Provider\r\n      value={{\r\n        smJSInstance: props.smJS,\r\n        ongoingSubscriptionRecord: ongoingSubscriptionRecord.current,\r\n        updateSubscriptionInfo,\r\n        scheduleCleanup,\r\n        cancelCleanup,\r\n      }}\r\n    >\r\n      {props.children}\r\n    </SMContext.Provider>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { convertQueryDefinitionToQueryInfo } from '../queryDefinitionAdapters';\r\nimport {\r\n  QueryDataReturn,\r\n  UseSubscriptionReturn,\r\n  Maybe,\r\n  UseSubscriptionQueryDefinitions,\r\n} from '../types';\r\n\r\nimport { ISMContext, ISMContextSubscription, SMContext } from './context';\r\n\r\nexport function useSubscription<\r\n  TQueryDefinitions extends UseSubscriptionQueryDefinitions\r\n>(\r\n  queryDefinitions: TQueryDefinitions,\r\n  opts?: { subscriptionId: string }\r\n): UseSubscriptionReturn<TQueryDefinitions> {\r\n  const smContext = React.useContext(SMContext);\r\n\r\n  if (!smContext) {\r\n    throw Error(\r\n      'You must wrap your app with an SMProvider before using useSubscription.'\r\n    );\r\n  }\r\n\r\n  const obj = { stack: '' };\r\n  Error.captureStackTrace(obj, useSubscription);\r\n  if (obj.stack === '') {\r\n    // Should be supported in all browsers, but better safe than sorry\r\n    throw Error('Error.captureStackTrace not supported');\r\n  }\r\n  const subscriptionId = opts?.subscriptionId || obj.stack.split('\\n')[1];\r\n\r\n  const preExistingState = getPreexistingState({\r\n    subscriptionId,\r\n    smContext,\r\n    queryDefinitions,\r\n  });\r\n\r\n  const [results, setResults] = React.useState<\r\n    QueryDataReturn<TQueryDefinitions>\r\n  >(preExistingState.results);\r\n  const [error, setError] = React.useState<any>(preExistingState.error);\r\n  const [querying, setQuerying] = React.useState<boolean>(\r\n    preExistingState.querying\r\n  );\r\n\r\n  let qdStateManager: Maybe<UseSubscriptionReturn<TQueryDefinitions> & {\r\n    cancelCleanup(): void;\r\n    scheduleCleanup(): void;\r\n  }> = null;\r\n  let qdError: Maybe<any> = null;\r\n  try {\r\n    // buildQueryDefinitionStateManager throws a promise if a query is suspending rendering\r\n    // we catch that promise here and re-throw it further down, so that we can manage cleanup\r\n    // if this function throws and it is not caught, then the number of hooks produced by this hook changes, causing a react error\r\n    qdStateManager = buildQueryDefinitionStateManager({\r\n      smContext,\r\n      subscriptionId,\r\n      queryDefinitions,\r\n      data: {\r\n        results: results,\r\n        error: error,\r\n        querying: querying,\r\n      },\r\n      handlers: {\r\n        onResults: setResults,\r\n        onError: setError,\r\n        setQuerying,\r\n      },\r\n    });\r\n  } catch (e) {\r\n    qdError = e;\r\n    qdStateManager = null;\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    qdStateManager?.cancelCleanup();\r\n    return () => {\r\n      qdStateManager?.scheduleCleanup();\r\n    };\r\n  }, [smContext, subscriptionId]);\r\n\r\n  if (qdError) throw qdError;\r\n\r\n  return qdStateManager as UseSubscriptionReturn<TQueryDefinitions> & {\r\n    cancelCleanup(): void;\r\n    scheduleCleanup(): void;\r\n  };\r\n}\r\n\r\nfunction getPreexistingState<\r\n  TQueryDefinitions extends UseSubscriptionQueryDefinitions\r\n>(opts: {\r\n  smContext: ISMContext;\r\n  subscriptionId: string;\r\n  queryDefinitions: TQueryDefinitions;\r\n}) {\r\n  const subscriptionId = opts.subscriptionId;\r\n  const preExistingContextForThisSubscription =\r\n    opts.smContext.ongoingSubscriptionRecord[subscriptionId];\r\n\r\n  const results =\r\n    preExistingContextForThisSubscription?.results ||\r\n    Object.keys(opts.queryDefinitions).reduce(\r\n      (acc, key: keyof TQueryDefinitions) => {\r\n        acc[key] = null;\r\n        return acc;\r\n      },\r\n      {} as { [key in keyof TQueryDefinitions]: null }\r\n    );\r\n  const error = preExistingContextForThisSubscription?.error;\r\n  const querying =\r\n    preExistingContextForThisSubscription?.querying != null\r\n      ? preExistingContextForThisSubscription?.querying\r\n      : true;\r\n\r\n  return { results, error, querying };\r\n}\r\n\r\n/**\r\n * useSubscription accepts query definitions that optionally disable suspense rendering\r\n * to facilitate that, this method splits all query definitions into 2 groups\r\n * @param queryDefinitions\r\n * @returns {suspendEnabled: UseSubscriptionQueryDefinitions, suspendDisabled: UseSubscriptionQueryDefinitions}\r\n */\r\nfunction splitQueryDefinitions(\r\n  queryDefinitions: UseSubscriptionQueryDefinitions\r\n): {\r\n  suspendEnabled: UseSubscriptionQueryDefinitions;\r\n  suspendDisabled: UseSubscriptionQueryDefinitions;\r\n} {\r\n  return Object.entries(queryDefinitions).reduce(\r\n    (split, [alias, queryDefinition]) => {\r\n      const suspend =\r\n        queryDefinition.useSubOpts?.doNotSuspend != null\r\n          ? !queryDefinition.useSubOpts.doNotSuspend\r\n          : true;\r\n\r\n      split[\r\n        suspend\r\n          ? subscriptionIds.suspendEnabled\r\n          : subscriptionIds.suspendDisabled\r\n      ][alias] = queryDefinition;\r\n      return split;\r\n    },\r\n    {\r\n      [subscriptionIds.suspendEnabled]: {},\r\n      [subscriptionIds.suspendDisabled]: {},\r\n    } as {\r\n      suspendEnabled: UseSubscriptionQueryDefinitions;\r\n      suspendDisabled: UseSubscriptionQueryDefinitions;\r\n    }\r\n  );\r\n}\r\n\r\nconst subscriptionIds = {\r\n  suspendEnabled: 'suspendEnabled' as 'suspendEnabled',\r\n  suspendDisabled: 'suspendDisabled' as 'suspendDisabled',\r\n};\r\n\r\nfunction buildQueryDefinitionStateManager<\r\n  TQueryDefinitions extends UseSubscriptionQueryDefinitions\r\n>(opts: {\r\n  smContext: ISMContext;\r\n  subscriptionId: string;\r\n  queryDefinitions: TQueryDefinitions;\r\n  data: {\r\n    results: QueryDataReturn<TQueryDefinitions> | undefined;\r\n    error: any;\r\n    querying: boolean;\r\n  };\r\n  handlers: {\r\n    onResults(results: any): void;\r\n    onError(error: any): void;\r\n    setQuerying(querying: boolean): void;\r\n  };\r\n}): UseSubscriptionReturn<TQueryDefinitions> & {\r\n  cancelCleanup(): void;\r\n  scheduleCleanup(): void;\r\n} {\r\n  type TReturn = UseSubscriptionReturn<TQueryDefinitions> & {\r\n    cancelCleanup(): void;\r\n    scheduleCleanup(): void;\r\n  };\r\n\r\n  // When a subscription is initialized, the state of the subscription is split\r\n  // suspended subscriptions and non suspended subscriptions are initialized separately,\r\n  // so that rendering can continue as soon as possible.\r\n  // To maintain shared state (like results, which are an aggregate of the results from both suspended and non suspended queries)\r\n  // separately from subscription specific state (like the previously generated gql fragments to compare previous and next state and discover if we need to reinitialize subscriptions)\r\n  // we have a parentSubscriptionId we use for storing shared state, and a subscriptionId for storing subscription specific state\r\n  const parentSubscriptionId = opts.subscriptionId;\r\n  const preExistingContextForThisParentSubscription =\r\n    opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId];\r\n  if (!preExistingContextForThisParentSubscription) {\r\n    opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId] = {};\r\n  }\r\n\r\n  function cancelCleanup() {\r\n    opts.smContext.cancelCleanup(parentSubscriptionId);\r\n  }\r\n\r\n  function scheduleCleanup() {\r\n    opts.smContext.scheduleCleanup(parentSubscriptionId);\r\n  }\r\n\r\n  // We can not directly call \"onResults\" from this function's arguments within the subscriptions 'onData'\r\n  // because if this component unmounts due to fallback rendering then mounts again, we would be calling onResults on the\r\n  // state of the component rendered before the fallback occured.\r\n  // To avoid that, we keep a reference to the most up to date results setter in the subscription context\r\n  // and call that in \"onData\" instead.\r\n  opts.smContext.updateSubscriptionInfo(parentSubscriptionId, {\r\n    onResults: opts.handlers.onResults,\r\n    onError: opts.handlers.onError,\r\n    setQuerying: opts.handlers.setQuerying,\r\n  });\r\n\r\n  const { suspendDisabled, suspendEnabled } = splitQueryDefinitions(\r\n    opts.queryDefinitions\r\n  );\r\n\r\n  const allSubscriptionIds = Object.values(subscriptionIds).map(\r\n    subscriptionId => parentSubscriptionId + subscriptionId\r\n  );\r\n  function getAllSubscriptionStates(): Array<\r\n    ISMContextSubscription | undefined\r\n  > {\r\n    return allSubscriptionIds.map(\r\n      subscriptionId => opts.smContext.ongoingSubscriptionRecord[subscriptionId]\r\n    );\r\n  }\r\n\r\n  // From the received queried definitions\r\n  // and a static parentSubscriptionId+subscriptionSuffix identifier\r\n  // initializes subscriptions and updates the useSubscription state on the hook\r\n  // Also maintains a copy of that state at the context level, such that the component rendering the hook\r\n  // can unmount and remount without losing its state. This is key for suspense to work, since components unmount when a promise is thrown\r\n  //\r\n  // returns a promise if there's an unresolved request and \"suspend\" is set to true\r\n  function handleNewQueryDefitions(subOpts: {\r\n    queryDefinitions: UseSubscriptionQueryDefinitions;\r\n    parentSubscriptionId: string;\r\n    subscriptionSuffix: string;\r\n    suspend: boolean;\r\n  }): Promise<any> | undefined {\r\n    const {\r\n      queryDefinitions,\r\n      parentSubscriptionId,\r\n      subscriptionSuffix,\r\n      suspend,\r\n    } = subOpts;\r\n    const subscriptionId = parentSubscriptionId + subscriptionSuffix;\r\n\r\n    const preExistingContextForThisSubscription =\r\n      opts.smContext.ongoingSubscriptionRecord[subscriptionId];\r\n\r\n    if (!preExistingContextForThisSubscription) {\r\n      opts.smContext.ongoingSubscriptionRecord[subscriptionId] = {};\r\n    }\r\n\r\n    let newQueryInfo;\r\n    if (preExistingContextForThisSubscription?.queryInfo) {\r\n      newQueryInfo = convertQueryDefinitionToQueryInfo({\r\n        queryDefinitions: subOpts.queryDefinitions,\r\n        queryId: preExistingContextForThisSubscription.queryInfo.queryId,\r\n      });\r\n    }\r\n\r\n    const queryDefinitionHasBeenUpdated =\r\n      newQueryInfo &&\r\n      preExistingContextForThisSubscription?.queryInfo &&\r\n      preExistingContextForThisSubscription.queryInfo.queryGQL !==\r\n        newQueryInfo.queryGQL;\r\n\r\n    if (\r\n      preExistingContextForThisSubscription &&\r\n      !queryDefinitionHasBeenUpdated\r\n    ) {\r\n      return preExistingContextForThisSubscription.suspendPromise;\r\n    }\r\n\r\n    if (queryDefinitionHasBeenUpdated) {\r\n      preExistingContextForThisSubscription.unsub &&\r\n        preExistingContextForThisSubscription.unsub();\r\n    }\r\n\r\n    const queryTimestamp = new Date().valueOf();\r\n    opts.smContext.updateSubscriptionInfo(parentSubscriptionId, {\r\n      querying: true,\r\n    });\r\n    opts.smContext.updateSubscriptionInfo(subscriptionId, {\r\n      querying: true,\r\n      lastQueryTimestamp: queryTimestamp,\r\n    });\r\n    console.log('querying');\r\n    opts.handlers.setQuerying(true);\r\n    const suspendPromise = opts.smContext.smJSInstance\r\n      .subscribe(queryDefinitions, {\r\n        onData: ({ results: newResults }) => {\r\n          const contextforThisSub =\r\n            opts.smContext.ongoingSubscriptionRecord[subscriptionId];\r\n          const thisQueryIsMostRecent =\r\n            contextforThisSub.lastQueryTimestamp === queryTimestamp;\r\n          if (thisQueryIsMostRecent) {\r\n            const contextForThisParentSub =\r\n              opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId];\r\n            contextForThisParentSub.onResults &&\r\n              contextForThisParentSub.onResults({\r\n                ...opts.data.results,\r\n                ...newResults,\r\n              });\r\n            opts.smContext.updateSubscriptionInfo(\r\n              subOpts.parentSubscriptionId,\r\n              {\r\n                results: { ...opts.data.results, ...newResults },\r\n              }\r\n            );\r\n          }\r\n        },\r\n        onError: error => {\r\n          const contextForThisParentSub =\r\n            opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId];\r\n          contextForThisParentSub.onError &&\r\n            contextForThisParentSub.onError(error);\r\n          opts.smContext.updateSubscriptionInfo(subOpts.parentSubscriptionId, {\r\n            error,\r\n          });\r\n        },\r\n        onSubscriptionInitialized: subscriptionCanceller => {\r\n          opts.smContext.updateSubscriptionInfo(subscriptionId, {\r\n            unsub: () => subscriptionCanceller(),\r\n          });\r\n          opts.smContext.updateSubscriptionInfo(parentSubscriptionId, {\r\n            unsub: () => {\r\n              getAllSubscriptionStates().map(\r\n                subscriptionState =>\r\n                  subscriptionState?.unsub && subscriptionState?.unsub()\r\n              );\r\n            },\r\n          });\r\n        },\r\n        onQueryInfoConstructed: queryInfo => {\r\n          opts.smContext.updateSubscriptionInfo(subscriptionId, {\r\n            queryInfo,\r\n          });\r\n        },\r\n      })\r\n      .finally(() => {\r\n        const contextForThisSub =\r\n          opts.smContext.ongoingSubscriptionRecord[subscriptionId];\r\n        const thisQueryIsMostRecent =\r\n          contextForThisSub?.lastQueryTimestamp === queryTimestamp;\r\n        if (thisQueryIsMostRecent) {\r\n          contextForThisSub.setQuerying && contextForThisSub.setQuerying(false);\r\n          opts.smContext.updateSubscriptionInfo(subscriptionId, {\r\n            suspendPromise: undefined,\r\n            querying: false,\r\n          });\r\n\r\n          // if all the queries have resolved, we can set \"querying\" to false for the parent subscription state\r\n          const allQueriesHaveResolved = !getAllSubscriptionStates().some(\r\n            state => state && state.querying\r\n          );\r\n          if (allQueriesHaveResolved) {\r\n            opts.handlers.setQuerying(false);\r\n            opts.smContext.updateSubscriptionInfo(parentSubscriptionId, {\r\n              querying: false,\r\n            });\r\n            console.log('set querying false');\r\n          }\r\n        }\r\n      });\r\n\r\n    if (!preExistingContextForThisSubscription && suspend) {\r\n      opts.smContext.updateSubscriptionInfo(subscriptionId, {\r\n        suspendPromise,\r\n      });\r\n    }\r\n\r\n    if (suspend) return suspendPromise;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  if (\r\n    opts.data.error ||\r\n    opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId].error\r\n  )\r\n    throw opts.data.error ||\r\n      opts.smContext.ongoingSubscriptionRecord[parentSubscriptionId].error;\r\n\r\n  if (Object.keys(suspendDisabled).length) {\r\n    handleNewQueryDefitions({\r\n      queryDefinitions: suspendDisabled,\r\n      parentSubscriptionId,\r\n      subscriptionSuffix: subscriptionIds.suspendDisabled,\r\n      suspend: false,\r\n    });\r\n  }\r\n\r\n  if (Object.keys(suspendEnabled).length) {\r\n    const suspendPromise = handleNewQueryDefitions({\r\n      queryDefinitions: suspendEnabled,\r\n      parentSubscriptionId,\r\n      subscriptionSuffix: subscriptionIds.suspendEnabled,\r\n      suspend: true,\r\n    });\r\n\r\n    if (suspendPromise) throw suspendPromise;\r\n  }\r\n\r\n  return {\r\n    data: opts.data.results,\r\n    error: opts.data.error,\r\n    querying: opts.data.querying,\r\n    scheduleCleanup,\r\n    cancelCleanup,\r\n  } as TReturn;\r\n}\r\n","import {\r\n  ApolloClient,\r\n  InMemoryCache,\r\n  ApolloLink,\r\n  Observable,\r\n  split,\r\n  gql,\r\n} from '@apollo/client/core';\r\nimport { WebSocketLink } from '@apollo/client/link/ws';\r\nimport { HttpLink } from '@apollo/client/link/http';\r\nimport { BatchHttpLink } from '@apollo/client/link/batch-http';\r\nimport { getMainDefinition } from '@apollo/client/utilities';\r\nimport { DocumentNode, ISMGQLClient } from './types';\r\n\r\nrequire('isomorphic-fetch');\r\n\r\ninterface IGetGQLClientOpts {\r\n  httpUrl: string;\r\n  wsUrl: string;\r\n}\r\n\r\nexport function getGQLCLient(gqlClientOpts: IGetGQLClientOpts) {\r\n  const wsLink = new WebSocketLink({\r\n    uri: gqlClientOpts.wsUrl,\r\n    options: {\r\n      reconnect: true,\r\n    },\r\n  });\r\n\r\n  const nonBatchedLink = new HttpLink({\r\n    uri: gqlClientOpts.httpUrl,\r\n  });\r\n\r\n  const queryBatchLink = split(\r\n    operation => operation.getContext().batchedQuery !== false,\r\n    new BatchHttpLink({\r\n      uri: gqlClientOpts.httpUrl,\r\n      batchMax: 30,\r\n      batchInterval: 50,\r\n    }),\r\n    nonBatchedLink\r\n  );\r\n\r\n  const mutationBatchLink = split(\r\n    operation => operation.getContext().batchedMutation,\r\n    new BatchHttpLink({\r\n      uri: gqlClientOpts.httpUrl,\r\n      // no batch max for explicitly batched mutations\r\n      // to ensure transactional integrity\r\n      batchMax: Number.MAX_SAFE_INTEGER,\r\n      batchInterval: 0,\r\n    }),\r\n    queryBatchLink\r\n  );\r\n\r\n  const requestLink = split(\r\n    // split based on operation type\r\n    ({ query }) => {\r\n      const definition = getMainDefinition(query);\r\n      return (\r\n        definition.kind === 'OperationDefinition' &&\r\n        definition.operation === 'subscription'\r\n      );\r\n    },\r\n    wsLink,\r\n    mutationBatchLink\r\n  );\r\n\r\n  function getContextWithToken(opts: { token: string }) {\r\n    return {\r\n      headers: {\r\n        Authorization: `Bearer ${opts.token}`,\r\n      },\r\n    };\r\n  }\r\n\r\n  function authenticateSubscriptionDocument(opts: {\r\n    gql: DocumentNode;\r\n    token: string;\r\n  }) {\r\n    const documentBody = opts.gql.loc?.source.body;\r\n\r\n    if (!documentBody) {\r\n      throw new Error('No documentBody found');\r\n    }\r\n\r\n    const operationsThatRequireToken = [\r\n      'GetChildren',\r\n      'GetReferences',\r\n      'GetNodes',\r\n      'GetNodesNew',\r\n      'GetNodesById',\r\n    ];\r\n\r\n    if (\r\n      operationsThatRequireToken.some(operation =>\r\n        documentBody?.includes(`${operation}(`)\r\n      )\r\n    ) {\r\n      let documentBodyWithAuthTokensInjected = documentBody;\r\n\r\n      operationsThatRequireToken.forEach(operation => {\r\n        documentBodyWithAuthTokensInjected = documentBodyWithAuthTokensInjected.replace(\r\n          new RegExp(operation + `\\\\((.*)\\\\)`, 'g'),\r\n          `${operation}($1, authToken: \"${opts.token}\")`\r\n        );\r\n      });\r\n\r\n      return gql(documentBodyWithAuthTokensInjected);\r\n    }\r\n\r\n    return opts.gql;\r\n  }\r\n\r\n  const authLink = new ApolloLink(\r\n    (operation, forward) =>\r\n      new Observable(observer => {\r\n        let handle: ZenObservable.Subscription;\r\n        Promise.resolve(operation)\r\n          .then(() => {\r\n            handle = forward(operation).subscribe({\r\n              next: observer.next.bind(observer),\r\n              error: observer.error.bind(observer),\r\n              complete: observer.complete.bind(observer),\r\n            });\r\n          })\r\n          .catch(observer.error.bind(observer));\r\n\r\n        return () => {\r\n          if (handle) handle.unsubscribe();\r\n        };\r\n      })\r\n  );\r\n\r\n  const baseClient = new ApolloClient({\r\n    link: ApolloLink.from([authLink, requestLink]),\r\n    cache: new InMemoryCache(),\r\n    defaultOptions: {\r\n      watchQuery: {\r\n        fetchPolicy: 'no-cache',\r\n        errorPolicy: 'ignore',\r\n      },\r\n      query: {\r\n        fetchPolicy: 'no-cache',\r\n        errorPolicy: 'all',\r\n      },\r\n    },\r\n  });\r\n\r\n  const gqlClient: ISMGQLClient = {\r\n    query: async opts => {\r\n      const { data } = await baseClient.query({\r\n        query: opts.gql,\r\n        context: {\r\n          batchedQuery: opts.batched != null ? opts.batched : true,\r\n          ...getContextWithToken({ token: opts.token }),\r\n        },\r\n      });\r\n\r\n      return data;\r\n    },\r\n    subscribe: opts => {\r\n      const subscription = baseClient\r\n        .subscribe({\r\n          query: authenticateSubscriptionDocument(opts),\r\n        })\r\n        .subscribe({\r\n          next: message => {\r\n            if (!message.data)\r\n              opts.onError(\r\n                new Error(`Unexpected message structure.\\n${message}`)\r\n              );\r\n            else opts.onMessage(message.data);\r\n          },\r\n          error: opts.onError,\r\n        });\r\n\r\n      return () => subscription.unsubscribe();\r\n    },\r\n    mutate: async opts => {\r\n      return await Promise.all(\r\n        opts.mutations.map(mutation =>\r\n          baseClient.mutate({\r\n            mutation,\r\n            context: {\r\n              batchedMutation: true,\r\n              ...getContextWithToken({ token: opts.token }),\r\n            },\r\n          })\r\n        )\r\n      );\r\n    },\r\n  };\r\n\r\n  return gqlClient;\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\nimport { OBJECT_PROPERTY_SEPARATOR } from '..';\r\n\r\nimport {\r\n  DeepPartial,\r\n  GetResultingDataTypeFromNodeDefinition,\r\n  ISMNode,\r\n} from '../types';\r\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\r\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\r\n\r\nexport type UpdateNodesOperation = {\r\n  type: 'updateNodes';\r\n  smOperationName: 'UpdateNodes';\r\n  nodes: Array<{\r\n    data: { id: string } & Record<string, any>;\r\n    position?: number;\r\n    onSuccess?: (data: any) => void;\r\n    onFail?: () => void;\r\n  }>;\r\n  name?: string;\r\n};\r\n\r\nexport function updateNodes(\r\n  operation: Omit<UpdateNodesOperation, 'type' | 'smOperationName'>\r\n): UpdateNodesOperation {\r\n  return {\r\n    type: 'updateNodes',\r\n    smOperationName: 'UpdateNodes',\r\n    ...operation,\r\n  };\r\n}\r\n\r\nexport type UpdateNodeOperation<\r\n  TSMNode extends ISMNode = ISMNode<any, Record<string, any>>\r\n> = {\r\n  type: 'updateNode';\r\n  smOperationName: 'UpdateNodes';\r\n  data: { id: string } & DeepPartial<\r\n    GetResultingDataTypeFromNodeDefinition<TSMNode>\r\n  >;\r\n  name?: string;\r\n  onSuccess?: (data: any) => void;\r\n  onFail?: () => void;\r\n};\r\n\r\nexport function updateNode<\r\n  TSMNode extends ISMNode = ISMNode<any, Record<string, any>>\r\n>(\r\n  operation: Omit<UpdateNodeOperation<TSMNode>, 'type' | 'smOperationName'>\r\n): UpdateNodeOperation<TSMNode> {\r\n  return {\r\n    type: 'updateNode',\r\n    smOperationName: 'UpdateNodes',\r\n    ...operation,\r\n  };\r\n}\r\n\r\nfunction getPropertiesToNull(object: Record<string, any>) {\r\n  return Object.entries(object).reduce((acc, [key, value]) => {\r\n    if (value == null) acc.push(key);\r\n    else if (!Array.isArray(value) && typeof value === 'object') {\r\n      acc.push(\r\n        ...getPropertiesToNull(value).map(\r\n          property => `${key}${OBJECT_PROPERTY_SEPARATOR}${property}`\r\n        )\r\n      );\r\n    }\r\n\r\n    return acc;\r\n  }, [] as Array<string>);\r\n}\r\n\r\nexport function getMutationsFromTransactionUpdateOperations(\r\n  operations: Array<UpdateNodeOperation | UpdateNodesOperation>\r\n): Array<DocumentNode> {\r\n  if (!operations.length) return [];\r\n\r\n  const allUpdateNodeOperations: Array<{\r\n    id: string;\r\n  }> = operations.flatMap(operation => {\r\n    if (operation.type === 'updateNode') {\r\n      return operation.data;\r\n    } else if (operation.type === 'updateNodes') {\r\n      return operation.nodes.map(({ data }) => data);\r\n    } else {\r\n      throw Error(`Operation not recognized: \"${operation}\"`);\r\n    }\r\n  });\r\n\r\n  const name = getMutationNameFromOperations(operations, 'UpdateNodes');\r\n\r\n  const dropPropertiesMutations = allUpdateNodeOperations.reduce(\r\n    (acc, updateNodeOperation) => {\r\n      const propertiesToNull = getPropertiesToNull(updateNodeOperation);\r\n      if (propertiesToNull.length) {\r\n        acc.push(gql`\r\n        mutation {\r\n          DropProperties(\r\n            nodeIds: [\"${updateNodeOperation.id}\"]\r\n            propertyNames: [${propertiesToNull\r\n              .map(prop => `\"${prop}${OBJECT_PROPERTY_SEPARATOR}*\"`)\r\n              .join(',')}]\r\n  \r\n          )\r\n          { \r\n            id\r\n          }\r\n      }\r\n      `);\r\n      }\r\n      return acc;\r\n    },\r\n    [] as Array<DocumentNode>\r\n  );\r\n\r\n  // For now, returns a single mutation\r\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\r\n  return [\r\n    gql`\r\n        mutation ${name} {\r\n          UpdateNodes(\r\n            nodes: [\r\n              ${allUpdateNodeOperations\r\n                .map(convertUpdateNodeOperationToUpdateNodesMutationArguments)\r\n                .join('\\n')}\r\n            ] \r\n          ) {\r\n            id\r\n          }\r\n        }\r\n      `,\r\n  ].concat(dropPropertiesMutations);\r\n}\r\n\r\nfunction convertUpdateNodeOperationToUpdateNodesMutationArguments(operation: {\r\n  id: string;\r\n}): string {\r\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation);\r\n\r\n  return `{\r\n      ${dataToPersistInSM}\r\n    }`;\r\n}\r\n","import { createDOFactory } from './DO';\r\nimport { createDOProxyGenerator } from './DOProxyGenerator';\r\nimport { OptimisticUpdatesOrchestrator } from './OptimisticUpdates';\r\nimport { RepositoryFactory } from './Repository';\r\nimport { generateQuerier, generateSubscriber } from './smQueriers';\r\nimport { createSMQueryManager } from './SMQueryManager';\r\nimport { createTransaction } from './transaction/transaction';\r\nimport {\r\n  ISMJS,\r\n  SMConfig,\r\n  ISMData,\r\n  SMDataDefaultFn,\r\n  NodeRelationalQueryBuilderRecord,\r\n  NodeMutationFn,\r\n  NodeDefArgs,\r\n  ISMNode,\r\n  SMDataEnum,\r\n  MapFnForNode,\r\n  QueryDefinition,\r\n  ValidFilterForNode,\r\n  GetAllAvailableNodeDataType,\r\n  DeepPartial,\r\n  QueryDefinitionTarget,\r\n  IChildrenQuery,\r\n  IChildrenQueryBuilder,\r\n  IByReferenceQuery,\r\n  IByReferenceQueryBuilder,\r\n  GetResultingDataTypeFromNodeDefinition,\r\n  GetResultingDataTypeFromProperties,\r\n  GetResultingDataFromQueryDefinition,\r\n} from './types';\r\n\r\nexport {\r\n  ISMNode,\r\n  SMDataEnum,\r\n  MapFnForNode,\r\n  ValidFilterForNode,\r\n  QueryDefinition,\r\n  ISMJS,\r\n  GetAllAvailableNodeDataType,\r\n  DeepPartial,\r\n  QueryDefinitionTarget,\r\n  IChildrenQuery,\r\n  IChildrenQueryBuilder,\r\n  IByReferenceQuery,\r\n  IByReferenceQueryBuilder,\r\n  GetResultingDataTypeFromNodeDefinition,\r\n  GetResultingDataTypeFromProperties,\r\n  GetResultingDataFromQueryDefinition,\r\n};\r\nexport * from './smDataTypes';\r\nexport * from './react';\r\nexport * from './config';\r\nexport * from './gqlClient';\r\n\r\nexport class SMJS implements ISMJS {\r\n  public gqlClient: ISMJS['gqlClient'];\r\n  public plugins: ISMJS['plugins'];\r\n  public query: ISMJS['query'];\r\n  public subscribe: ISMJS['subscribe'];\r\n  public SMQueryManager: ISMJS['SMQueryManager'];\r\n  public transaction: ISMJS['transaction'];\r\n  public tokens: Record<string, string> = {};\r\n  public DOFactory: ISMJS['DOFactory'];\r\n  public DOProxyGenerator: ISMJS['DOProxyGenerator'];\r\n  private optimisticUpdatesOrchestrator: InstanceType<\r\n    typeof OptimisticUpdatesOrchestrator\r\n  >;\r\n\r\n  constructor(config: SMConfig) {\r\n    this.gqlClient = config.gqlClient;\r\n    this.plugins = config.plugins;\r\n    this.query = generateQuerier({ smJSInstance: this });\r\n    this.subscribe = generateSubscriber(this);\r\n    this.DOProxyGenerator = createDOProxyGenerator(this);\r\n    this.DOFactory = createDOFactory(this);\r\n    this.SMQueryManager = createSMQueryManager(this);\r\n    this.optimisticUpdatesOrchestrator = new OptimisticUpdatesOrchestrator();\r\n    this.transaction = createTransaction(this, {\r\n      onUpdateRequested: this.optimisticUpdatesOrchestrator.onUpdateRequested,\r\n    });\r\n  }\r\n\r\n  public def<\r\n    TNodeType extends string,\r\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n    TNodeComputedData extends Record<string, any> = {},\r\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord = {},\r\n    TNodeMutations extends Record<\r\n      string,\r\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\r\n    > = {}\r\n  >(\r\n    def: NodeDefArgs<\r\n      TNodeType,\r\n      TNodeData,\r\n      TNodeComputedData,\r\n      TNodeRelationalData,\r\n      TNodeMutations\r\n    >\r\n  ): ISMNode<\r\n    TNodeType,\r\n    TNodeData,\r\n    TNodeComputedData,\r\n    TNodeRelationalData,\r\n    TNodeMutations\r\n  > {\r\n    const DOClass = this.DOFactory(def);\r\n\r\n    return {\r\n      _isSMNodeDef: true,\r\n      do: DOClass,\r\n      repository: RepositoryFactory({\r\n        def,\r\n        DOClass,\r\n        onDOConstructed: this.optimisticUpdatesOrchestrator.onDOConstructed,\r\n        onDODeleted: this.optimisticUpdatesOrchestrator.onDODeleted,\r\n        onDataReceived: this.optimisticUpdatesOrchestrator\r\n          .onPersistedDataReceived,\r\n      }),\r\n      type: def.type,\r\n      smData: def.properties,\r\n      smComputed: def.computed,\r\n      smRelational: def.relational,\r\n      smMutations: def.mutations,\r\n    };\r\n  }\r\n\r\n  public getToken(opts: { tokenName: string }): string {\r\n    return this.tokens[opts.tokenName];\r\n  }\r\n\r\n  public setToken(opts: { tokenName: string; token: string }): void {\r\n    this.tokens[opts.tokenName] = opts.token;\r\n  }\r\n\r\n  public clearTokens() {\r\n    this.tokens = {};\r\n  }\r\n}\r\n","import {\r\n  SMNotUpToDateException,\r\n  SMNotUpToDateInComputedException,\r\n} from './exceptions';\r\nimport { OBJECT_PROPERTY_SEPARATOR } from './smDataTypes';\r\nimport {\r\n  ISMJS,\r\n  ISMData,\r\n  SMDataDefaultFn,\r\n  IDOProxy,\r\n  ISMNode,\r\n  NodeDO,\r\n  Maybe,\r\n  RelationalQueryRecordEntry,\r\n  SM_DATA_TYPES,\r\n} from './types';\r\n\r\nexport function createDOProxyGenerator(smJSInstance: ISMJS) {\r\n  /**\r\n   * When some data fetcher like \"useQuery\" requests some data we do not directly return the DO instances\r\n   * Instead, we decorate each DO instance with a bit of functionality\r\n   * Firstly, we add getters for relational results\r\n   *      For example, if I request a list of todos and an assignee for each of those todos\r\n   *        this proxy generator would be adding an \"assignee\" getter to each todo and\r\n   *        that assignee getter would return a PROXIED DO for that user\r\n   *\r\n   * Why not just store that data on the do instance directly?\r\n   *      For this case I just described it wouldn't be a problem, since a todo has a single assignee\r\n   *      But imagine a scenario in which a developer is querying for a specific meeting and all active todos in that meeting\r\n   *        and then lazily querying all the archived todos for that meeting.\r\n   *        If the developer isn't extremely careful with naming collision (activeTodos vs archivedTodos distinction, vs just calling them \"todos\")\r\n   *        it's easy to see how this would create a problem if both query sources are getting the same DO instance\r\n   *\r\n   *      To get around this problem, EACH REQUEST RESULT WILL RETURN ITS OWN INSTANCE OF A PROXIED DO\r\n   *         so naming collision is never a problem.\r\n   *\r\n   *      This also gives us the benefit of support different paging results being displayed simultaneously, since again, the relation results from different\r\n   *         queries will never overwrite each other.\r\n   *\r\n   *\r\n   * Another use for this proxy is to ensure the developer receives helpful errors when they try to read some data that is not being subscribed to\r\n   *      This means that if I query a list of users, request their \"firstName\" and \"id\", but then attempt to read user.lastName from the result of that query\r\n   *      we don't just return the cached value, or undefined, because this is likely unintentional. Most apps will want to have real time data.\r\n   *\r\n   *      Instead, we'll throw an error and tell them - hey, you tried to read this property from this node type in this query, but you didn't request it/aren't subscribed to it!\r\n   */\r\n  return function DOProxyGenerator<\r\n    TNodeType extends string,\r\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n    TNodeComputedData extends Record<string, any>,\r\n    TRelationalResults extends Record<string, Array<IDOProxy> | IDOProxy>\r\n  >(opts: {\r\n    node: ISMNode<TNodeType, TNodeData, TNodeComputedData>;\r\n    queryId: string;\r\n    do: NodeDO;\r\n    // The DOProxy protects the dev from reading a property that we haven't actually queried from SM\r\n    allPropertiesQueried: Array<string>;\r\n    relationalResults: Maybe<TRelationalResults>;\r\n    relationalQueries: Maybe<Record<string, RelationalQueryRecordEntry>>;\r\n  }): NodeDO & TRelationalResults & IDOProxy {\r\n    let relationalResults = opts.relationalResults;\r\n\r\n    // Casting to unknown here because we don't want type safety around structure of a node's data when building plugins\r\n    // but completely losing type safety in opts.node.smComputed would break the return type inference in QueryDataReturn\r\n    const nodeSMComputed = (opts.node.smComputed as unknown) as Record<\r\n      string,\r\n      (proxy: IDOProxy) => any\r\n    >;\r\n    const computedAccessors = nodeSMComputed\r\n      ? Object.keys(nodeSMComputed).reduce((acc, computedKey) => {\r\n          let computedFn = () => nodeSMComputed[computedKey](proxy as IDOProxy);\r\n          smJSInstance.plugins?.forEach(plugin => {\r\n            if (plugin.DOProxy?.computedDecorator) {\r\n              computedFn = plugin.DOProxy.computedDecorator({\r\n                ProxyInstance: proxy,\r\n                computedFn,\r\n              });\r\n            }\r\n          });\r\n\r\n          acc[computedKey] = computedFn;\r\n\r\n          return acc;\r\n        }, {} as Record<string, () => any>)\r\n      : {};\r\n\r\n    const proxy = new Proxy(opts.do as Record<string, any>, {\r\n      getOwnPropertyDescriptor: function(target, key: string) {\r\n        // This gives better json stringify results\r\n        // by preventing attempts to get properties which are not\r\n        // guaranteed to be up to date\r\n        // @TODO write tests for this enumeration\r\n        if (\r\n          opts.allPropertiesQueried.includes(key) ||\r\n          (opts.relationalQueries &&\r\n            Object.keys(opts.relationalQueries).includes(key))\r\n        ) {\r\n          return {\r\n            ...Object.getOwnPropertyDescriptor(target, key),\r\n            enumerable: true,\r\n            configurable: true,\r\n          };\r\n        }\r\n\r\n        return {\r\n          ...Object.getOwnPropertyDescriptor(target, key),\r\n          enumerable: false,\r\n        };\r\n      },\r\n      get: (target, key: string) => {\r\n        if (key === 'updateRelationalResults') {\r\n          return (newRelationalResults: Maybe<TRelationalResults>) => {\r\n            relationalResults = {\r\n              ...relationalResults,\r\n              ...newRelationalResults,\r\n            } as Maybe<TRelationalResults>;\r\n          };\r\n        }\r\n\r\n        if (\r\n          relationalResults &&\r\n          opts.relationalQueries &&\r\n          Object.keys(relationalResults).includes(key)\r\n        ) {\r\n          // SM returns an array when \"byReference\" is used\r\n          // but we only care about the first result\r\n          if ('byReference' in opts.relationalQueries[key]) {\r\n            const results = relationalResults[key];\r\n            if (!Array.isArray(results))\r\n              throw Error(`Expected results to be an array but it wasn't`);\r\n            return results[0];\r\n          }\r\n          return relationalResults[key];\r\n        }\r\n\r\n        if (Object.keys(opts.node.smData).includes(key)) {\r\n          if (!opts.allPropertiesQueried.includes(key)) {\r\n            throw new SMNotUpToDateException({\r\n              propName: key,\r\n              queryId: opts.queryId,\r\n              nodeType: opts.node.type,\r\n            });\r\n          }\r\n\r\n          const smDataForThisProp = opts.node.smData[key] as ISMData;\r\n          if (\r\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\r\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\r\n          ) {\r\n            // do not return an object if this prop came back as null from SM\r\n            if (opts.do[key] == null) return opts.do[key];\r\n\r\n            return getNestedObjectWithNotUpToDateProtection({\r\n              nodeType: opts.node.type,\r\n              queryId: opts.queryId,\r\n              allCachedData: opts.do[key],\r\n              smDataForThisObject: smDataForThisProp.boxedValue,\r\n              allPropertiesQueried: opts.allPropertiesQueried,\r\n              parentObjectKey: key,\r\n            });\r\n          }\r\n\r\n          return opts.do[key];\r\n        } else if (computedAccessors[key]) {\r\n          try {\r\n            return computedAccessors[key]();\r\n          } catch (e) {\r\n            if (e instanceof SMNotUpToDateException) {\r\n              throw new SMNotUpToDateInComputedException({\r\n                computedPropName: key,\r\n                propName: e.propName,\r\n                nodeType: opts.node.type,\r\n                queryId: opts.queryId,\r\n              });\r\n            }\r\n\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        return target[key];\r\n      },\r\n    }) as NodeDO & TRelationalResults & IDOProxy;\r\n\r\n    return proxy;\r\n  };\r\n\r\n  function getNestedObjectWithNotUpToDateProtection(opts: {\r\n    nodeType: string;\r\n    queryId: string;\r\n    allCachedData: Record<string, any>;\r\n    smDataForThisObject: Record<string, ISMData>;\r\n    allPropertiesQueried: Array<string>;\r\n    parentObjectKey: Maybe<string>;\r\n  }) {\r\n    const objectToReturn = {};\r\n\r\n    Object.keys(opts.smDataForThisObject).forEach(objectProp => {\r\n      const name = opts.parentObjectKey\r\n        ? `${opts.parentObjectKey}${OBJECT_PROPERTY_SEPARATOR}${objectProp}`\r\n        : objectProp;\r\n      const smDataForThisProp = opts.smDataForThisObject[objectProp];\r\n      const isUpToDate =\r\n        opts.allPropertiesQueried.includes(name) ||\r\n        // this second case handles ensuring that nested objects are enumerable\r\n        // for example, if user matches the interface { address: { apt: { floor: number, unit: number } } }\r\n        // and we request address_apt_floor and address_apt_unit\r\n        // we need to make address.apt enumerable below\r\n        opts.allPropertiesQueried.some(prop => prop.startsWith(name));\r\n\r\n      Object.defineProperty(objectToReturn, objectProp, {\r\n        // @TODO write tests for this enumeration\r\n        enumerable: isUpToDate,\r\n        get: () => {\r\n          if (\r\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\r\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\r\n          ) {\r\n            if (opts.allCachedData[objectProp] == null)\r\n              return opts.allCachedData[objectProp];\r\n\r\n            return getNestedObjectWithNotUpToDateProtection({\r\n              nodeType: opts.nodeType,\r\n              queryId: opts.queryId,\r\n              allCachedData: opts.allCachedData[objectProp],\r\n              smDataForThisObject: smDataForThisProp.boxedValue,\r\n              allPropertiesQueried: opts.allPropertiesQueried,\r\n              parentObjectKey: name,\r\n            });\r\n          }\r\n\r\n          if (!isUpToDate) {\r\n            throw new SMNotUpToDateException({\r\n              propName: name,\r\n              nodeType: opts.nodeType,\r\n              queryId: opts.queryId,\r\n            });\r\n          }\r\n\r\n          return opts.allCachedData\r\n            ? opts.allCachedData[objectProp]\r\n            : undefined;\r\n        },\r\n      });\r\n    });\r\n\r\n    return objectToReturn;\r\n  }\r\n}\r\n","import { PROPERTIES_QUERIED_FOR_ALL_NODES } from './consts';\r\nimport { NULL_TAG } from './dataConversions';\r\nimport { SMData } from './smDataTypes';\r\nimport {\r\n  ISMJS,\r\n  ISMData,\r\n  SMDataDefaultFn,\r\n  NodeRelationalQueryBuilderRecord,\r\n  NodeMutationFn,\r\n  NodeDO,\r\n  NodeComputedFns,\r\n  NodeRelationalFns,\r\n  DeepPartial,\r\n  NodeRelationalQueryBuilder,\r\n  ISMNode,\r\n  SM_DATA_TYPES,\r\n} from './types';\r\n\r\nexport function createDOFactory(smJSInstance: ISMJS) {\r\n  /**\r\n   * Returns a DO class, since there is one instance of the DO class\r\n   * for each instance of that node type that is fetched from SM\r\n   */\r\n  return function DOFactory<\r\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\r\n    TNodeComputedData extends Record<string, any>,\r\n    // the tsignore here is necessary\r\n    // because the generic that NodeRelationalQueryBuilderRecord needs is\r\n    // the node definition for the origin of the relational queries\r\n    // which when defining a node, is the node being defined\r\n    // attempting to replicate the node here would always end up in a loop\r\n    // since we need the relational data to construct a node\r\n    // and need the node to construct the relational data (without this ts ignore)\r\n    // @ts-ignore\r\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\r\n    TNodeMutations extends Record<\r\n      string,\r\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\r\n    >,\r\n    TDOClass = new (initialData?: Record<string, any>) => NodeDO\r\n  >(node: {\r\n    type: string;\r\n    properties: TNodeData;\r\n    computed?: NodeComputedFns<TNodeData, TNodeComputedData>;\r\n    // @ts-ignore\r\n    relational?: NodeRelationalFns<TNodeRelationalData>;\r\n    mutations?: TNodeMutations;\r\n  }): TDOClass {\r\n    // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\r\n    // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\r\n    // eslint-disable-next-line\r\n    // @ts-ignore\r\n    return class DO implements TDOClass {\r\n      public parsedData: DeepPartial<TNodeData>;\r\n      public version: number = -1;\r\n      public id: string;\r\n      public lastUpdatedBy: string;\r\n      public persistedData: Record<string, any> = {};\r\n      private _defaults: Record<keyof TNodeData, any>;\r\n      public type = node.type;\r\n\r\n      constructor(\r\n        initialData: DeepPartial<TNodeData> & {\r\n          version: number;\r\n          id: string;\r\n          lastUpdatedBy: string;\r\n        }\r\n      ) {\r\n        this._defaults = this.getDefaultData(node.properties);\r\n        this.id = initialData.id;\r\n        this.lastUpdatedBy = initialData.lastUpdatedBy;\r\n        if (initialData.version != null) {\r\n          this.version = Number(initialData.version);\r\n        }\r\n\r\n        if (initialData) {\r\n          this.persistedData = this.parseReceivedData({\r\n            initialData,\r\n            nodeProperties: node.properties,\r\n          });\r\n        }\r\n\r\n        this.parsedData = this.getParsedData({\r\n          smData: node.properties,\r\n          persistedData: this.persistedData,\r\n          defaultData: this._defaults,\r\n        });\r\n        smJSInstance.plugins?.forEach(plugin => {\r\n          if (plugin.DO?.onConstruct) {\r\n            plugin.DO.onConstruct({\r\n              DOInstance: this,\r\n              parsedDataKey: 'parsedData',\r\n            });\r\n          }\r\n        });\r\n\r\n        this.initializeNodePropGetters();\r\n        this.initializeNodeComputedGetters();\r\n        this.initializeNodeRelationalGetters();\r\n        this.initializeNodeMutations();\r\n      }\r\n\r\n      private parseReceivedData(opts: {\r\n        initialData: Record<string, any>;\r\n        nodeProperties: typeof node.properties;\r\n      }) {\r\n        const { initialData, nodeProperties } = opts;\r\n\r\n        return Object.entries(nodeProperties).reduce(\r\n          (acc, [propName, propValue]) => {\r\n            const property = this.getSMData(propValue);\r\n\r\n            const propExistsInInitialData =\r\n              propName in initialData &&\r\n              initialData[propName] != null &&\r\n              initialData[propName] !== NULL_TAG;\r\n\r\n            if (this.isObjectType(property.type) && propExistsInInitialData) {\r\n              acc[propName] = this.parseReceivedData({\r\n                initialData: initialData[propName],\r\n                nodeProperties: property.boxedValue,\r\n              });\r\n            } else if (\r\n              this.isArrayType(property.type) &&\r\n              propExistsInInitialData\r\n            ) {\r\n              acc[propName] = initialData[propName].map(\r\n                property.boxedValue.parser\r\n              );\r\n            } else if (\r\n              propName in initialData &&\r\n              initialData[propName] === null\r\n            ) {\r\n              acc[propName] = null;\r\n            } else if (propExistsInInitialData) {\r\n              acc[propName] = property.parser(initialData[propName]);\r\n            }\r\n\r\n            return acc;\r\n          },\r\n          {} as Record<string, any>\r\n        );\r\n      }\r\n\r\n      private getDefaultData = (\r\n        nodePropertiesOrSMData:\r\n          | typeof node.properties\r\n          | SMData<any, any, any>\r\n          | ((_default: any) => SMData<any, any, any>)\r\n      ): Record<keyof TNodeData, any> => {\r\n        if (nodePropertiesOrSMData instanceof SMData) {\r\n          if (this.isObjectType(nodePropertiesOrSMData.type)) {\r\n            return this.getDefaultData(nodePropertiesOrSMData.boxedValue);\r\n          }\r\n          return nodePropertiesOrSMData.defaultValue;\r\n        }\r\n\r\n        const getDefaultFnValue = (\r\n          propName?: keyof TNodeData,\r\n          defaultSMData?: ISMData\r\n        ) => {\r\n          const defaultFn =\r\n            defaultSMData ||\r\n            ((nodePropertiesOrSMData as TNodeData)[\r\n              propName as keyof TNodeData\r\n            ] as any)._default;\r\n\r\n          // if a boolean dataType is not passed a default value, it returns an error. We throw it here\r\n          if (defaultFn instanceof Error) {\r\n            throw defaultFn;\r\n          }\r\n\r\n          // if array type, we need to set the default value as an array containing the parent type's boxedValue\r\n          if (this.isArrayType(defaultFn.type)) {\r\n            if (this.isObjectType(defaultFn.boxedValue.type)) {\r\n              return [this.getDefaultData(defaultFn.boxedValue.boxedValue)];\r\n            }\r\n            return [defaultFn.boxedValue.defaultValue];\r\n          }\r\n\r\n          return defaultFn.defaultValue;\r\n        };\r\n\r\n        if (typeof nodePropertiesOrSMData === 'function') {\r\n          return getDefaultFnValue(\r\n            undefined,\r\n            (nodePropertiesOrSMData as any)._default as ISMData\r\n          );\r\n        }\r\n\r\n        return Object.keys(nodePropertiesOrSMData).reduce(\r\n          (acc, prop: keyof TNodeData) => {\r\n            const propValue = nodePropertiesOrSMData[prop] as ISMData;\r\n            if (\r\n              this.isObjectType(propValue.type) ||\r\n              this.isRecordType(propValue.type)\r\n            ) {\r\n              acc[prop] = this.getDefaultData(propValue.boxedValue);\r\n            } else if (typeof propValue === 'function') {\r\n              const defaultValue = getDefaultFnValue(prop);\r\n\r\n              acc[prop] = defaultValue;\r\n            } else {\r\n              acc[prop] = (nodePropertiesOrSMData[\r\n                prop\r\n              ] as ISMData).defaultValue;\r\n            }\r\n            return acc;\r\n          },\r\n          {} as Record<keyof TNodeData, any>\r\n        );\r\n      };\r\n\r\n      private getParsedData(opts: {\r\n        smData: ISMData | Record<string, ISMData | SMDataDefaultFn>; // because it can be a single value (sm.number, sm.string, sm.boolean, sm.array, sm.record) or an object (root node data, nested objects)\r\n        persistedData: any;\r\n        defaultData: any;\r\n      }) {\r\n        if (\r\n          opts.smData instanceof SMData &&\r\n          opts.smData.isOptional &&\r\n          opts.persistedData == null\r\n        ) {\r\n          return null;\r\n        }\r\n\r\n        const property = this.getSMData(opts.smData as ISMData);\r\n\r\n        if (property instanceof SMData && property.boxedValue) {\r\n          // sm.array, sm.object or sm.record\r\n          if (this.isArrayType(property.type)) {\r\n            if (opts.persistedData) {\r\n              return (opts.persistedData || []).map((data: any) => {\r\n                return this.getParsedData({\r\n                  smData: property.boxedValue,\r\n                  persistedData: data,\r\n                  defaultData:\r\n                    property.type === SM_DATA_TYPES.array\r\n                      ? opts.defaultData?.[0] || null // If property is a non-optional array and the boxed value is of type sm.object, the default data for an array should be an array with a single item, where that item is the default data for that object\r\n                      : null,\r\n                });\r\n              });\r\n            } else {\r\n              return opts.defaultData;\r\n            }\r\n          } else {\r\n            // sm.object, sm.record\r\n            // safe to assume that if we made it this far, the expected data type is object and it's non optional, so lets default it to {}\r\n            if (!opts.persistedData) {\r\n              opts.persistedData = {};\r\n            }\r\n\r\n            const boxedValueSMProperty = this.getSMData(property.boxedValue);\r\n\r\n            if (boxedValueSMProperty instanceof SMData) {\r\n              // sm.record\r\n              return Object.keys(opts.persistedData).reduce((acc, key) => {\r\n                acc[key] = this.getParsedData({\r\n                  smData: property.boxedValue,\r\n                  persistedData: opts.persistedData[key],\r\n                  defaultData: opts.defaultData, //opts.defaultData,\r\n                }); // no default value for values in a record\r\n                return acc;\r\n              }, {} as Record<string, any>);\r\n            } else {\r\n              // if we're dealing with an object, lets loop over the keys in its boxed value\r\n              return Object.keys(property.boxedValue).reduce((acc, key) => {\r\n                acc[key] = this.getParsedData({\r\n                  smData: property.boxedValue[key],\r\n                  persistedData: opts.persistedData[key],\r\n                  defaultData: opts.defaultData?.[key],\r\n                });\r\n                return acc;\r\n              }, {} as Record<string, any>);\r\n            }\r\n          }\r\n        } else if (property instanceof SMData) {\r\n          // sm.string, sm.boolean, sm.number\r\n\r\n          // if a property was nulled using our old format, parse as native null\r\n          if (opts.persistedData === NULL_TAG && opts.smData.isOptional) {\r\n            return null;\r\n          }\r\n\r\n          if (opts.persistedData != null) {\r\n            return property.parser(opts.persistedData);\r\n          }\r\n\r\n          return opts.defaultData;\r\n        } else {\r\n          // root of node, simply loop over keys of data definition and call this function recursively\r\n          return Object.keys(property).reduce((acc, prop) => {\r\n            acc[prop] = this.getParsedData({\r\n              // @ts-ignore\r\n              smData: property[prop],\r\n              persistedData: opts.persistedData[prop],\r\n              defaultData: opts.defaultData[prop],\r\n            });\r\n            return acc;\r\n          }, {} as Record<string, any>);\r\n        }\r\n      }\r\n\r\n      public onDataReceived = (\r\n        receivedData: {\r\n          version: number;\r\n          lastUpdatedBy: string;\r\n        } & DeepPartial<TNodeData>,\r\n        opts?: { __unsafeIgnoreVersion: boolean }\r\n      ) => {\r\n        if (receivedData.version == null) {\r\n          throw Error('Message received for a node was missing a version');\r\n        }\r\n\r\n        const newVersion = Number(receivedData.version);\r\n\r\n        // __unsafeIgnoreVersion should used by OptimisticUpdatesOrchestrator ONLY\r\n        // it allows setting the data on the DO to a version older than the last optimistic update\r\n        // so that we can revert on a failed request\r\n        if (opts?.__unsafeIgnoreVersion || newVersion >= this.version) {\r\n          this.version = newVersion;\r\n          this.lastUpdatedBy = receivedData.lastUpdatedBy;\r\n\r\n          const newData = this.parseReceivedData({\r\n            initialData: receivedData,\r\n            nodeProperties: node.properties,\r\n          });\r\n\r\n          this.extendPersistedWithNewlyReceivedData({\r\n            smData: node.properties,\r\n            object: this.persistedData,\r\n            extension: newData,\r\n          });\r\n\r\n          this.parsedData = this.getParsedData({\r\n            smData: node.properties,\r\n            persistedData: this.persistedData,\r\n            defaultData: this._defaults,\r\n          });\r\n        }\r\n      };\r\n\r\n      private extendPersistedWithNewlyReceivedData(opts: {\r\n        smData: Record<string, ISMData | SMDataDefaultFn>;\r\n        object: Record<string, any>;\r\n        extension: Record<string, any>;\r\n      }) {\r\n        Object.entries(opts.extension).forEach(([key, value]) => {\r\n          const smDataForThisProp = this.getSMData(opts.smData[key]);\r\n\r\n          // if this is a record, completely overwrite the stored persisted data\r\n          if (this.isRecordType(smDataForThisProp.type)) {\r\n            opts.object[key] = value;\r\n          } else {\r\n            // if it's an object, extend the persisted data we've received so far with the newly received data\r\n            if (this.isObjectType(smDataForThisProp.type)) {\r\n              if (value == null) {\r\n                opts.object[key] = null;\r\n              } else {\r\n                opts.object[key] = opts.object[key] || {};\r\n\r\n                this.extendPersistedWithNewlyReceivedData({\r\n                  smData: smDataForThisProp.boxedValue,\r\n                  object: opts.object[key],\r\n                  extension: value,\r\n                });\r\n              }\r\n            } else {\r\n              // otherwise no need to extend, simply overwrite the value\r\n              opts.object[key] = value;\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      /**\r\n       * initializes getters for properties that are stored on this node in SM\r\n       * as properties on this DO instance\r\n       */\r\n      private initializeNodePropGetters() {\r\n        Object.keys(node.properties).forEach(prop => {\r\n          if (PROPERTIES_QUERIED_FOR_ALL_NODES.includes(prop)) {\r\n            // do not create getters for any properties included in the node definition which are already being queried by sm-js regardless\r\n            // since the code in this DO relies on setting those properties directly using this.version or this.lastUpdatedBy\r\n            return;\r\n          }\r\n\r\n          const property = this.getSMData(node.properties[prop]);\r\n\r\n          if (this.isObjectType(property.type)) {\r\n            this.setObjectProp(prop);\r\n          } else if (this.isArrayType(property.type)) {\r\n            this.setArrayProp(prop);\r\n          } else {\r\n            this.setPrimitiveValueProp(prop);\r\n          }\r\n        });\r\n      }\r\n\r\n      private initializeNodeComputedGetters() {\r\n        const computedData = node.computed;\r\n        if (computedData) {\r\n          Object.keys(computedData).forEach(computedProp => {\r\n            this.setComputedProp({\r\n              propName: computedProp,\r\n              computedFn: computedData[computedProp] as (\r\n                data: Record<string, any>\r\n              ) => any,\r\n            });\r\n          });\r\n        }\r\n      }\r\n\r\n      private initializeNodeRelationalGetters() {\r\n        const relationalData = node.relational;\r\n        if (relationalData) {\r\n          Object.keys(relationalData).forEach(relationalProp => {\r\n            this.setRelationalProp({\r\n              propName: relationalProp,\r\n              relationalQueryGetter: relationalData[\r\n                relationalProp\r\n              ] as () => NodeRelationalQueryBuilder<any>,\r\n            });\r\n          });\r\n        }\r\n      }\r\n\r\n      private initializeNodeMutations() {\r\n        const mutations = node.mutations;\r\n        if (mutations) {\r\n          Object.keys(mutations).forEach(mutationName => {\r\n            Object.defineProperty(this, mutationName, {\r\n              get: () => mutations[mutationName].bind(this),\r\n            });\r\n          });\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Object type props have different getters and setters than non object type\r\n       * because when an object property is set we extend the previous value, instead of replacing its reference entirely (we've seen great performance gains doing this)\r\n       */\r\n      private setObjectProp = (propNameForThisObject: string) => {\r\n        Object.defineProperty(this, propNameForThisObject, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: () => {\r\n            return this.parsedData[propNameForThisObject];\r\n          },\r\n        });\r\n      };\r\n\r\n      private setPrimitiveValueProp = (propName: string) => {\r\n        Object.defineProperty(this, propName, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: () => {\r\n            return this.parsedData[propName];\r\n          },\r\n        });\r\n      };\r\n\r\n      private setArrayProp = (propName: string) => {\r\n        Object.defineProperty(this, propName, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: () => {\r\n            return this.parsedData[propName];\r\n          },\r\n        });\r\n      };\r\n\r\n      private setComputedProp(opts: {\r\n        propName: string;\r\n        computedFn: (nodeData: Record<string, any>) => any;\r\n      }) {\r\n        let computedGetter = () => opts.computedFn(this);\r\n        smJSInstance.plugins?.forEach(plugin => {\r\n          if (plugin.DO?.computedDecorator) {\r\n            computedGetter = plugin.DO.computedDecorator({\r\n              computedFn: computedGetter,\r\n              DOInstance: this,\r\n            });\r\n          }\r\n        });\r\n\r\n        Object.defineProperty(this, opts.propName, {\r\n          get: () => computedGetter(),\r\n          enumerable: true,\r\n        });\r\n      }\r\n\r\n      private setRelationalProp(opts: {\r\n        propName: string;\r\n        relationalQueryGetter: () => NodeRelationalQueryBuilder<\r\n          ISMNode<any, TNodeData, TNodeComputedData, TNodeRelationalData>\r\n        >;\r\n      }) {\r\n        Object.defineProperty(this, opts.propName, {\r\n          configurable: true,\r\n          get: () => {\r\n            return opts.relationalQueryGetter();\r\n          },\r\n        });\r\n      }\r\n\r\n      private getSMData(prop: ISMData<any, any, any> | SMDataDefaultFn) {\r\n        if (typeof prop === 'function') {\r\n          return (prop as any)._default as ISMData;\r\n        }\r\n        return prop as ISMData;\r\n      }\r\n\r\n      private isArrayType(type: string) {\r\n        return (\r\n          type === SM_DATA_TYPES.array || type === SM_DATA_TYPES.maybeArray\r\n        );\r\n      }\r\n\r\n      private isObjectType(type: string) {\r\n        return (\r\n          type === SM_DATA_TYPES.object || type === SM_DATA_TYPES.maybeObject\r\n        );\r\n      }\r\n\r\n      private isRecordType(type: string) {\r\n        return (\r\n          type === SM_DATA_TYPES.record || type === SM_DATA_TYPES.maybeRecord\r\n        );\r\n      }\r\n    };\r\n  };\r\n}\r\n","import { RELATIONAL_UNION_QUERY_SEPARATOR } from './consts';\r\nimport { SMDataParsingException } from './exceptions';\r\nimport {\r\n  IDOProxy,\r\n  Maybe,\r\n  ISMJS,\r\n  ISMQueryManager,\r\n  QueryRecord,\r\n  BaseQueryRecordEntry,\r\n  RelationalQueryRecordEntry,\r\n} from './types';\r\n\r\ntype SMQueryManagerState = Record<\r\n  string, // the alias for this set of results\r\n  SMQueryManagerStateEntry\r\n>;\r\n\r\ntype SMQueryManagerStateEntry = {\r\n  // which id or ids represent the most up to date results for this alias, used in conjunction with proxyCache to build a returned data set\r\n  idsOrIdInCurrentResult: string | Array<string>;\r\n  proxyCache: SMQueryManagerProxyCache;\r\n};\r\n\r\ntype SMQueryManagerProxyCache = Record<\r\n  string, // id of the node\r\n  SMQueryManagerProxyCacheEntry\r\n>;\r\n\r\ntype SMQueryManagerProxyCacheEntry = {\r\n  proxy: IDOProxy;\r\n  relationalState: Maybe<SMQueryManagerState>;\r\n}; // the proxy for that DO and relational state from the query results/latest subscription message\r\n\r\nexport function createSMQueryManager(smJSInstance: ISMJS) {\r\n  /**\r\n   * SMQueryManager is in charge of\r\n   *\r\n   *    1) receiving data from an SM query and notifying the appropriate DO repositories\r\n   *    2) building proxies for those DOs\r\n   *    3) keeping a cache of those generated proxies so that we can update proxies on subscription messages, rather than generating new ones\r\n   *    4) handling incoming SM subscription messages and\r\n   *       4.1) notifying DO repositories with the data in those sub messages\r\n   *       4.2) build proxies for new DOs received + update relational data (recursively) for proxies that had been previously built\r\n   *    5) building the resulting data that is returned by useSMQuery from its cache of proxies\r\n   */\r\n  return class SMQueryManager implements ISMQueryManager {\r\n    public state: SMQueryManagerState = {};\r\n    public queryRecord: QueryRecord;\r\n\r\n    constructor(queryRecord: QueryRecord) {\r\n      this.queryRecord = queryRecord;\r\n    }\r\n\r\n    public onQueryResult(opts: { queryResult: any; queryId: string }) {\r\n      this.notifyRepositories({\r\n        data: opts.queryResult,\r\n        queryRecord: this.queryRecord,\r\n      });\r\n\r\n      this.state = this.getNewStateFromQueryResult(opts);\r\n    }\r\n\r\n    public onSubscriptionMessage(opts: {\r\n      node: Record<string, any>;\r\n      operation: {\r\n        action: 'UpdateNode' | 'DeleteNode' | 'InsertNode';\r\n        path: string;\r\n      };\r\n      queryId: string;\r\n      subscriptionAlias: string;\r\n    }) {\r\n      const { node, operation, subscriptionAlias } = opts;\r\n      const queryRecordEntryForThisSubscription = this.queryRecord[\r\n        subscriptionAlias\r\n      ];\r\n\r\n      if (operation.action === 'DeleteNode' && operation.path === node.id) {\r\n        const idsOrIdInCurrentResult = this.state[opts.subscriptionAlias]\r\n          .idsOrIdInCurrentResult;\r\n        if (Array.isArray(idsOrIdInCurrentResult)) {\r\n          this.state[\r\n            opts.subscriptionAlias\r\n          ].idsOrIdInCurrentResult = idsOrIdInCurrentResult.filter(\r\n            id => id !== node.id\r\n          );\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      this.notifyRepositories({\r\n        data: {\r\n          [subscriptionAlias]: node,\r\n        },\r\n        queryRecord: {\r\n          [subscriptionAlias]: queryRecordEntryForThisSubscription,\r\n        },\r\n      });\r\n\r\n      this.updateProxiesAndStateFromSubscriptionMessage(opts);\r\n    }\r\n\r\n    /**\r\n     * Returns the current results based on received query results and subscription messages\r\n     */\r\n    getResults() {\r\n      return this.getResultsFromState(this.state);\r\n    }\r\n\r\n    /**\r\n     * Is used to build the overall results for the query, and also to build the relational results used by each proxy\r\n     * which is why \"state\" is a param here\r\n     */\r\n    public getResultsFromState(\r\n      state: SMQueryManagerState\r\n    ): Record<string, any> {\r\n      const acc = Object.keys(state).reduce((resultsAcc, queryAlias) => {\r\n        const stateForThisAlias = state[queryAlias];\r\n        const idsOrId = stateForThisAlias.idsOrIdInCurrentResult;\r\n\r\n        const resultsAlias = this.removeUnionSuffix(queryAlias);\r\n\r\n        resultsAcc[resultsAlias] = Array.isArray(idsOrId)\r\n          ? idsOrId.map(id => stateForThisAlias.proxyCache[id].proxy)\r\n          : stateForThisAlias.proxyCache[idsOrId].proxy;\r\n\r\n        return resultsAcc;\r\n      }, {} as Record<string, any>);\r\n\r\n      return acc;\r\n    }\r\n\r\n    /**\r\n     * Takes a queryRecord and the data that resulted from that query\r\n     * notifies the appropriate repositories so that DOs can be constructed or updated\r\n     */\r\n    public notifyRepositories(opts: {\r\n      data: Record<string, any>;\r\n      queryRecord: { [key: string]: BaseQueryRecordEntry };\r\n    }) {\r\n      Object.keys(opts.queryRecord).forEach(queryAlias => {\r\n        const dataForThisAlias = opts.data[queryAlias];\r\n\r\n        if (!dataForThisAlias) {\r\n          throw Error(\r\n            `notifyRepositories could not find resulting data for the alias \"${queryAlias}\" in the following queryRecord:\\n${JSON.stringify(\r\n              opts.queryRecord,\r\n              null,\r\n              2\r\n            )}\\nResulting data:\\n${JSON.stringify(opts.data, null, 2)}`\r\n          );\r\n        }\r\n\r\n        const nodeRepository = opts.queryRecord[queryAlias].def.repository;\r\n\r\n        if (Array.isArray(dataForThisAlias)) {\r\n          dataForThisAlias.forEach(data => nodeRepository.onDataReceived(data));\r\n        } else {\r\n          nodeRepository.onDataReceived(dataForThisAlias);\r\n        }\r\n\r\n        const relationalQueries = opts.queryRecord[queryAlias].relational;\r\n\r\n        if (relationalQueries) {\r\n          Object.keys(relationalQueries).forEach(relationalAlias => {\r\n            const relationalDataForThisAlias = Array.isArray(dataForThisAlias)\r\n              ? dataForThisAlias.flatMap(\r\n                  (dataEntry: any) => dataEntry[relationalAlias]\r\n                )\r\n              : dataForThisAlias[relationalAlias];\r\n\r\n            relationalDataForThisAlias.forEach((relationalDataEntry: any) => {\r\n              const relationalQuery = relationalQueries[relationalAlias];\r\n\r\n              if (relationalAlias.includes(RELATIONAL_UNION_QUERY_SEPARATOR)) {\r\n                const node = relationalDataEntry;\r\n                if (node && node.type !== relationalQuery.def.type) return;\r\n              }\r\n\r\n              this.notifyRepositories({\r\n                data: {\r\n                  [relationalAlias]: relationalDataEntry,\r\n                },\r\n                queryRecord: {\r\n                  [relationalAlias]: relationalQuery,\r\n                },\r\n              });\r\n            });\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Gets the initial state for this manager from the initial query results\r\n     *   does not execute on subscription messages\r\n     */\r\n    public getNewStateFromQueryResult(opts: {\r\n      queryResult: Record<string, any>;\r\n      queryId: string;\r\n    }): SMQueryManagerState {\r\n      return Object.keys(this.queryRecord).reduce(\r\n        (resultingStateAcc, queryAlias) => {\r\n          const cacheEntry = this.buildCacheEntry({\r\n            nodeData: opts.queryResult[queryAlias],\r\n            queryId: opts.queryId,\r\n            queryAlias,\r\n          });\r\n\r\n          if (!cacheEntry) return resultingStateAcc;\r\n          resultingStateAcc[queryAlias] = cacheEntry;\r\n\r\n          return resultingStateAcc;\r\n        },\r\n        {} as SMQueryManagerState\r\n      );\r\n    }\r\n\r\n    public buildCacheEntry(opts: {\r\n      nodeData: Record<string, any> | Array<Record<string, any>>;\r\n      queryId: string;\r\n      queryAlias: string;\r\n      queryRecord?: QueryRecord;\r\n    }): Maybe<SMQueryManagerStateEntry> {\r\n      const { nodeData, queryAlias } = opts;\r\n      const queryRecord = opts.queryRecord || this.queryRecord;\r\n      const { relational } = queryRecord[opts.queryAlias];\r\n\r\n      // if the query alias includes a relational union query separator\r\n      // and the first item in the array of results has a type that does not match the type of the node def in this query record\r\n      // this means that the result node likely matches a different type in that union\r\n      if (queryAlias.includes(RELATIONAL_UNION_QUERY_SEPARATOR)) {\r\n        const node = (opts.nodeData as Array<any>)[0];\r\n        if (node && node.type !== queryRecord[opts.queryAlias].def.type)\r\n          return null;\r\n      }\r\n\r\n      const buildRelationalStateForNode = (\r\n        node: Record<string, any>\r\n      ): Maybe<SMQueryManagerState> => {\r\n        if (!relational) return null;\r\n\r\n        return Object.keys(relational).reduce(\r\n          (relationalStateAcc, relationalAlias) => {\r\n            const relationalDataForThisAlias = node[relationalAlias];\r\n            if (!relationalDataForThisAlias) return relationalStateAcc;\r\n\r\n            const cacheEntry = this.buildCacheEntry({\r\n              nodeData: relationalDataForThisAlias,\r\n              queryId: opts.queryId,\r\n              queryAlias: relationalAlias,\r\n              queryRecord: (relational as unknown) as QueryRecord,\r\n            });\r\n            if (!cacheEntry) return relationalStateAcc;\r\n\r\n            return {\r\n              ...relationalStateAcc,\r\n              [this.removeUnionSuffix(relationalAlias)]: cacheEntry,\r\n            };\r\n          },\r\n          {} as SMQueryManagerState\r\n        );\r\n      };\r\n\r\n      const buildProxyCacheEntryForNode = (\r\n        node: Record<string, any>\r\n      ): SMQueryManagerProxyCacheEntry => {\r\n        const relationalState = buildRelationalStateForNode(node);\r\n        const nodeRepository = queryRecord[queryAlias].def.repository;\r\n\r\n        const proxy = smJSInstance.DOProxyGenerator({\r\n          node: queryRecord[opts.queryAlias].def,\r\n          allPropertiesQueried: queryRecord[opts.queryAlias].properties,\r\n          relationalQueries: relational\r\n            ? this.getApplicableRelationalQueries({\r\n                relationalQueries: relational,\r\n                nodeData: node,\r\n              })\r\n            : null,\r\n          queryId: opts.queryId,\r\n          relationalResults: !relationalState\r\n            ? null\r\n            : this.getResultsFromState(relationalState),\r\n          do: nodeRepository.byId(node.id),\r\n        });\r\n\r\n        return {\r\n          proxy,\r\n          relationalState,\r\n        };\r\n      };\r\n\r\n      if (Array.isArray(opts.nodeData)) {\r\n        if ('id' in queryRecord[opts.queryAlias]) {\r\n          if (opts.nodeData[0] == null) {\r\n            throw new SMDataParsingException({\r\n              receivedData: opts.nodeData,\r\n              message: `Queried a node by id for the query with the id \"${opts.queryId}\" but received back an empty array`,\r\n            });\r\n          }\r\n\r\n          return {\r\n            idsOrIdInCurrentResult: opts.nodeData[0].id,\r\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\r\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\r\n\r\n              return proxyCacheAcc;\r\n            }, {} as SMQueryManagerProxyCache),\r\n          };\r\n        } else {\r\n          return {\r\n            idsOrIdInCurrentResult: opts.nodeData.map(node => node.id),\r\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\r\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\r\n\r\n              return proxyCacheAcc;\r\n            }, {} as SMQueryManagerProxyCache),\r\n          };\r\n        }\r\n      } else {\r\n        return {\r\n          idsOrIdInCurrentResult: opts.nodeData.id,\r\n          proxyCache: {\r\n            [(nodeData as { id: string }).id]: buildProxyCacheEntryForNode(\r\n              nodeData\r\n            ),\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    public updateProxiesAndStateFromSubscriptionMessage(opts: {\r\n      node: any;\r\n      queryId: string;\r\n      subscriptionAlias: string;\r\n    }) {\r\n      const { node, queryId, subscriptionAlias } = opts;\r\n      const queryRecordEntryForThisSubscription = this.queryRecord[\r\n        subscriptionAlias\r\n      ];\r\n      this.state[subscriptionAlias] = this.state[subscriptionAlias] || {};\r\n      const stateForThisAlias = this.state[subscriptionAlias];\r\n      const nodeId = node.id;\r\n      const { proxy, relationalState } =\r\n        stateForThisAlias.proxyCache[nodeId] || {};\r\n\r\n      if (proxy) {\r\n        const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\r\n          {\r\n            queryId,\r\n            proxy,\r\n            newRelationalData: this.getRelationalData({\r\n              queryRecord: queryRecordEntryForThisSubscription,\r\n              node: opts.node,\r\n            }),\r\n            relationalQueryRecord:\r\n              queryRecordEntryForThisSubscription.relational || null,\r\n            currentState: { proxy, relationalState },\r\n          }\r\n        );\r\n        stateForThisAlias.proxyCache[nodeId] = newCacheEntry;\r\n      } else {\r\n        const cacheEntry = this.buildCacheEntry({\r\n          nodeData: node,\r\n          queryId,\r\n          queryAlias: subscriptionAlias,\r\n          queryRecord: this.queryRecord,\r\n        });\r\n        if (!cacheEntry) return;\r\n        const { proxyCache } = cacheEntry;\r\n\r\n        const newlyGeneratedProxy = proxyCache[node.id];\r\n\r\n        if (!newlyGeneratedProxy)\r\n          throw Error('Expected a newly generated proxy');\r\n\r\n        stateForThisAlias.proxyCache[nodeId] = proxyCache[node.id];\r\n      }\r\n\r\n      if ('id' in queryRecordEntryForThisSubscription) {\r\n        if ((stateForThisAlias.idsOrIdInCurrentResult as string) === nodeId) {\r\n          return;\r\n        }\r\n\r\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = nodeId;\r\n      } else {\r\n        if (\r\n          (\r\n            stateForThisAlias.idsOrIdInCurrentResult || ([] as Array<string>)\r\n          ).includes(nodeId)\r\n        )\r\n          return; // don't need to do anything if this id was already in the returned set\r\n\r\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = [\r\n          nodeId, // insert the new node at the start of the array\r\n          ...(this.state[opts.subscriptionAlias]\r\n            .idsOrIdInCurrentResult as Array<string>),\r\n        ];\r\n      }\r\n    }\r\n\r\n    public recursivelyUpdateProxyAndReturnNewCacheEntry(opts: {\r\n      queryId: string;\r\n      proxy: IDOProxy;\r\n      newRelationalData: Maybe<\r\n        Record<string, Array<Record<string, any> | Record<string, any>>>\r\n      >;\r\n      relationalQueryRecord: Maybe<Record<string, RelationalQueryRecordEntry>>;\r\n      currentState: SMQueryManagerProxyCacheEntry;\r\n    }): SMQueryManagerProxyCacheEntry {\r\n      const {\r\n        queryId,\r\n        proxy,\r\n        newRelationalData,\r\n        currentState,\r\n        relationalQueryRecord,\r\n      } = opts;\r\n      const { relationalState: currentRelationalState } = currentState;\r\n\r\n      const newRelationalState = !relationalQueryRecord\r\n        ? null\r\n        : Object.keys(relationalQueryRecord).reduce(\r\n            (relationalStateAcc, relationalAlias) => {\r\n              if (!newRelationalData || !newRelationalData[relationalAlias]) {\r\n                return relationalStateAcc;\r\n              }\r\n\r\n              const relationalDataForThisAlias =\r\n                newRelationalData[relationalAlias];\r\n              const queryRecordForThisAlias =\r\n                relationalQueryRecord[relationalAlias];\r\n\r\n              const currentStateForThisAlias = !currentRelationalState\r\n                ? null\r\n                : currentRelationalState[relationalAlias];\r\n\r\n              if (!currentStateForThisAlias) {\r\n                const cacheEntry = this.buildCacheEntry({\r\n                  nodeData: relationalDataForThisAlias,\r\n                  queryId,\r\n                  queryAlias: relationalAlias,\r\n                  queryRecord: (relationalQueryRecord as unknown) as QueryRecord,\r\n                });\r\n\r\n                if (!cacheEntry) return relationalStateAcc;\r\n\r\n                relationalStateAcc[relationalAlias] = cacheEntry;\r\n\r\n                return relationalStateAcc;\r\n              }\r\n\r\n              if (Array.isArray(relationalDataForThisAlias)) {\r\n                relationalStateAcc[relationalAlias] = relationalStateAcc[\r\n                  relationalAlias\r\n                ] || { proxyCache: {}, idsOrIdInCurrentResult: [] };\r\n\r\n                relationalDataForThisAlias.forEach(node => {\r\n                  const existingProxy =\r\n                    currentStateForThisAlias.proxyCache[node.id]?.proxy;\r\n\r\n                  if (!existingProxy) {\r\n                    const cacheEntry = this.buildCacheEntry({\r\n                      nodeData: node,\r\n                      queryId: queryId,\r\n                      queryAlias: relationalAlias,\r\n                      queryRecord: (relationalQueryRecord as unknown) as QueryRecord,\r\n                    });\r\n\r\n                    if (!cacheEntry) return;\r\n\r\n                    relationalStateAcc[relationalAlias] = {\r\n                      proxyCache: {\r\n                        ...relationalStateAcc[relationalAlias].proxyCache,\r\n                        [node.id]: cacheEntry.proxyCache[node.id],\r\n                      },\r\n                      idsOrIdInCurrentResult: [\r\n                        ...(relationalStateAcc[relationalAlias]\r\n                          .idsOrIdInCurrentResult as Array<string>),\r\n                        node.id,\r\n                      ],\r\n                    };\r\n                  } else {\r\n                    const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\r\n                      {\r\n                        queryId,\r\n                        proxy: existingProxy,\r\n                        newRelationalData: this.getRelationalData({\r\n                          queryRecord: queryRecordForThisAlias,\r\n                          node,\r\n                        }),\r\n                        relationalQueryRecord:\r\n                          queryRecordForThisAlias.relational || null,\r\n                        currentState:\r\n                          currentStateForThisAlias.proxyCache[node.id],\r\n                      }\r\n                    );\r\n\r\n                    relationalStateAcc[relationalAlias] = {\r\n                      proxyCache: {\r\n                        ...relationalStateAcc[relationalAlias].proxyCache,\r\n                        [node.id]: newCacheEntry,\r\n                      },\r\n                      idsOrIdInCurrentResult: [\r\n                        ...(relationalStateAcc[relationalAlias]\r\n                          .idsOrIdInCurrentResult as Array<string>),\r\n                        node.id,\r\n                      ],\r\n                    };\r\n                  }\r\n                });\r\n              } else {\r\n                throw Error(\r\n                  `Not implemented. ${JSON.stringify(\r\n                    relationalDataForThisAlias\r\n                  )}`\r\n                );\r\n              }\r\n\r\n              return relationalStateAcc;\r\n            },\r\n            {} as SMQueryManagerState\r\n          );\r\n\r\n      newRelationalState\r\n        ? proxy.updateRelationalResults(\r\n            this.getResultsFromState(newRelationalState)\r\n          )\r\n        : proxy.updateRelationalResults(null);\r\n\r\n      return {\r\n        proxy,\r\n        relationalState: newRelationalState,\r\n      };\r\n    }\r\n\r\n    public getRelationalData(opts: {\r\n      queryRecord: BaseQueryRecordEntry;\r\n      node: Record<string, any>;\r\n    }) {\r\n      return opts.queryRecord.relational\r\n        ? Object.keys(opts.queryRecord.relational).reduce(\r\n            (relationalDataAcc, relationalAlias) => {\r\n              relationalDataAcc[relationalAlias] = opts.node[relationalAlias];\r\n\r\n              return relationalDataAcc;\r\n            },\r\n            {} as Record<string, any>\r\n          )\r\n        : null;\r\n    }\r\n\r\n    public removeUnionSuffix(alias: string) {\r\n      if (alias.includes(RELATIONAL_UNION_QUERY_SEPARATOR))\r\n        return alias.split(RELATIONAL_UNION_QUERY_SEPARATOR)[0];\r\n      else return alias;\r\n    }\r\n\r\n    public getApplicableRelationalQueries(opts: {\r\n      relationalQueries: Record<string, RelationalQueryRecordEntry>;\r\n      nodeData: Record<string, any>;\r\n    }) {\r\n      return Object.keys(opts.relationalQueries).reduce(\r\n        (acc, relationalQueryAlias) => {\r\n          if (!relationalQueryAlias.includes(RELATIONAL_UNION_QUERY_SEPARATOR))\r\n            return {\r\n              ...acc,\r\n              [relationalQueryAlias]:\r\n                opts.relationalQueries[relationalQueryAlias],\r\n            };\r\n\r\n          const firstResult = opts.nodeData[relationalQueryAlias]\r\n            ? opts.nodeData[relationalQueryAlias][0]\r\n            : null;\r\n\r\n          // if the node.type returned in the relational query results does not match that of the relational query alias, skip adding this relational query\r\n          // this happens when a reference union is queried, for all nodes in the union type that do not match the type in the result\r\n          // and ensures that the correct node definition is used when building the decorated results for this query/subscription\r\n          if (\r\n            firstResult &&\r\n            firstResult.type !==\r\n              opts.relationalQueries[relationalQueryAlias].def.type\r\n          )\r\n            return acc;\r\n\r\n          return {\r\n            ...acc,\r\n            [this.removeUnionSuffix(relationalQueryAlias)]: opts\r\n              .relationalQueries[relationalQueryAlias],\r\n          };\r\n        },\r\n        {} as Record<string, RelationalQueryRecordEntry>\r\n      );\r\n    }\r\n  };\r\n}\r\n","import { DocumentNode } from '@apollo/client/core';\r\nimport { sortBy } from 'lodash';\r\nimport {\r\n  createEdge,\r\n  createEdges,\r\n  getMutationsFromEdgeCreateOperations,\r\n  dropEdge,\r\n  dropEdges,\r\n  getMutationsFromEdgeDropOperations,\r\n  replaceEdge,\r\n  replaceEdges,\r\n  getMutationsFromEdgeReplaceOperations,\r\n  updateEdge,\r\n  updateEdges,\r\n  getMutationsFromEdgeUpdateOperations,\r\n} from './edges';\r\nimport {\r\n  CreateEdgeOperation,\r\n  CreateEdgesOperation,\r\n  DropEdgeOperation,\r\n  DropEdgesOperation,\r\n  ReplaceEdgeOperation,\r\n  ReplaceEdgesOperation,\r\n  UpdateEdgeOperation,\r\n  UpdateEdgesOperation,\r\n} from './edges/types';\r\nimport {\r\n  createNode,\r\n  CreateNodeOperation,\r\n  createNodes,\r\n  CreateNodesOperation,\r\n  getMutationsFromTransactionCreateOperations,\r\n} from './create';\r\nimport {\r\n  getMutationsFromTransactionUpdateOperations,\r\n  updateNode,\r\n  UpdateNodeOperation,\r\n  updateNodes,\r\n  UpdateNodesOperation,\r\n} from './update';\r\nimport {\r\n  dropNode,\r\n  DropNodeOperation,\r\n  getMutationsFromTransactionDropOperations,\r\n} from './drop';\r\nimport { ISMJS } from '../types';\r\nimport { DEFAULT_TOKEN_NAME } from '../consts';\r\n\r\nexport interface ITransactionContext {\r\n  createNodes: typeof createNodes;\r\n  createNode: typeof createNode;\r\n  updateNodes: typeof updateNodes;\r\n  updateNode: typeof updateNode;\r\n  dropNode: typeof dropNode;\r\n  createEdge: typeof createEdge;\r\n  createEdges: typeof createEdges;\r\n  dropEdge: typeof dropEdge;\r\n  dropEdges: typeof dropEdges;\r\n  updateEdge: typeof updateEdge;\r\n  updateEdges: typeof updateEdges;\r\n  replaceEdge: typeof replaceEdge;\r\n  replaceEdges: typeof replaceEdges;\r\n}\r\n\r\ntype TIndexedOperationType = OperationType & { position?: number };\r\n\r\ntype TExecutionResult =\r\n  | Array<{\r\n      data: Record<string, any>;\r\n    }>\r\n  | Array<\r\n      Array<{\r\n        data: Record<string, any>;\r\n      }>\r\n    >;\r\n\r\ntype TOperationsByType = Record<\r\n  OperationType['type'],\r\n  Array<TIndexedOperationType>\r\n>;\r\n\r\nexport interface IPendingTransaction {\r\n  operations: TOperationsByType;\r\n  execute: () => Promise<any>;\r\n  callbackResult?: void | Promise<any> | Array<IPendingTransaction>;\r\n  token: string;\r\n}\r\n\r\ntype OperationType =\r\n  | CreateNodeOperation\r\n  | CreateNodesOperation\r\n  | UpdateNodeOperation\r\n  | UpdateNodesOperation\r\n  | DropNodeOperation\r\n  | CreateEdgeOperation\r\n  | CreateEdgesOperation\r\n  | DropEdgeOperation\r\n  | DropEdgesOperation\r\n  | UpdateEdgeOperation\r\n  | UpdateEdgesOperation\r\n  | ReplaceEdgeOperation\r\n  | ReplaceEdgesOperation;\r\n\r\nexport function createTransaction(\r\n  smJSInstance: ISMJS,\r\n  globalOperationHandlers: {\r\n    onUpdateRequested(update: {\r\n      id: string;\r\n      payload: Record<string, any>;\r\n    }): { onUpdateFailed(): void; onUpdateSuccessful(): void };\r\n  }\r\n) {\r\n  /**\r\n   * A transaction allows developers to build groups of mutations that execute with transactional integrity\r\n   *   this means if one mutation fails, others are cancelled and any graph state changes are rolled back.\r\n   *\r\n   * The callback function can return a promise if the transaction requires some data fetching to build its list of operations.\r\n   */\r\n  return function transaction(\r\n    callback:\r\n      | ((context: ITransactionContext) => void | Promise<void>)\r\n      | Array<IPendingTransaction>,\r\n    opts?: { tokenName?: string }\r\n  ) {\r\n    const operationsByType: TOperationsByType = {\r\n      createNode: [],\r\n      createNodes: [],\r\n      updateNode: [],\r\n      updateNodes: [],\r\n      dropNode: [],\r\n      createEdge: [],\r\n      createEdges: [],\r\n      dropEdge: [],\r\n      dropEdges: [],\r\n      replaceEdge: [],\r\n      replaceEdges: [],\r\n      updateEdge: [],\r\n      updateEdges: [],\r\n    };\r\n\r\n    /**\r\n     * Keeps track of the number of operations performed in this transaction (for operations that we need to provide callback data for).\r\n     * This is used to store each operation's order in the transaction so that we can map it to the response we get back from SM.\r\n     * SM responds with each operation in the order they were sent up.\r\n     */\r\n    let createOperationsCount = 0;\r\n    let updateOperationsCount = 0;\r\n\r\n    function pushOperation(operation: OperationType) {\r\n      if (!operationsByType[operation.type]) {\r\n        throw Error(\r\n          `No operationsByType array initialized for \"${operation.type}\"`\r\n        );\r\n      }\r\n      /**\r\n       * createNodes/updateNodes creates multiple nodes in a single operation,\r\n       * therefore we need to track the position of these nodes instead of just the position of the operation itself\r\n       */\r\n      if (operation.type === 'createNodes') {\r\n        createOperationsCount += 1;\r\n\r\n        operationsByType[operation.type].push({\r\n          ...operation,\r\n          position: createOperationsCount,\r\n          nodes: operation.nodes.map((node, idx) => {\r\n            return {\r\n              ...node,\r\n              position:\r\n                idx === 0\r\n                  ? createOperationsCount\r\n                  : (createOperationsCount += 1),\r\n            };\r\n          }),\r\n        });\r\n      } else if (operation.type === 'createNode') {\r\n        createOperationsCount += 1;\r\n\r\n        operationsByType[operation.type].push({\r\n          ...operation,\r\n          position: createOperationsCount,\r\n        });\r\n      } else if (operation.type === 'updateNodes') {\r\n        updateOperationsCount += 1;\r\n\r\n        operationsByType[operation.type].push({\r\n          ...operation,\r\n          position: updateOperationsCount,\r\n          nodes: operation.nodes.map((node, idx) => {\r\n            return {\r\n              ...node,\r\n              position:\r\n                idx === 0\r\n                  ? updateOperationsCount\r\n                  : (updateOperationsCount += 1),\r\n            };\r\n          }),\r\n        });\r\n      } else if (operation.type === 'updateNode') {\r\n        updateOperationsCount += 1;\r\n        operationsByType[operation.type].push({\r\n          ...operation,\r\n          position: updateOperationsCount,\r\n        });\r\n      } else {\r\n        operationsByType[operation.type].push(operation);\r\n      }\r\n    }\r\n\r\n    const context: ITransactionContext = {\r\n      createNode: opts => {\r\n        const operation = createNode(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      createNodes: opts => {\r\n        const operation = createNodes(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      updateNode: opts => {\r\n        const operation = updateNode(opts);\r\n        const {\r\n          onUpdateSuccessful,\r\n          onUpdateFailed,\r\n        } = globalOperationHandlers.onUpdateRequested({\r\n          id: opts.data.id,\r\n          payload: opts.data,\r\n        });\r\n\r\n        pushOperation({\r\n          ...operation,\r\n          onSuccess: data => {\r\n            operation.onSuccess && operation.onSuccess(data);\r\n            onUpdateSuccessful();\r\n          },\r\n          onFail: () => {\r\n            operation.onFail && operation.onFail();\r\n            onUpdateFailed();\r\n          },\r\n        });\r\n        return operation;\r\n      },\r\n      updateNodes: opts => {\r\n        const operation = updateNodes(opts);\r\n\r\n        const globalHandlers = opts.nodes.map(node => {\r\n          return globalOperationHandlers.onUpdateRequested({\r\n            id: node.data.id,\r\n            payload: node.data,\r\n          });\r\n        });\r\n        pushOperation({\r\n          ...operation,\r\n          nodes: operation.nodes.map((node, nodeIdx) => ({\r\n            ...node,\r\n            onSuccess: data => {\r\n              node.onSuccess && node.onSuccess(data);\r\n              globalHandlers[nodeIdx].onUpdateSuccessful();\r\n            },\r\n            onFail: () => {\r\n              node.onFail && node.onFail();\r\n              globalHandlers[nodeIdx].onUpdateFailed();\r\n            },\r\n          })),\r\n        });\r\n        return operation;\r\n      },\r\n      dropNode: opts => {\r\n        const operation = dropNode(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      createEdge: opts => {\r\n        const operation = createEdge(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      createEdges: opts => {\r\n        const operation = createEdges(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      dropEdge: opts => {\r\n        const operation = dropEdge(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      dropEdges: opts => {\r\n        const operation = dropEdges(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      updateEdge: opts => {\r\n        const operation = updateEdge(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      updateEdges: opts => {\r\n        const operation = updateEdges(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      replaceEdge: opts => {\r\n        const operation = replaceEdge(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n      replaceEdges: opts => {\r\n        const operation = replaceEdges(opts);\r\n        pushOperation(operation);\r\n        return operation;\r\n      },\r\n    };\r\n\r\n    function sortMutationsByTransactionPosition<T>(\r\n      operations: Array<TIndexedOperationType>\r\n    ) {\r\n      return (sortBy(\r\n        operations,\r\n        operation => operation.position\r\n      ) as unknown) as T;\r\n    }\r\n\r\n    function getAllMutations(\r\n      operations: TOperationsByType\r\n    ): Array<DocumentNode> {\r\n      return [\r\n        ...getMutationsFromTransactionCreateOperations(\r\n          sortMutationsByTransactionPosition([\r\n            ...(operations.createNode as Array<\r\n              CreateNodeOperation & { position: number }\r\n            >),\r\n            ...(operations.createNodes as Array<\r\n              CreateNodesOperation & { position: number }\r\n            >),\r\n          ])\r\n        ),\r\n        ...getMutationsFromTransactionUpdateOperations(\r\n          sortMutationsByTransactionPosition([\r\n            ...(operations.updateNode as Array<\r\n              UpdateNodeOperation & { position: number }\r\n            >),\r\n            ...(operations.updateNodes as Array<\r\n              UpdateNodesOperation & { position: number }\r\n            >),\r\n          ])\r\n        ),\r\n        ...getMutationsFromTransactionDropOperations([\r\n          ...(operations.dropNode as Array<DropNodeOperation>),\r\n        ]),\r\n        ...getMutationsFromEdgeCreateOperations([\r\n          ...(operations.createEdge as Array<CreateEdgeOperation>),\r\n          ...(operations.createEdges as Array<CreateEdgesOperation>),\r\n        ]),\r\n        ...getMutationsFromEdgeDropOperations([\r\n          ...(operations.dropEdge as Array<DropEdgeOperation>),\r\n          ...(operations.dropEdges as Array<DropEdgesOperation>),\r\n        ]),\r\n        ...getMutationsFromEdgeReplaceOperations([\r\n          ...(operations.replaceEdge as Array<ReplaceEdgeOperation>),\r\n          ...(operations.replaceEdges as Array<ReplaceEdgesOperation>),\r\n        ]),\r\n        ...getMutationsFromEdgeUpdateOperations([\r\n          ...(operations.updateEdge as Array<UpdateEdgeOperation>),\r\n          ...(operations.updateEdges as Array<UpdateEdgesOperation>),\r\n        ]),\r\n      ];\r\n    }\r\n\r\n    const tokenName = opts?.tokenName || DEFAULT_TOKEN_NAME;\r\n    const token = smJSInstance.getToken({ tokenName });\r\n\r\n    /**\r\n     * Group operations by their SM operation name, sorted by position if applicable\r\n     */\r\n    function groupBySMOperationName(operations: TOperationsByType) {\r\n      const result = Object.entries(operations).reduce(\r\n        (acc, [_, operations]) => {\r\n          operations.forEach(\r\n            (operation: TIndexedOperationType | OperationType) => {\r\n              if (acc.hasOwnProperty(operation.smOperationName)) {\r\n                acc[operation.smOperationName] = [\r\n                  ...acc[operation.smOperationName],\r\n                  operation,\r\n                ];\r\n              } else {\r\n                acc[operation.smOperationName] = [operation];\r\n              }\r\n            }\r\n          );\r\n          return acc;\r\n        },\r\n        {} as Record<string, Array<any>>\r\n      );\r\n\r\n      Object.entries(result).forEach(([smOperationName, operations]) => {\r\n        result[smOperationName] = sortBy(\r\n          operations,\r\n          operation => operation.position\r\n        );\r\n      });\r\n\r\n      return result;\r\n    }\r\n\r\n    if (Array.isArray(callback)) {\r\n      return transactionGroup(callback);\r\n    }\r\n\r\n    const result = callback(context);\r\n\r\n    function handleErrorCallbacks(opts: {\r\n      operationsByType: TOperationsByType;\r\n    }) {\r\n      const { operationsByType } = opts;\r\n\r\n      const operationsBySMOperationName = groupBySMOperationName(\r\n        operationsByType\r\n      );\r\n\r\n      Object.entries(operationsBySMOperationName).forEach(\r\n        ([smOperationName, operations]) => {\r\n          operations.forEach(operation => {\r\n            // we only need to gather the data for node create/update operations\r\n            if (\r\n              smOperationName === 'CreateNodes' ||\r\n              smOperationName === 'UpdateNodes'\r\n            ) {\r\n              // for createNodes, execute callback on each individual node rather than top-level operation\r\n              if (operation.hasOwnProperty('nodes')) {\r\n                operation.nodes.forEach((node: any) => {\r\n                  if (node.hasOwnProperty('onFail')) {\r\n                    node.onFail();\r\n                  }\r\n                });\r\n              } else if (operation.hasOwnProperty('onFail')) {\r\n                operation.onFail();\r\n              }\r\n            }\r\n          });\r\n        }\r\n      );\r\n    }\r\n\r\n    function handleSuccessCallbacks(opts: {\r\n      executionResult: TExecutionResult;\r\n      operationsByType: TOperationsByType;\r\n    }) {\r\n      const { executionResult, operationsByType } = opts;\r\n\r\n      const operationsBySMOperationName = groupBySMOperationName(\r\n        operationsByType\r\n      );\r\n\r\n      /**\r\n       * Loop through the operations, map the operation to each result sent back from SM,\r\n       * then pass the result into the callback if it exists\r\n       */\r\n      const executeCallbacksWithData = (executionResult: TExecutionResult) => {\r\n        executionResult.forEach(\r\n          (\r\n            result:\r\n              | {\r\n                  data: Record<string, any>;\r\n                }\r\n              | {\r\n                  data: Record<string, any>;\r\n                }[]\r\n          ) => {\r\n            // if executionResult is 2d array\r\n            if (Array.isArray(result)) {\r\n              executeCallbacksWithData(result);\r\n            } else {\r\n              const resultData = result.data;\r\n\r\n              Object.entries(operationsBySMOperationName).forEach(\r\n                ([smOperationName, operations]) => {\r\n                  if (resultData.hasOwnProperty(smOperationName)) {\r\n                    operations.forEach(operation => {\r\n                      // we only need to gather the data for node create/update operations\r\n                      if (\r\n                        smOperationName === 'CreateNodes' ||\r\n                        smOperationName === 'UpdateNodes'\r\n                      ) {\r\n                        const groupedResult = resultData[smOperationName];\r\n                        // for createNodes, execute callback on each individual node rather than top-level operation\r\n                        if (operation.hasOwnProperty('nodes')) {\r\n                          operation.nodes.forEach((node: any) => {\r\n                            if (node.hasOwnProperty('onSuccess')) {\r\n                              const operationResult =\r\n                                groupedResult[node.position - 1];\r\n\r\n                              node.onSuccess(operationResult);\r\n                            }\r\n                          });\r\n                        } else if (operation.hasOwnProperty('onSuccess')) {\r\n                          const operationResult =\r\n                            groupedResult[operation.position - 1];\r\n                          operation.onSuccess(operationResult);\r\n                        }\r\n                      }\r\n                    });\r\n                  }\r\n                }\r\n              );\r\n            }\r\n          }\r\n        );\r\n      };\r\n\r\n      executeCallbacksWithData(executionResult);\r\n\r\n      /**\r\n       * For all other operations, just invoke the callback with no args.\r\n       * Transactions will guarantee that all operations have succeeded, so this is safe to do\r\n       */\r\n      Object.entries(operationsBySMOperationName).forEach(\r\n        ([smOperationName, operations]) => {\r\n          if (\r\n            smOperationName !== 'CreateNodes' &&\r\n            smOperationName !== 'UpdateNodes'\r\n          ) {\r\n            operations.forEach(operation => {\r\n              if (operation.hasOwnProperty('onSuccess')) {\r\n                operation.onSuccess();\r\n              } else if (operation.hasOwnProperty('edges')) {\r\n                (operation.edges as CreateEdgesOperation['edges']).forEach(\r\n                  edgeOperation => {\r\n                    if (edgeOperation.hasOwnProperty('onSuccess')) {\r\n                      edgeOperation.onSuccess!();\r\n                    }\r\n                  }\r\n                );\r\n              }\r\n            });\r\n          }\r\n        }\r\n      );\r\n    }\r\n\r\n    async function execute() {\r\n      try {\r\n        if (typeof callback === 'function') {\r\n          if (result instanceof Promise) {\r\n            await result;\r\n          }\r\n        }\r\n        const mutations = getAllMutations(operationsByType);\r\n\r\n        const executionResult: TExecutionResult = await smJSInstance.gqlClient.mutate(\r\n          {\r\n            mutations,\r\n            token,\r\n          }\r\n        );\r\n\r\n        if (executionResult) {\r\n          handleSuccessCallbacks({\r\n            executionResult,\r\n            operationsByType,\r\n          });\r\n        }\r\n\r\n        return executionResult;\r\n      } catch (error) {\r\n        handleErrorCallbacks({\r\n          operationsByType,\r\n        });\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return {\r\n      operations: operationsByType,\r\n      execute,\r\n      callbackResult: result,\r\n      token,\r\n    };\r\n\r\n    function transactionGroup(\r\n      transactions: Array<IPendingTransaction>\r\n    ): Omit<IPendingTransaction, 'callbackResult'> {\r\n      const asyncCallbacks = transactions\r\n        .filter(tx => tx.callbackResult instanceof Promise)\r\n        .map(({ callbackResult }) => callbackResult);\r\n\r\n      async function execute() {\r\n        try {\r\n          const allTokensMatch = transactions.every(\r\n            ({ token }) => token === transactions[0].token\r\n          );\r\n\r\n          if (!allTokensMatch) {\r\n            throw new Error(\r\n              'transactionGroup - All grouped transactions must use the same authentication token.'\r\n            );\r\n          }\r\n\r\n          if (asyncCallbacks.length) {\r\n            await Promise.all(asyncCallbacks);\r\n          }\r\n\r\n          const allMutations = transactions.map(({ operations }) => {\r\n            return smJSInstance.gqlClient.mutate({\r\n              mutations: getAllMutations(operations),\r\n              token,\r\n            });\r\n          });\r\n\r\n          const executionResults: Array<TExecutionResult> = await Promise.all(\r\n            allMutations\r\n          );\r\n\r\n          if (executionResults) {\r\n            executionResults.forEach((result, idx) => {\r\n              handleSuccessCallbacks({\r\n                executionResult: result,\r\n                operationsByType: transactions[idx].operations,\r\n              });\r\n            });\r\n          }\r\n\r\n          return executionResults.flat();\r\n        } catch (error) {\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      return {\r\n        operations: operationsByType,\r\n        execute,\r\n        token,\r\n      };\r\n    }\r\n  };\r\n}\r\n","import { DocumentNode, gql } from '@apollo/client/core';\r\n\r\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\r\n\r\nexport type DropNodeOperation = {\r\n  type: 'dropNode';\r\n  smOperationName: 'DropNode';\r\n  id: string;\r\n  name?: string;\r\n  onSuccess?: () => any;\r\n};\r\n\r\nexport function dropNode(\r\n  operation: Omit<DropNodeOperation, 'type' | 'smOperationName'>\r\n): DropNodeOperation {\r\n  return {\r\n    type: 'dropNode',\r\n    smOperationName: 'DropNode',\r\n    ...operation,\r\n  };\r\n}\r\n\r\nexport function getMutationsFromTransactionDropOperations(\r\n  operations: Array<DropNodeOperation>\r\n): Array<DocumentNode> {\r\n  if (!operations.length) return [];\r\n\r\n  const allDropNodeOperations: Array<{\r\n    id: string;\r\n    name?: string;\r\n  }> = operations.map(operation => {\r\n    if (operation.type === 'dropNode') {\r\n      return operation;\r\n    } else {\r\n      throw Error(`Operation not recognized: \"${operation}\"`);\r\n    }\r\n  });\r\n\r\n  return allDropNodeOperations.map(operation => {\r\n    const name = getMutationNameFromOperations([operation], 'DropNode');\r\n\r\n    return gql`\r\n      mutation ${name} {\r\n        DropNode(nodeId: \"${operation.id}\")\r\n      }    \r\n    `;\r\n  });\r\n}\r\n","import { PROPERTIES_QUERIED_FOR_ALL_NODES } from './consts';\r\nimport {\r\n  JSON_TAG,\r\n  NULL_TAG,\r\n  parseJSONFromBE,\r\n  prepareValueForFE,\r\n} from './dataConversions';\r\nimport { SMNotCachedException, SMDataParsingException } from './exceptions';\r\nimport { OBJECT_PROPERTY_SEPARATOR, OBJECT_IDENTIFIER } from './smDataTypes';\r\nimport {\r\n  ISMData,\r\n  SMDataDefaultFn,\r\n  NodeDO,\r\n  ISMNodeRepository,\r\n  DeepPartial,\r\n  GetAllAvailableNodeDataType,\r\n  SM_DATA_TYPES,\r\n} from './types';\r\n\r\n/**\r\n * Returns an initialized instance of a repository for an SMNode\r\n */\r\nexport function RepositoryFactory<\r\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>\r\n>(opts: {\r\n  def: {\r\n    type: string;\r\n    properties: TNodeData;\r\n  };\r\n  DOClass: new (initialData?: Record<string, any>) => NodeDO;\r\n  onDataReceived(opts: {\r\n    data: { id: string } & Record<string, any>;\r\n    applyUpdateToDO: () => void;\r\n  }): void;\r\n  onDOConstructed?(DO: NodeDO): void;\r\n  onDODeleted?(DO: NodeDO): void;\r\n}): ISMNodeRepository {\r\n  // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\r\n  // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\r\n  // eslint-disable-next-line\r\n  // @ts-ignore\r\n  class Repository implements ISMNodeRepository {\r\n    private cached: Record<string, NodeDO> = {};\r\n\r\n    public onDataReceived(\r\n      data: { id: string; type: string } & Record<string, any>\r\n    ) {\r\n      if (opts.def.type !== data.type) {\r\n        throw Error(\r\n          `Attempted to query a node with an id belonging to a different type - Expected: ${opts.def.type} Received: ${data.type}`\r\n        );\r\n      }\r\n      const cached = this.cached[data.id];\r\n\r\n      const parsedData = this.parseDataFromSM<TNodeData>(data);\r\n\r\n      if (!cached) {\r\n        const newDO = new opts.DOClass(parsedData);\r\n        this.cached[data.id] = newDO;\r\n        opts.onDOConstructed && opts.onDOConstructed(newDO);\r\n      }\r\n\r\n      // applyUpdateToDO is called conditionally by OptimisticUpdatesOrchestrator\r\n      // see comments in that class to understand why\r\n      opts.onDataReceived({\r\n        data: parsedData,\r\n        applyUpdateToDO: () => {\r\n          // if there was no cached node it was already initialized with this data\r\n          // calling onDataReceived again would be wasted CPU cycles\r\n          cached && cached.onDataReceived(parsedData);\r\n        },\r\n      });\r\n    }\r\n\r\n    public byId(id: string) {\r\n      const cached = this.cached[id];\r\n\r\n      if (!cached) {\r\n        throw new SMNotCachedException({\r\n          nodeType: opts.def.type,\r\n          id,\r\n        });\r\n      }\r\n\r\n      return cached;\r\n    }\r\n\r\n    public onNodeDeleted(id: string) {\r\n      if (this.cached[id]) {\r\n        if (opts.onDODeleted) {\r\n          opts.onDODeleted(this.cached[id]);\r\n        }\r\n        delete this.cached[id];\r\n      }\r\n    }\r\n    /**\r\n     * This method takes data that comes in from SM and is about to be applied to this DO's instance. It needs to:\r\n     * 1) ignore data not specified in the smNode definition for this node\r\n     *     this is so that the querier in smDataContext can call onDataReceived on the DO with the data it receives from SM without having to ignore the relational aliases there\r\n     *     without doing this, we'd get errors about attempting to set a property on a DO which is read only\r\n     * 2) take objects spread into root properties and convert them to regular objects\r\n     *     for example, if we are trying to store `settings: { show: true }` in SM, what is actually stored in the DB is\r\n     *     settings__dot__show: 'true'\r\n     *     since all data must be a string (we don't need to worry about coercing strings to booleans or numbers though, that's handled by the smDataTypes)\r\n     */\r\n    private parseDataFromSM<\r\n      TNodeData extends Record<string, ISMData | SMDataDefaultFn>\r\n    >(\r\n      receivedData: any\r\n    ): { id: string; version: number } & DeepPartial<\r\n      GetAllAvailableNodeDataType<TNodeData, {}>\r\n    > {\r\n      const oldStyleObjects: Record<string, any> = {};\r\n      return Object.keys(receivedData).reduce((parsed, key: string) => {\r\n        const isDataStoredOnAllNodes = PROPERTIES_QUERIED_FOR_ALL_NODES.includes(\r\n          key\r\n        );\r\n        if (isDataStoredOnAllNodes) {\r\n          return {\r\n            ...parsed,\r\n            [key]: receivedData[key],\r\n          };\r\n        }\r\n\r\n        // point 1) above\r\n        const isDataStoredOnTheNode = key.includes(OBJECT_PROPERTY_SEPARATOR)\r\n          ? Object.keys(opts.def.properties).includes(\r\n              key.split(OBJECT_PROPERTY_SEPARATOR)[0]\r\n            )\r\n          : Object.keys(opts.def.properties).includes(key);\r\n\r\n        if (!isDataStoredOnTheNode) return parsed;\r\n\r\n        const type = (opts.def.properties[key] as ISMData)?.type;\r\n        const isObjectData =\r\n          key.includes(OBJECT_PROPERTY_SEPARATOR) ||\r\n          type === SM_DATA_TYPES.object ||\r\n          type === SM_DATA_TYPES.maybeObject;\r\n\r\n        const isRecordData =\r\n          type === SM_DATA_TYPES.record || type === SM_DATA_TYPES.maybeRecord;\r\n\r\n        const isArrayData = (() => {\r\n          if (isObjectData) {\r\n            return false;\r\n          }\r\n\r\n          const receivedDataValue = opts.def.properties[key];\r\n\r\n          const smDataType =\r\n            typeof receivedDataValue === 'function'\r\n              ? ((receivedDataValue as any)._default as ISMData).type\r\n              : receivedDataValue.type;\r\n\r\n          return (\r\n            smDataType === SM_DATA_TYPES.array ||\r\n            smDataType === SM_DATA_TYPES.maybeArray\r\n          );\r\n        })();\r\n\r\n        // point 2 above\r\n        if (isObjectData) {\r\n          const [root, ...nests] = key.split(OBJECT_PROPERTY_SEPARATOR);\r\n\r\n          // it it was set to __NULL__ it means this\r\n          // node is using the old style of storing nested objects\r\n          if (receivedData[root] === NULL_TAG || receivedData[root] === null) {\r\n            parsed[root as keyof TNodeData] = null as any;\r\n            return parsed;\r\n          } else if (\r\n            typeof receivedData[root] === 'string' &&\r\n            receivedData[root].startsWith(JSON_TAG)\r\n          ) {\r\n            // https://tractiontools.atlassian.net/browse/TT-2905\r\n            // will ensure this would've been set to null if this object was updated\r\n            //\r\n            // this means 3 things\r\n            // 1 we can acquire all the data for this object from this one property\r\n            // 2 we have to ignore the \"null\" values coming in when we're querying for the new style propeties (root_nestedProperty)\r\n            // 3 we have to ensure we only return from this object data that was queried\r\n            //   otherwise we risk hitting the DO class with data that is not documented in the node definition, leading to errors\r\n            try {\r\n              oldStyleObjects[root] =\r\n                oldStyleObjects[root] || parseJSONFromBE(receivedData[root]);\r\n            } catch (e) {\r\n              throw new SMDataParsingException({\r\n                receivedData,\r\n                message: `Could not parse json stored in old format for an object in the key \"${key}\"`,\r\n              });\r\n            }\r\n          }\r\n\r\n          if (oldStyleObjects[root]) {\r\n            parsed[root as keyof TNodeData] =\r\n              parsed[root] ||\r\n              (this.getOnlyQueriedData({\r\n                allDataReceived: receivedData,\r\n                dataPreviouslyParsedForThisObject: oldStyleObjects[root],\r\n                rootProp: root,\r\n              }) as any);\r\n\r\n            return parsed;\r\n          }\r\n\r\n          if (parsed[root] == null) {\r\n            parsed[root as keyof TNodeData] = {} as any;\r\n          }\r\n\r\n          this.nest({\r\n            nests,\r\n            root: parsed[root] as Record<string, any>,\r\n            val:\r\n              receivedData[key] === OBJECT_IDENTIFIER ? {} : receivedData[key],\r\n          });\r\n\r\n          return parsed;\r\n        } else if (isRecordData) {\r\n          if (\r\n            typeof receivedData[key] === 'string' &&\r\n            receivedData[key].startsWith(JSON_TAG)\r\n          ) {\r\n            parsed[key as keyof TNodeData] = parseJSONFromBE(receivedData[key]);\r\n          } else if (receivedData[key] == null) {\r\n            parsed[key as keyof TNodeData] = null as any;\r\n          } else {\r\n            throw new SMDataParsingException({\r\n              receivedData,\r\n              message: `Could not parse json stored in old format for a record in the key \"${key}\"`,\r\n            });\r\n          }\r\n\r\n          return parsed;\r\n        } else if (isArrayData) {\r\n          parsed[key as keyof TNodeData] = prepareValueForFE(receivedData[key]);\r\n          return parsed;\r\n        } else {\r\n          parsed[key as keyof TNodeData] = receivedData[key];\r\n          return parsed;\r\n        }\r\n      }, {} as { id: string; version: number } & DeepPartial<GetAllAvailableNodeDataType<TNodeData, {}>>);\r\n    }\r\n\r\n    private getOnlyQueriedData(opts: {\r\n      allDataReceived: Record<string, any>;\r\n      dataPreviouslyParsedForThisObject: Record<string, any>;\r\n      rootProp: string;\r\n    }) {\r\n      const newStylePropertiesQueriedForThisObject = Object.keys(\r\n        opts.allDataReceived\r\n      ).filter(key =>\r\n        key.startsWith(`${opts.rootProp}${OBJECT_PROPERTY_SEPARATOR}`)\r\n      );\r\n\r\n      return newStylePropertiesQueriedForThisObject.reduce((acc, prop) => {\r\n        const [root, ...nests] = prop.split(OBJECT_PROPERTY_SEPARATOR);\r\n        this.nest({\r\n          nests,\r\n          root: acc,\r\n          val: this.getDataForProp({\r\n            prop,\r\n            object: { [root]: opts.dataPreviouslyParsedForThisObject },\r\n          }),\r\n        });\r\n\r\n        return acc;\r\n      }, {} as Record<string, any>);\r\n    }\r\n\r\n    // with a \"prop\" in the format root__dot__nestedKey__dot__evenMoreNestedKey\r\n    // returns the correct value from an \"object\" of previously parsed data { root: { nestedKey: { evenMoreNestedKey: true } } }\r\n    private getDataForProp(opts: {\r\n      object: Record<string, any>;\r\n      prop: string;\r\n    }): any {\r\n      if (opts.object == null) {\r\n        return undefined; // the prop is not set on the object at all\r\n      }\r\n\r\n      if (opts.prop.includes(OBJECT_PROPERTY_SEPARATOR)) {\r\n        const [root, ...rest] = opts.prop.split(OBJECT_PROPERTY_SEPARATOR);\r\n        return this.getDataForProp({\r\n          object: opts.object[root],\r\n          prop: rest.join(OBJECT_PROPERTY_SEPARATOR),\r\n        });\r\n      }\r\n\r\n      return opts.object[opts.prop];\r\n    }\r\n\r\n    private nest(opts: {\r\n      nests: Array<string>;\r\n      root: Record<string, any>;\r\n      val: any;\r\n    }) {\r\n      const parsedVal = opts.val === NULL_TAG ? null : opts.val;\r\n\r\n      if (opts.nests.length === 0) {\r\n        opts.root = parsedVal;\r\n      } else if (opts.nests.length === 1) {\r\n        const nextNest = opts.nests[0];\r\n        opts.root[nextNest] = parsedVal;\r\n      } else {\r\n        const [nextNest, ...remainingNests] = opts.nests;\r\n\r\n        if (opts.root[nextNest] == null) {\r\n          opts.root[nextNest] = null;\r\n        } else {\r\n          this.nest({\r\n            nests: remainingNests,\r\n            root: opts.root[nextNest],\r\n            val: parsedVal,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line\r\n  // @ts-ignore\r\n  return new Repository();\r\n}\r\n","import { getGQLCLient } from './gqlClient';\r\nimport { SMConfig } from './types';\r\n\r\nexport function getDefaultConfig(): SMConfig {\r\n  return {\r\n    gqlClient: getGQLCLient({\r\n      httpUrl: 'https://saasmaster.dev02.tt-devs.com/playground/..',\r\n      wsUrl: 'wss://saasmaster.dev02.tt-devs.com/',\r\n    }),\r\n  };\r\n}\r\n"],"names":["PROPERTIES_QUERIED_FOR_ALL_NODES","parseJSONFromBE","jsonString","startsWith","Error","JSON_TAG","JSON","parse","replace","SM_DATA_TYPES","SM_RELATIONAL_TYPES","SMNotUpToDateException","opts","propName","nodeType","queryId","SMNotUpToDateInComputedException","_Error2","computedPropName","SMNotCachedException","_Error3","id","SMDataTypeException","_Error4","dataType","value","SMDataTypeExplicitDefaultException","_Error5","SMDataParsingException","_Error6","message","stringify","receivedData","SMUnexpectedSubscriptionMessageException","exception","SMData","type","parser","boxedValue","defaultValue","isOptional","string","String","_default","optional","maybeString","number","parsed","Number","isNaN","error","process","env","NODE_ENV","console","throwLocallyLogInProd","maybeNumber","boolean","undefined","maybeBoolean","object","val","maybeObject","record","maybeRecord","OptimisticUpdatesOrchestrator","DOsById","lastKnownPersistedDataById","inFlightRequestsById","onDOConstructed","DO","_this","onDODeleted","onPersistedDataReceived","nodeId","data","applyUpdateToDO","onUpdateRequested","update","getDOById","onUpdateSuccessful","onUpdateFailed","rollbackState","deepClone","obj","Array","isArray","outputArray","forEach","item","push","outputObject","key","persistedData","version","lastUpdatedBy","updateIdx","length","currentVersion","onDataReceived","payload","handleUpdateFailed","handleUpdateSuccessful","inFlightRequestsForThisNode","this","__unsafeIgnoreVersion","splice","cleanupIfNoInFlightRequests","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","tryCatch","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","convertNodeDataToSMPersistedData","nodeData","parsedData","entries","reduce","acc","childNodes","map","additionalEdges","edgeItem","to","targetId","sourceId","from","convertEdgeDirectionNames","skipBooleanStringWrapping","escapeText","prepareObjectForBE","convertPropertyToBE","join","text","preparedKey","parentKey","omitObjectIdentifier","getMapFnReturn","relationaFns","mapFnOpts","properties","relational","mapFn","getQueriedProperties","mapFnReturn","smData","smRelational","isRootLevel","includes","nestedKey","getAllNodeProperties","nodeProperties","getIdsString","ids","getSubscriptionGetNodeOptions","options","def","under","getSpaces","numberOfSpaces","fill","getQueryPropertiesString","propsString","nestLevel","queryRecordEntry","relationalQueryRecord","alias","operation","relationalQueryRecordEntry","idProp","depth","getRelationalQueryString","convertQueryDefinitionToQueryInfo","queryRecord","queryDefinitions","queryDefinitionsAlias","queriedProps","nodeDef","queryDefinition","_isSMNodeDef","smComputed","getRelationalQueries","relationalQueries","addRelationalQueryRecord","relationalQueriesWithinThisRelationalQuery","relationalType","_smRelational","byReference","relationalQuery","children","queryBuilderOpts","unionType","target","some","underIds","filter","getQueryRecordFromQueryDefinition","queryGQLString","getSanitizedQueryId","convertedToDotFormat","idx","getGetNodeOptions","getRootLevelQueryString","trim","subscriptionConfigs","subscriptionConfigsAcc","subscriptionName","extractNodeFromSubscriptionMessage","subscriptionMessage","node","description","extractOperationFromSubscriptionMessage","underId","gqlString","getQueryInfo","queryGQL","gql","subscriptionConfig","queryIdx","splitQueryDefinitionsByToken","split","tokenName","generateQuerier","smJSInstance","queryManager","getError","getToken","performQueries","all","queryDefinitionsSplitByToken","gqlClient","query","token","batched","resultsForToken","stack","startStack","substring","indexOf","results","qM","SMQueryManager","onQueryResult","queryResult","_context2","onError","getResults","getMutationNameFromOperations","operations","fallback","operationNames","getEdgePermissionsString","permissions","view","edit","manage","terminate","addChild","convertEdgeCreationOperationToMutationArguments","edge","convertEdgeDropOperationToMutationArguments","convertEdgeReplaceOperationToMutationArguments","current","convertEdgeUpdateOperationToMutationArguments","convertCreateNodeOperationToCreateNodesMutationArguments","mutationArgs","SMContext","React","createContext","subscriptionIds","suspendEnabled","suspendDisabled","getGQLCLient","gqlClientOpts","wsLink","WebSocketLink","uri","wsUrl","reconnect","nonBatchedLink","HttpLink","httpUrl","queryBatchLink","getContext","batchedQuery","BatchHttpLink","batchMax","batchInterval","mutationBatchLink","batchedMutation","MAX_SAFE_INTEGER","requestLink","definition","getMainDefinition","kind","getContextWithToken","headers","Authorization","authenticateSubscriptionDocument","documentBody","_opts$gql$loc","source","body","operationsThatRequireToken","documentBodyWithAuthTokensInjected","RegExp","authLink","ApolloLink","forward","Observable","observer","subscribe","bind","unsubscribe","baseClient","ApolloClient","link","cache","InMemoryCache","defaultOptions","watchQuery","fetchPolicy","errorPolicy","subscription","onMessage","mutate","mutations","mutation","convertUpdateNodeOperationToUpdateNodesMutationArguments","require","SMJS","config","plugins","transaction","tokens","DOFactory","DOProxyGenerator","optimisticUpdatesOrchestrator","updateQueryManagerWithSubscriptionMessage","initSubs","unsub","subscriptionCancellers","cancel","mustAwaitQuery","messageQueue","onData","e","onSubscriptionMessage","subscriptionAlias","onQueryInfoConstructed","skipInitialQuery","onSubscriptionInitialized","_context3","relationalResults","nodeSMComputed","computedAccessors","computedKey","computedFn","proxy","plugin","DOProxy","_plugin$DOProxy","computedDecorator","ProxyInstance","Proxy","getOwnPropertyDescriptor","allPropertiesQueried","get","newRelationalResults","smDataForThisProp","getNestedObjectWithNotUpToDateProtection","objectToReturn","smDataForThisObject","objectProp","parentObjectKey","isUpToDate","prop","allCachedData","createDOProxyGenerator","initialData","_defaults","getDefaultData","nodePropertiesOrSMData","isObjectType","getDefaultFnValue","defaultSMData","defaultFn","isArrayType","propValue","isRecordType","newVersion","newData","parseReceivedData","extendPersistedWithNewlyReceivedData","extension","getParsedData","defaultData","setObjectProp","propNameForThisObject","setPrimitiveValueProp","setArrayProp","_plugin$DO","onConstruct","DOInstance","parsedDataKey","initializeNodePropGetters","initializeNodeComputedGetters","initializeNodeRelationalGetters","initializeNodeMutations","property","_this2","getSMData","propExistsInInitialData","_this3","array","_opts$defaultData2","_this4","_this5","computedData","computed","computedProp","_this6","setComputedProp","relationalData","relationalProp","_this7","setRelationalProp","relationalQueryGetter","mutationName","_this8","computedGetter","_this9","_plugin$DO2","maybeArray","createDOFactory","notifyRepositories","getNewStateFromQueryResult","queryRecordEntryForThisSubscription","action","path","updateProxiesAndStateFromSubscriptionMessage","idsOrIdInCurrentResult","getResultsFromState","resultsAcc","queryAlias","stateForThisAlias","idsOrId","removeUnionSuffix","proxyCache","dataForThisAlias","nodeRepository","repository","relationalAlias","flatMap","dataEntry","relationalDataEntry","resultingStateAcc","cacheEntry","buildCacheEntry","buildProxyCacheEntryForNode","relationalState","relationalStateAcc","relationalDataForThisAlias","buildRelationalStateForNode","getApplicableRelationalQueries","byId","proxyCacheAcc","newCacheEntry","recursivelyUpdateProxyAndReturnNewCacheEntry","newRelationalData","getRelationalData","currentState","currentRelationalState","newRelationalState","queryRecordForThisAlias","currentStateForThisAlias","existingProxy","_currentStateForThisA","updateRelationalResults","relationalDataAcc","relationalQueryAlias","firstResult","createSMQueryManager","globalOperationHandlers","callback","operationsByType","createNode","createNodes","updateNode","updateNodes","dropNode","createEdge","createEdges","dropEdge","dropEdges","replaceEdge","replaceEdges","updateEdge","updateEdges","createOperationsCount","updateOperationsCount","pushOperation","position","nodes","smOperationName","onSuccess","onFail","globalHandlers","nodeIdx","edges","sortMutationsByTransactionPosition","sortBy","getAllMutations","allCreateNodeOperations","getMutationsFromTransactionCreateOperations","allUpdateNodeOperations","dropPropertiesMutations","updateNodeOperation","propertiesToNull","getPropertiesToNull","concat","getMutationsFromTransactionUpdateOperations","getMutationsFromTransactionDropOperations","getMutationsFromEdgeCreateOperations","getMutationsFromEdgeDropOperations","getMutationsFromEdgeReplaceOperations","getMutationsFromEdgeUpdateOperations","groupBySMOperationName","transactions","asyncCallbacks","tx","callbackResult","every","allMutations","executionResults","handleSuccessCallbacks","executionResult","flat","execute","transactionGroup","handleErrorCallbacks","operationsBySMOperationName","executeCallbacksWithData","resultData","groupedResult","edgeOperation","createTransaction","DOClass","cached","parseDataFromSM","newDO","onNodeDeleted","oldStyleObjects","_opts$def$properties$","isObjectData","isRecordData","isArrayData","receivedDataValue","smDataType","root","nests","getOnlyQueriedData","allDataReceived","dataPreviouslyParsedForThisObject","rootProp","nest","prepareValueForFE","beData","prepared","getDataForProp","rest","parsedVal","nextNest","remainingNests","smMutations","setToken","clearTokens","props","useContext","ongoingSubscriptionRecord","useRef","cleanupTimeoutRecord","updateSubscriptionInfo","useCallback","subscriptionId","subInfo","scheduleCleanup","cleanup","existingContextSubscription","subscriptionTTLMs","setTimeout","cancelCleanup","clearTimeout","Provider","smJS","parsedBoxedValue","smArray","replaceAll","useSubscription","smContext","captureStackTrace","preExistingState","preExistingContextForThisSubscription","querying","getPreexistingState","useState","setResults","setError","setQuerying","qdStateManager","qdError","parentSubscriptionId","onResults","handlers","useSubOpts","doNotSuspend","splitQueryDefinitions","allSubscriptionIds","getAllSubscriptionStates","handleNewQueryDefitions","subOpts","newQueryInfo","suspend","subscriptionSuffix","queryInfo","queryDefinitionHasBeenUpdated","suspendPromise","queryTimestamp","Date","valueOf","lastQueryTimestamp","log","newResults","contextForThisParentSub","subscriptionCanceller","subscriptionState","contextForThisSub","buildQueryDefinitionStateManager","useEffect"],"mappings":"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"}