{"version":3,"file":"sm-js.cjs.development.js","sources":["../src/exceptions.ts","../src/smDataTypes.ts","../src/DO.ts","../src/DOProxyGenerator.ts","../src/dataConversions.ts","../src/queryDefinitionAdapters.ts","../src/Repository.ts","../node_modules/regenerator-runtime/runtime.js","../src/smQueriers.ts","../src/SMQueryManager.ts","../src/transaction/getMutationNameFromOperations.ts","../src/transaction/edges/utilities.ts","../src/transaction/edges/create.ts","../src/transaction/edges/drop.ts","../src/transaction/edges/replace.ts","../src/transaction/edges/update.ts","../src/transaction/convertNodeDataToSMPersistedData.ts","../src/transaction/create.ts","../src/transaction/update.ts","../src/transaction/drop.ts","../src/transaction/transaction.ts","../src/react/context.tsx","../src/react/useSMSubscription.tsx","../src/gqlClient.ts","../src/config.ts","../src/index.ts"],"sourcesContent":["// thrown when any property on the DO is accessed but is not marked as upToDate\n// by calling DO.setUpToDateData({ [propName]: true })\n// or DO.setUpToDateData({ nested: { [propName]: true } })\n// this is done automatically by smData fetchers, smQuery and smSubscribe\n// so this error should only occur when data is accessed but was never queried or is not currently being subscribed to (is cached only)\nexport class SMNotUpToDateException extends Error {\n  public propName: string;\n\n  constructor(opts: { propName: string; nodeType: string; queryId: string }) {\n    super(\n      `SMNotUpToDate exception - The property \"${opts.propName}\" on the DO for the node type ${opts.nodeType} was read but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\n    );\n    this.propName = opts.propName;\n  }\n}\n\nexport class SMNotUpToDateInComputedException extends Error {\n  constructor(opts: {\n    computedPropName: string;\n    propName: string;\n    nodeType: string;\n    queryId: string;\n  }) {\n    super(\n      `SMNotUpToDateInComputed exception - The property \"${opts.propName}\" on the DO for the node type \"${opts.nodeType}\" was read for the computed property \"${opts.computedPropName}\" but is not guaranteed to be up to date. Add that property to the query with the id ${opts.queryId}`\n    );\n  }\n}\n\nexport class SMNotCachedException extends Error {\n  constructor(opts: { nodeType: string; id: string }) {\n    super(\n      `SMNotCached exception - Attempted to get the node with the type \"${opts.nodeType}\" and id \"${opts.id}\" but it was not cached.`\n    );\n  }\n}\n\nexport class SMDataTypeException extends Error {\n  constructor(opts: { dataType: string; value: any }) {\n    super(\n      `SMDataType exception - the data type ${opts.dataType} received a bad value. Value: \"${opts.value}\"`\n    );\n  }\n}\n\nexport class SMDataTypeExplicitDefaultException extends Error {\n  constructor(opts: { dataType: string }) {\n    super(\n      `SMDataTypeExplicitDefaultException - the data type ${opts.dataType} requires setting an explicit default value for non-optional properties`\n    );\n  }\n}\n\nexport class SMDataParsingException extends Error {\n  constructor(opts: { receivedData: any; message: string }) {\n    super(\n      `SMDataParsing exception - ${opts.message}\\nData: ${JSON.stringify(\n        opts.receivedData,\n        null,\n        2\n      )}.`\n    );\n  }\n}\n\nexport class SMUnexpectedSubscriptionMessageException extends Error {\n  public exception: {\n    subscriptionMessage: Record<string, any>;\n    description: string;\n  };\n\n  constructor(exception: {\n    subscriptionMessage: Record<string, any>;\n    description: string;\n  }) {\n    super(\n      `SMUnexpectedSubscriptionMessage exception - unexpected subscription message received`\n    );\n    this.exception = exception;\n  }\n}\n\nexport class SMUnexpectedQueryResultException extends Error {\n  public exception: {\n    queryRecord: Record<string, any>;\n    resultData: Record<string, any>;\n  };\n\n  constructor(exception: {\n    queryRecord: Record<string, any>;\n    resultData: Record<string, any>;\n  }) {\n    super(\n      `SMUnexpectedQueryResult exception - unexpected query result received`\n    );\n    this.exception = exception;\n  }\n}\n\nexport function throwLocallyLogInProd(error: Error) {\n  if (process?.env?.NODE_ENV !== 'production') {\n    throw error;\n  } else {\n    console.error(error);\n  }\n}\n","import {\n  SMDataTypeException,\n  SMDataTypeExplicitDefaultException,\n  throwLocallyLogInProd,\n} from './exceptions';\nimport {\n  GetExpectedNodeDataType,\n  GetSMDataType,\n  IByReferenceQueryBuilder,\n  IChildrenQueryBuilder,\n  ISMData,\n  ISMNode,\n  ISMQueryPagination,\n  MapFnForNode,\n  Maybe,\n  QueryDefinition,\n  SMDataDefaultFn,\n} from './types';\n\nexport const SM_DATA_TYPES = {\n  string: 's',\n  maybeString: 'mS',\n  number: 'n',\n  maybeNumber: 'mN',\n  boolean: 'b',\n  maybeBoolean: 'mB',\n  object: 'o',\n  maybeObject: 'mO',\n  record: 'r',\n  maybeRecord: 'mR',\n  array: 'a',\n  maybeArray: 'mA',\n};\n\nexport class SMData<\n  TParsedValue,\n  TSMValue,\n  TBoxedValue extends\n    | ISMData\n    | Record<string, ISMData | SMDataDefaultFn>\n    | undefined\n> implements ISMData<TParsedValue, TSMValue, TBoxedValue> {\n  type: typeof SM_DATA_TYPES[keyof typeof SM_DATA_TYPES];\n  parser: (smValue: TSMValue) => TParsedValue;\n  boxedValue: TBoxedValue;\n  defaultValue: Maybe<TParsedValue>;\n  isOptional: boolean;\n\n  constructor(opts: {\n    type: string;\n    parser: (smValue: TSMValue) => TParsedValue;\n    boxedValue?: TBoxedValue;\n    defaultValue?: TParsedValue;\n    isOptional: boolean;\n  }) {\n    this.type = opts.type;\n    this.parser = opts.parser;\n    this.boxedValue = opts.boxedValue as TBoxedValue;\n    this.defaultValue = opts.defaultValue ?? null;\n    this.isOptional = opts.isOptional;\n  }\n}\n\n/**\n * smData serve 2 purposes:\n * 1) they convert strings from SM into their real types (objects, strings, numbers, booleans)\n * 2) they serve as a way for TS to infer the data type of the node based on the smData types used,\n */\n\nexport const string = (defaultValue: string) =>\n  new SMData<string, string, undefined>({\n    type: SM_DATA_TYPES.string,\n    parser: value => (value != null ? String(value) : value),\n    defaultValue,\n    isOptional: false,\n  });\n\nstring._default = string('');\n\nstring.optional = new SMData<Maybe<string>, Maybe<string>, undefined>({\n  type: SM_DATA_TYPES.maybeString,\n  parser: value => (value != null ? String(value) : value),\n  isOptional: true,\n});\n\nexport const number = (\n  defaultValue: number\n): SMData<number, string, undefined> =>\n  new SMData<number, string, undefined>({\n    type: SM_DATA_TYPES.number,\n    parser: value => {\n      const parsed = Number(value);\n\n      if (isNaN(parsed)) {\n        throwLocallyLogInProd(\n          new SMDataTypeException({\n            dataType: SM_DATA_TYPES.number,\n            value,\n          })\n        );\n        return number._default.defaultValue as number;\n      }\n\n      return parsed;\n    },\n    defaultValue,\n    isOptional: false,\n  }) as SMData<number, string, undefined>;\n\nnumber._default = number(0);\n\nnumber.optional = new SMData<Maybe<number>, Maybe<string>, undefined>({\n  type: SM_DATA_TYPES.maybeNumber,\n  parser: value => {\n    if (value != null) {\n      return Number(value);\n    }\n    return value;\n  },\n  isOptional: true,\n});\n\nexport const boolean = <TDefaultValue extends boolean>(\n  defaultValue?: TDefaultValue\n) => {\n  if (defaultValue === undefined) {\n    return (new SMDataTypeExplicitDefaultException({\n      dataType: SM_DATA_TYPES.boolean,\n    }) as unknown) as ISMData<boolean, string | boolean, undefined>;\n  }\n\n  return new SMData<boolean, string | boolean, undefined>({\n    type: SM_DATA_TYPES.boolean,\n    parser: value => {\n      if (value === 'true' || value === true) {\n        return true;\n      } else if (value === 'false' || value === false) {\n        return false;\n      } else {\n        throw new SMDataTypeException({\n          dataType: SM_DATA_TYPES.boolean,\n          value: value,\n        });\n      }\n    },\n    defaultValue,\n    isOptional: false,\n  }) as TDefaultValue extends undefined\n    ? Error\n    : ISMData<boolean, string | boolean, undefined>;\n};\n// need this in order to trigger an error when a user doesn't provide a default\n//@ts-ignore\nboolean._default = boolean();\n\nboolean.optional = new SMData<\n  Maybe<boolean>,\n  Maybe<string | boolean>,\n  undefined\n>({\n  type: SM_DATA_TYPES.maybeBoolean,\n  parser: value => {\n    if (value == null) return value;\n\n    if (value === 'true' || value === true) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  isOptional: true,\n});\n\nexport const object = <\n  TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\n>(\n  boxedValue: TBoxedValue\n) =>\n  new SMData<\n    GetExpectedNodeDataType<TBoxedValue>,\n    GetExpectedNodeDataType<TBoxedValue>,\n    TBoxedValue\n  >({\n    type: SM_DATA_TYPES.object,\n    /**\n     * Doesn't need to do any parsing on the data to convert strings to their real types\n     * That's done by the DO class's \"objectDataSetter\" method\n     */\n    parser: val => val,\n    boxedValue,\n    isOptional: false,\n  });\n\nobject._default = null as any;\n\nobject.optional = <\n  TBoxedValue extends Record<string, ISMData | SMDataDefaultFn>\n>(\n  boxedValue: TBoxedValue\n) =>\n  new SMData<\n    Maybe<GetExpectedNodeDataType<TBoxedValue>>,\n    Maybe<GetExpectedNodeDataType<TBoxedValue>>,\n    TBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeObject,\n    /**\n     * Doesn't need to do any parsing on the data to convert strings to their real types\n     * That's done by the DO class's \"objectDataSetter\" method\n     */\n    parser: val => val,\n    boxedValue,\n    isOptional: true,\n  });\n\nexport const record = <\n  TKey extends string,\n  TBoxedValue extends ISMData | SMDataDefaultFn\n>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  return new SMData<\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\n    Record<TKey, GetSMDataType<typeof parsedBoxedValue>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.record,\n    parser: val => val,\n    boxedValue: boxedValue as typeof parsedBoxedValue,\n    isOptional: false,\n    defaultValue: {} as Record<string, any>,\n  });\n};\n\nrecord.optional = <TBoxedValue extends ISMData | SMDataDefaultFn>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  return new SMData<\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\n    Maybe<Record<string, GetSMDataType<typeof parsedBoxedValue>>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeRecord,\n    parser: val => val,\n    boxedValue: parsedBoxedValue,\n    isOptional: true,\n    defaultValue: null,\n  });\n};\n\nrecord._default = null as any;\n\nexport const array = <TBoxedValue extends ISMData | SMDataDefaultFn>(\n  boxedValue: TBoxedValue\n) => {\n  const parsedBoxedValue: ISMData =\n    // will be a function if no explicit default set\n    typeof boxedValue === 'function'\n      ? ((boxedValue as any)._default as ISMData)\n      : (boxedValue as ISMData);\n\n  function smArray(\n    defaultValue: Array<GetSMDataType<typeof parsedBoxedValue>>\n  ) {\n    return new SMData<\n      Array<GetSMDataType<typeof parsedBoxedValue>>,\n      Array<GetSMDataType<typeof parsedBoxedValue>>,\n      typeof parsedBoxedValue\n    >({\n      type: SM_DATA_TYPES.array,\n      parser: value => value,\n      boxedValue: parsedBoxedValue,\n      defaultValue,\n      isOptional: false,\n    });\n  }\n\n  smArray.optional = new SMData<\n    Maybe<Array<GetSMDataType<typeof parsedBoxedValue>>>,\n    Maybe<Array<GetSMDataType<typeof parsedBoxedValue>>>,\n    typeof parsedBoxedValue\n  >({\n    type: SM_DATA_TYPES.maybeArray,\n    parser: value => value,\n    boxedValue: parsedBoxedValue,\n    isOptional: true,\n  });\n\n  smArray._default = smArray([]);\n\n  return smArray;\n};\n\nexport const SM_RELATIONAL_TYPES = {\n  byReference: 'bR' as 'bR',\n  children: 'bP' as 'bP',\n};\n\nexport const reference = <\n  TParentHoldingReference extends ISMNode,\n  TReferencedNode extends ISMNode = ISMNode\n>(opts: {\n  def: TReferencedNode;\n  idProp: keyof TParentHoldingReference['smData'];\n}) => {\n  return ((queryBuilderOpts: { map: MapFnForNode<TReferencedNode> }) => {\n    return {\n      ...opts,\n      _smRelational: SM_RELATIONAL_TYPES.byReference,\n      map: queryBuilderOpts.map,\n    };\n  }) as IByReferenceQueryBuilder<TReferencedNode>;\n};\n\nexport const children = <TSMNode extends ISMNode>(opts: {\n  def: TSMNode;\n  depth?: number;\n}) => {\n  return ((queryBuilderOpts: {\n    map: MapFnForNode<TSMNode>;\n    pagination: ISMQueryPagination;\n  }) => {\n    return {\n      ...opts,\n      _smRelational: SM_RELATIONAL_TYPES.children,\n      map: queryBuilderOpts.map,\n      depth: opts.depth,\n    };\n  }) as IChildrenQueryBuilder<TSMNode>;\n};\n\nexport const OBJECT_PROPERTY_SEPARATOR = '__dot__';\n\nexport const OBJECT_IDENTIFIER = '__object__';\n\n// HACK ALERT! Exists only to make TS work the way we need it\n// It makes it possible to accept multiple node types within a record of query definitions, without losing type safety\n// See this for a simplified example https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBBwYHMA8ARAhlXAFQE8AHAUwD4AKFMNdALkQHkBbGKTASQGUYw6ADbkAwqgw58RMlQA0iAOQB9ZTADOJCr1zByAVXXlCACzET0AMXDR4YAIT3FlAJTM+A4efqS8BLVSIAN4AUIiIAE7kUCARSEEAdEl0DHIqapqyOnqGxmbiPlY2sAiOisxQESDkiAC+IfUhAlDkEcC4EDXchHAAJnB+uMFhiDC9zOqVniME6gDWE1OCDSEhdJOIUH0D0u49-YOIALzBo+NKAIwATADMigqzC0r9m2aIveTkvYp1q1CyiAAitUIsRLGApP5ZJRjohqL1dohBgEXMcYQAFXARWC4ISQmQUSirZqtdqdRAeQQiAoMfEBGGhcLhdIaALZAxGUzeBjWSAlBxOCpVchyEbhBEEZjI2SipmIACOIOIzGBrTBEOlhJWTTALTaHS6AFkQEJYDSMMNwgBtObkZWISYRTwAXXc-Cp3MkuDAxCJjXWUEQbGIADk+uRBu5jaaYOb0LDGYgQEYIpptupmInxYitgdpLKmYq1cxqEEzg9cPM6qijjDS+XNpW5tWRrUC7ihPs4BnkBZS2L3jntoMC+Ei6CS2WxhWq7Ua3Wp70Z82562XCsgA\nexport function queryDefinition<\n  TSMNode extends ISMNode,\n  TMapFn extends MapFnForNode<TSMNode> | undefined\n>(queryDefinition: QueryDefinition<TSMNode, TMapFn>) {\n  return queryDefinition;\n}\n","import { SMData, SM_DATA_TYPES } from './smDataTypes';\nimport {\n  ISMJS,\n  ISMData,\n  SMDataDefaultFn,\n  NodeRelationalQueryBuilderRecord,\n  NodeMutationFn,\n  NodeDO,\n  NodeComputedFns,\n  NodeRelationalFns,\n  DeepPartial,\n  NodeRelationalQueryBuilder,\n  ISMNode,\n} from './types';\n\nexport function createDOFactory(smJSInstance: ISMJS) {\n  /**\n   * Returns a DO class, since there is one instance of the DO class\n   * for each instance of that node type that is fetched from SM\n   */\n  return function DOFactory<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any>,\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord,\n    TNodeMutations extends Record<\n      string,\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\n    >,\n    TDOClass = new (initialData?: Record<string, any>) => NodeDO\n  >(node: {\n    type: string;\n    properties: TNodeData;\n    computed?: NodeComputedFns<TNodeData, TNodeComputedData>;\n    relational?: NodeRelationalFns<TNodeRelationalData>;\n    mutations?: TNodeMutations;\n  }): TDOClass {\n    // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\n    // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\n    // eslint-disable-next-line\n    // @ts-ignore\n    return class DO implements TDOClass {\n      public parsedData: DeepPartial<TNodeData>;\n      public version: number = -1;\n      private _defaults: Record<keyof TNodeData, any>;\n      private _persistedData: Record<string, any> = {};\n\n      constructor(initialData?: DeepPartial<TNodeData> & { version: number }) {\n        this._defaults = this.getDefaultData(node.properties);\n        if (initialData?.version) {\n          this.version = Number(initialData.version);\n        }\n\n        if (initialData) {\n          this._persistedData = this.parseReceivedData({\n            initialData,\n            nodeProperties: node.properties,\n          });\n        }\n\n        this.parsedData = this.getParsedData({\n          smData: node.properties,\n          persistedData: this._persistedData,\n          defaultData: this._defaults,\n        });\n\n        smJSInstance.plugins?.forEach(plugin => {\n          if (plugin.DO?.onConstruct) {\n            plugin.DO.onConstruct({\n              DOInstance: this,\n              parsedDataKey: 'parsedData',\n            });\n          }\n        });\n\n        this.initializeNodePropGettersAndSetters();\n        this.initializeNodeComputedGetters();\n        this.initializeNodeRelationalGetters();\n        this.initializeNodeMutations();\n      }\n\n      private parseReceivedData(opts: {\n        initialData: Record<string, any>;\n        nodeProperties: typeof node.properties;\n      }) {\n        const { initialData, nodeProperties } = opts;\n\n        return Object.entries(nodeProperties).reduce(\n          (acc, [propName, propValue]) => {\n            const property = this.getSMData(propValue);\n\n            const propExistsInInitialData =\n              propName in initialData && initialData[propName] != null;\n\n            if (this.isObjectType(property.type) && propExistsInInitialData) {\n              acc[propName] = this.parseReceivedData({\n                initialData: initialData[propName],\n                nodeProperties: property.boxedValue,\n              });\n            } else if (\n              this.isArrayType(property.type) &&\n              propExistsInInitialData\n            ) {\n              acc[propName] = initialData[propName].map(\n                property.boxedValue.parser\n              );\n            } else if (\n              propName in initialData &&\n              initialData[propName] === null\n            ) {\n              acc[propName] = null;\n            } else if (propExistsInInitialData) {\n              acc[propName] = property.parser(initialData[propName]);\n            }\n\n            return acc;\n          },\n          {} as Record<string, any>\n        );\n      }\n\n      private getDefaultData = (\n        nodePropertiesOrSMData:\n          | typeof node.properties\n          | SMData<any, any, any>\n          | ((_default: any) => SMData<any, any, any>)\n      ): Record<keyof TNodeData, any> => {\n        if (nodePropertiesOrSMData instanceof SMData) {\n          if (this.isObjectType(nodePropertiesOrSMData.type)) {\n            return this.getDefaultData(nodePropertiesOrSMData.boxedValue);\n          }\n          return nodePropertiesOrSMData.defaultValue;\n        }\n\n        const getDefaultFnValue = (\n          propName?: keyof TNodeData,\n          defaultSMData?: ISMData\n        ) => {\n          const defaultFn =\n            defaultSMData ||\n            ((nodePropertiesOrSMData as TNodeData)[\n              propName as keyof TNodeData\n            ] as any)._default;\n\n          // if a boolean dataType is not passed a default value, it returns an error. We throw it here\n          if (defaultFn instanceof Error) {\n            throw defaultFn;\n          }\n\n          // if array type, we need to set the default value as an array containing the parent type's boxedValue\n          if (this.isArrayType(defaultFn.type)) {\n            if (this.isObjectType(defaultFn.boxedValue.type)) {\n              return [this.getDefaultData(defaultFn.boxedValue.boxedValue)];\n            }\n            return [defaultFn.boxedValue.defaultValue];\n          }\n\n          return defaultFn.defaultValue;\n        };\n\n        if (typeof nodePropertiesOrSMData === 'function') {\n          return getDefaultFnValue(\n            undefined,\n            (nodePropertiesOrSMData as any)._default as ISMData\n          );\n        }\n\n        return Object.keys(nodePropertiesOrSMData).reduce(\n          (acc, prop: keyof TNodeData) => {\n            const propValue = nodePropertiesOrSMData[prop] as ISMData;\n            if (\n              this.isObjectType(propValue.type) ||\n              this.isRecordType(propValue.type)\n            ) {\n              acc[prop] = this.getDefaultData(propValue.boxedValue);\n            } else if (typeof propValue === 'function') {\n              const defaultValue = getDefaultFnValue(prop);\n\n              acc[prop] = defaultValue;\n            } else {\n              acc[prop] = (nodePropertiesOrSMData[\n                prop\n              ] as ISMData).defaultValue;\n            }\n            return acc;\n          },\n          {} as Record<keyof TNodeData, any>\n        );\n      };\n\n      private getParsedData(opts: {\n        smData: ISMData | Record<string, ISMData | SMDataDefaultFn>; // because it can be a single value (sm.number, sm.string, sm.boolean, sm.array, sm.record) or an object (root node data, nested objects)\n        persistedData: any;\n        defaultData: any;\n      }) {\n        if (\n          opts.smData instanceof SMData &&\n          opts.smData.isOptional &&\n          opts.persistedData == null\n        ) {\n          return null;\n        }\n\n        const property = this.getSMData(opts.smData as ISMData);\n\n        if (property instanceof SMData && property.boxedValue) {\n          // sm.array, sm.object or sm.record\n          if (this.isArrayType(property.type)) {\n            if (opts.persistedData) {\n              return (opts.persistedData || []).map((data: any) => {\n                return this.getParsedData({\n                  smData: property.boxedValue,\n                  persistedData: data,\n                  defaultData:\n                    property.type === SM_DATA_TYPES.array\n                      ? opts.defaultData?.[0] || null // If property is a non-optional array and the boxed value is of type sm.object, the default data for an array should be an array with a single item, where that item is the default data for that object\n                      : null,\n                });\n              });\n            } else {\n              return opts.defaultData;\n            }\n          } else {\n            // sm.object, sm.record\n            // safe to assume that if we made it this far, the expected data type is object and it's non optional, so lets default it to {}\n            if (!opts.persistedData) {\n              opts.persistedData = {};\n            }\n\n            const boxedValueSMProperty = this.getSMData(property.boxedValue);\n\n            if (boxedValueSMProperty instanceof SMData) {\n              // sm.record\n              return Object.keys(opts.persistedData).reduce((acc, key) => {\n                acc[key] = this.getParsedData({\n                  smData: property.boxedValue,\n                  persistedData: opts.persistedData[key],\n                  defaultData: opts.defaultData, //opts.defaultData,\n                }); // no default value for values in a record\n                return acc;\n              }, {} as Record<string, any>);\n            } else {\n              // if we're dealing with an object, lets loop over the keys in its boxed value\n              return Object.keys(property.boxedValue).reduce((acc, key) => {\n                acc[key] = this.getParsedData({\n                  smData: property.boxedValue[key],\n                  persistedData: opts.persistedData[key],\n                  defaultData: opts.defaultData?.[key],\n                });\n                return acc;\n              }, {} as Record<string, any>);\n            }\n          }\n        } else if (property instanceof SMData) {\n          // sm.string, sm.boolean, sm.number\n          if (opts.persistedData != null) {\n            return property.parser(opts.persistedData);\n          }\n\n          return opts.defaultData;\n        } else {\n          // root of node, simply loop over keys of data definition and call this function recursively\n          return Object.keys(property).reduce((acc, prop) => {\n            acc[prop] = this.getParsedData({\n              // @ts-ignore\n              smData: property[prop],\n              persistedData: opts.persistedData[prop],\n              defaultData: opts.defaultData[prop],\n            });\n            return acc;\n          }, {} as Record<string, any>);\n        }\n      }\n\n      public onDataReceived = (receivedData: DeepPartial<TNodeData>) => {\n        if (receivedData.version == null) {\n          throw Error('Message received for a node was missing a version');\n        }\n\n        const { version, ...restReceivedData } = receivedData;\n        const newVersion = Number(version);\n\n        if (newVersion >= this.version) {\n          this.version = newVersion;\n\n          const newData = this.parseReceivedData({\n            initialData: restReceivedData,\n            nodeProperties: node.properties,\n          });\n\n          this.extendPersistedWithNewlyReceivedData({\n            smData: node.properties,\n            object: this._persistedData,\n            extension: newData,\n          });\n\n          this.parsedData = this.getParsedData({\n            smData: node.properties,\n            persistedData: this._persistedData,\n            defaultData: this._defaults,\n          });\n        }\n      };\n\n      private extendPersistedWithNewlyReceivedData(opts: {\n        smData: Record<string, ISMData | SMDataDefaultFn>;\n        object: Record<string, any>;\n        extension: Record<string, any>;\n      }) {\n        Object.entries(opts.extension).forEach(([key, value]) => {\n          const smDataForThisProp = this.getSMData(opts.smData[key]);\n\n          // if this is a record, completely overwrite the stored persisted data\n          if (this.isRecordType(smDataForThisProp.type)) {\n            opts.object[key] = value;\n          } else {\n            // if it's an object, extend the persisted data we've received so far with the newly received data\n            if (this.isObjectType(smDataForThisProp.type)) {\n              if (value == null) {\n                opts.object[key] = null;\n              } else {\n                opts.object[key] = opts.object[key] || {};\n\n                this.extendPersistedWithNewlyReceivedData({\n                  smData: smDataForThisProp.boxedValue,\n                  object: opts.object[key],\n                  extension: value,\n                });\n              }\n            } else {\n              // otherwise no need to extend, simply overwrite the value\n              opts.object[key] = value;\n            }\n          }\n        });\n      }\n\n      /**\n       * initializes getters and setters for properties that are stored on this node in SM\n       * as properties on this DO instance\n       */\n      private initializeNodePropGettersAndSetters() {\n        Object.keys(node.properties).forEach(prop => {\n          const property = this.getSMData(node.properties[prop]);\n\n          if (this.isObjectType(property.type)) {\n            this.setObjectProp(prop);\n          } else if (this.isArrayType(property.type)) {\n            this.setArrayProp(prop);\n          } else {\n            this.setPrimitiveValueProp(prop);\n          }\n        });\n      }\n\n      private initializeNodeComputedGetters() {\n        const computedData = node.computed;\n        if (computedData) {\n          Object.keys(computedData).forEach(computedProp => {\n            this.setComputedProp({\n              propName: computedProp,\n              computedFn: computedData[computedProp] as (\n                data: Record<string, any>\n              ) => any,\n            });\n          });\n        }\n      }\n\n      private initializeNodeRelationalGetters() {\n        const relationalData = node.relational;\n        if (relationalData) {\n          Object.keys(relationalData).forEach(relationalProp => {\n            this.setRelationalProp({\n              propName: relationalProp,\n              relationalQueryGetter: relationalData[\n                relationalProp\n              ] as () => NodeRelationalQueryBuilder<\n                ISMNode<TNodeData, TNodeComputedData, TNodeRelationalData>\n              >,\n            });\n          });\n        }\n      }\n\n      private initializeNodeMutations() {\n        const mutations = node.mutations;\n        if (mutations) {\n          Object.keys(mutations).forEach(mutationName => {\n            Object.defineProperty(this, mutationName, {\n              get: () => mutations[mutationName].bind(this),\n            });\n          });\n        }\n      }\n\n      /**\n       * Object type props have different getters and setters than non object type\n       * because when an object property is set we extend the previous value, instead of replacing its reference entirely (we've seen great performance gains doing this)\n       */\n      private setObjectProp = (propNameForThisObject: string) => {\n        Object.defineProperty(this, propNameForThisObject, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propNameForThisObject];\n          },\n        });\n      };\n\n      private setPrimitiveValueProp = (propName: string) => {\n        Object.defineProperty(this, propName, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propName];\n          },\n        });\n      };\n\n      private setArrayProp = (propName: string) => {\n        Object.defineProperty(this, propName, {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return this.parsedData[propName];\n          },\n        });\n      };\n\n      private setComputedProp(opts: {\n        propName: string;\n        computedFn: (nodeData: Record<string, any>) => any;\n      }) {\n        let computedGetter = () => opts.computedFn(this);\n        smJSInstance.plugins?.forEach(plugin => {\n          if (plugin.DO?.computedDecorator) {\n            computedGetter = plugin.DO.computedDecorator({\n              computedFn: computedGetter,\n              DOInstance: this,\n            });\n          }\n        });\n\n        Object.defineProperty(this, opts.propName, {\n          get: () => computedGetter(),\n          enumerable: true,\n        });\n      }\n\n      private setRelationalProp(opts: {\n        propName: string;\n        relationalQueryGetter: () => NodeRelationalQueryBuilder<\n          ISMNode<TNodeData, TNodeComputedData, TNodeRelationalData>\n        >;\n      }) {\n        Object.defineProperty(this, opts.propName, {\n          configurable: true,\n          get: () => {\n            return opts.relationalQueryGetter();\n          },\n        });\n      }\n\n      private getSMData(prop: ISMData<any, any, any> | SMDataDefaultFn) {\n        if (typeof prop === 'function') {\n          return (prop as any)._default as ISMData;\n        }\n        return prop as ISMData;\n      }\n\n      private isArrayType(type: string) {\n        return (\n          type === SM_DATA_TYPES.array || type === SM_DATA_TYPES.maybeArray\n        );\n      }\n\n      private isObjectType(type: string) {\n        return (\n          type === SM_DATA_TYPES.object || type === SM_DATA_TYPES.maybeObject\n        );\n      }\n\n      private isRecordType(type: string) {\n        return (\n          type === SM_DATA_TYPES.record || type === SM_DATA_TYPES.maybeRecord\n        );\n      }\n    };\n  };\n}\n","import {\n  SMNotUpToDateException,\n  SMNotUpToDateInComputedException,\n} from './exceptions';\nimport { OBJECT_PROPERTY_SEPARATOR, SM_DATA_TYPES } from './smDataTypes';\nimport {\n  ISMJS,\n  ISMData,\n  SMDataDefaultFn,\n  IDOProxy,\n  ISMNode,\n  NodeDO,\n  Maybe,\n  RelationalQueryRecordEntry,\n} from './types';\n\nexport function createDOProxyGenerator(smJSInstance: ISMJS) {\n  /**\n   * When some data fetcher like \"useQuery\" requests some data we do not directly return the DO instances\n   * Instead, we decorate each DO instance with a bit of functionality\n   * Firstly, we add getters for relational results\n   *      For example, if I request a list of todos and an assignee for each of those todos\n   *        this proxy generator would be adding an \"assignee\" getter to each todo and\n   *        that assignee getter would return a PROXIED DO for that user\n   *\n   * Why not just store that data on the do instance directly?\n   *      For this case I just described it wouldn't be a problem, since a todo has a single assignee\n   *      But imagine a scenario in which a developer is querying for a specific meeting and all active todos in that meeting\n   *        and then lazily querying all the archived todos for that meeting.\n   *        If the developer isn't extremely careful with naming collision (activeTodos vs archivedTodos distinction, vs just calling them \"todos\")\n   *        it's easy to see how this would create a problem if both query sources are getting the same DO instance\n   *\n   *      To get around this problem, EACH REQUEST RESULT WILL RETURN ITS OWN INSTANCE OF A PROXIED DO\n   *         so naming collision is never a problem.\n   *\n   *      This also gives us the benefit of support different paging results being displayed simultaneously, since again, the relation results from different\n   *         queries will never overwrite each other.\n   *\n   *\n   * Another use for this proxy is to ensure the developer receives helpful errors when they try to read some data that is not being subscribed to\n   *      This means that if I query a list of users, request their \"firstName\" and \"id\", but then attempt to read user.lastName from the result of that query\n   *      we don't just return the cached value, or undefined, because this is likely unintentional. Most apps will want to have real time data.\n   *\n   *      Instead, we'll throw an error and tell them - hey, you tried to read this property from this node type in this query, but you didn't request it/aren't subscribed to it!\n   */\n  return function DOProxyGenerator<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any>,\n    TRelationalResults extends Record<string, Array<IDOProxy> | IDOProxy>\n  >(opts: {\n    node: ISMNode<TNodeData, TNodeComputedData>;\n    queryId: string;\n    do: NodeDO;\n    // The DOProxy protects the dev from reading a property that we haven't actually queried from SM\n    allPropertiesQueried: Array<string>;\n    relationalResults: Maybe<TRelationalResults>;\n    relationalQueries: Maybe<Record<string, RelationalQueryRecordEntry>>;\n  }): NodeDO & TRelationalResults & IDOProxy {\n    let relationalResults = opts.relationalResults;\n\n    // Casting to unknown here because we don't want type safety around structure of a node's data when building plugins\n    // but completely losing type safety in opts.node.smComputed would break the return type inference in QueryDataReturn\n    const nodeSMComputed = (opts.node.smComputed as unknown) as Record<\n      string,\n      (proxy: IDOProxy) => any\n    >;\n    const computedAccessors = nodeSMComputed\n      ? Object.keys(nodeSMComputed).reduce((acc, computedKey) => {\n          let computedFn = () => nodeSMComputed[computedKey](proxy as IDOProxy);\n          smJSInstance.plugins?.forEach(plugin => {\n            if (plugin.DOProxy?.computedDecorator) {\n              computedFn = plugin.DOProxy.computedDecorator({\n                ProxyInstance: proxy,\n                computedFn,\n              });\n            }\n          });\n\n          acc[computedKey] = computedFn;\n\n          return acc;\n        }, {} as Record<string, () => any>)\n      : {};\n\n    const proxy = new Proxy(opts.do as Record<string, any>, {\n      getOwnPropertyDescriptor: function(target, key: string) {\n        // This gives better json stringify results\n        // by preventing attempts to get properties which are not\n        // guaranteed to be up to date\n        // @TODO write tests for this enumeration\n        if (\n          opts.allPropertiesQueried.includes(key) ||\n          (opts.relationalQueries &&\n            Object.keys(opts.relationalQueries).includes(key))\n        ) {\n          return {\n            ...Object.getOwnPropertyDescriptor(target, key),\n            enumerable: true,\n            configurable: true,\n          };\n        }\n\n        return {\n          ...Object.getOwnPropertyDescriptor(target, key),\n          enumerable: false,\n        };\n      },\n      get: (target, key: string) => {\n        if (key === 'updateRelationalResults') {\n          return (newRelationalResults: Maybe<TRelationalResults>) => {\n            relationalResults = {\n              ...relationalResults,\n              ...newRelationalResults,\n            } as Maybe<TRelationalResults>;\n          };\n        }\n\n        if (\n          relationalResults &&\n          opts.relationalQueries &&\n          Object.keys(relationalResults).includes(key)\n        ) {\n          // SM returns an array when \"byReference\" is used\n          // but we only care about the first result\n          if ('byReference' in opts.relationalQueries[key]) {\n            const results = relationalResults[key];\n            if (!Array.isArray(results))\n              throw Error(`Expected results to be an array but it wasn't`);\n            return results[0];\n          }\n          return relationalResults[key];\n        }\n\n        if (Object.keys(opts.node.smData).includes(key)) {\n          if (!opts.allPropertiesQueried.includes(key)) {\n            throw new SMNotUpToDateException({\n              propName: key,\n              queryId: opts.queryId,\n              nodeType: opts.node.type,\n            });\n          }\n\n          const smDataForThisProp = opts.node.smData[key] as ISMData;\n          if (\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\n          ) {\n            // do not return an object if this prop came back as null from SM\n            if (opts.do[key] == null) return opts.do[key];\n\n            return getNestedObjectWithNotUpToDateProtection({\n              nodeType: opts.node.type,\n              queryId: opts.queryId,\n              allCachedData: opts.do[key],\n              smDataForThisObject: smDataForThisProp.boxedValue,\n              allPropertiesQueried: opts.allPropertiesQueried,\n              parentObjectKey: key,\n            });\n          }\n\n          return opts.do[key];\n        } else if (computedAccessors[key]) {\n          try {\n            return computedAccessors[key]();\n          } catch (e) {\n            if (e instanceof SMNotUpToDateException) {\n              throw new SMNotUpToDateInComputedException({\n                computedPropName: key,\n                propName: e.propName,\n                nodeType: opts.node.type,\n                queryId: opts.queryId,\n              });\n            }\n\n            throw e;\n          }\n        }\n\n        return target[key];\n      },\n    }) as NodeDO & TRelationalResults & IDOProxy;\n\n    return proxy;\n  };\n\n  function getNestedObjectWithNotUpToDateProtection(opts: {\n    nodeType: string;\n    queryId: string;\n    allCachedData: Record<string, any>;\n    smDataForThisObject: Record<string, ISMData>;\n    allPropertiesQueried: Array<string>;\n    parentObjectKey: Maybe<string>;\n  }) {\n    const objectToReturn = {};\n\n    Object.keys(opts.smDataForThisObject).forEach(objectProp => {\n      const name = opts.parentObjectKey\n        ? `${opts.parentObjectKey}${OBJECT_PROPERTY_SEPARATOR}${objectProp}`\n        : objectProp;\n      const smDataForThisProp = opts.smDataForThisObject[objectProp];\n      const isUpToDate =\n        opts.allPropertiesQueried.includes(name) ||\n        // this second case handles ensuring that nested objects are enumerable\n        // for example, if user matches the interface { address: { apt: { floor: number, unit: number } } }\n        // and we request address_apt_floor and address_apt_unit\n        // we need to make address.apt enumerable below\n        opts.allPropertiesQueried.some(prop => prop.startsWith(name));\n\n      Object.defineProperty(objectToReturn, objectProp, {\n        // @TODO write tests for this enumeration\n        enumerable: isUpToDate,\n        get: () => {\n          if (\n            smDataForThisProp.type === SM_DATA_TYPES.object ||\n            smDataForThisProp.type === SM_DATA_TYPES.maybeObject\n          ) {\n            if (opts.allCachedData[objectProp] == null)\n              return opts.allCachedData[objectProp];\n\n            return getNestedObjectWithNotUpToDateProtection({\n              nodeType: opts.nodeType,\n              queryId: opts.queryId,\n              allCachedData: opts.allCachedData[objectProp],\n              smDataForThisObject: smDataForThisProp.boxedValue,\n              allPropertiesQueried: opts.allPropertiesQueried,\n              parentObjectKey: name,\n            });\n          }\n\n          if (!isUpToDate) {\n            throw new SMNotUpToDateException({\n              propName: name,\n              nodeType: opts.nodeType,\n              queryId: opts.queryId,\n            });\n          }\n\n          return opts.allCachedData\n            ? opts.allCachedData[objectProp]\n            : undefined;\n        },\n      });\n    });\n\n    return objectToReturn;\n  }\n}\n","export const JSON_TAG = '__JSON__';\nexport const NULL_TAG = '__NULL__';\n\nexport function parseJSONFromBE(jsonString: string) {\n  if (!jsonString.startsWith(JSON_TAG)) {\n    throw Error(`parseJSONFromBE - invalid json received:\\n${jsonString}`);\n  }\n\n  // convert string array into js array\n  if (jsonString.startsWith(`${JSON_TAG}[`)) {\n    return JSON.parse(jsonString.replace('__JSON__', ''));\n  }\n\n  // Allow new line text (\\n to \\\\n)\n  // replacing prevents JSON.parse to complaining\n  return JSON.parse(jsonString.replace(JSON_TAG, '').replace(/\\n/g, '\\\\n'));\n}\n\nexport function prepareValueForFE(value: any): any {\n  if (value === NULL_TAG) {\n    return null;\n  } else if (value === 'true' || value === 'false') {\n    return value === 'true';\n  } else if (typeof value === 'string' && value.startsWith(JSON_TAG)) {\n    return parseJSONFromBE(value);\n  } else if (Array.isArray(value)) {\n    return value.map(entry => {\n      if (typeof entry === 'object') {\n        return prepareValueForFE(entry);\n      } else {\n        return entry;\n      }\n    });\n  } else if (value != null && typeof value === 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return prepareForFE(value);\n  } else {\n    return value;\n  }\n}\n\nexport function prepareForFE(beData: Record<string, any>) {\n  return Object.keys(beData).reduce((prepared, key) => {\n    const value = beData[key];\n    return {\n      ...prepared,\n      [key]: prepareValueForFE(value),\n    };\n  }, {} as Record<string, any>);\n}\n","import { gql } from '@apollo/client/core';\nimport {\n  SM_DATA_TYPES,\n  SM_RELATIONAL_TYPES,\n  OBJECT_PROPERTY_SEPARATOR,\n} from './smDataTypes';\nimport { SMUnexpectedSubscriptionMessageException } from './exceptions';\nimport {\n  NodeRelationalFns,\n  NodeRelationalQueryBuilderRecord,\n  MapFn,\n  ISMData,\n  NodeRelationalQuery,\n  ISMNode,\n  NodeComputedFns,\n  RelationalQueryRecordEntry,\n  BaseQueryRecordEntry,\n  IByReferenceQuery,\n  QueryDefinitions,\n  QueryRecord,\n  QueryRecordEntry,\n  QueryFilterEqualsKeyValue,\n} from './types';\n\nexport const PROPERTIES_QUERIED_FOR_ALL_NODES = ['id', 'version'];\n\n/**\n * Relational fns are specified when creating an smNode as fns that return a NodeRelationalQueryBuilder\n * so they can be evaluated lazily to avoid dependency loops between nodes related to each other.\n *\n * This fn executs those fns at query time, and returns a record of relational query builders\n */\nfunction getRelationalQueryBuildersFromRelationalFns(\n  relationaFns?: NodeRelationalFns<any>\n) {\n  if (!relationaFns) return {};\n\n  return Object.keys(relationaFns).reduce((acc, key) => {\n    acc[key] = relationaFns[key]();\n\n    return acc;\n  }, {} as NodeRelationalQueryBuilderRecord);\n}\n\nfunction getMapFnReturn(opts: {\n  mapFn: MapFn<any, any, any>;\n  properties: Record<string, ISMData>;\n  relational?: NodeRelationalFns<any>;\n}) {\n  const mapFnOpts: Record<string, any> = {\n    ...opts.properties,\n    ...getRelationalQueryBuildersFromRelationalFns(opts.relational),\n  };\n\n  Object.keys(opts.properties).forEach(key => {\n    const data = opts.properties[key] as ISMData;\n\n    if (\n      data.type === SM_DATA_TYPES.object ||\n      data.type === SM_DATA_TYPES.maybeObject\n    ) {\n      mapFnOpts[key] = (opts: { map: MapFn<any, any, any> }) => opts.map;\n    }\n  });\n\n  return opts.mapFn(mapFnOpts) as Record<\n    string,\n    ISMData | MapFn<any, any, any> | NodeRelationalQuery<ISMNode>\n  >;\n}\n\n/**\n * The functions in this file are responsible for translating queryDefinitionss to gql documents\n * only function that should be needed outside this file is convertQueryDefinitionToQueryInfo\n * other fns are exported for testing purposes only\n */\nfunction getQueriedProperties(opts: {\n  queryId: string;\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\n  smData: Record<string, any>;\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\n  // this optional arg is only true the first time this fn is called\n  // and is used to ensure we also query nested data that was stored in the old format (stringified json)\n  isRootLevel?: true;\n}): Array<string> {\n  const mapFnReturn = getMapFnReturn({\n    mapFn: opts.mapFn,\n    properties: opts.smData,\n    relational: opts.smRelational,\n  });\n\n  if (mapFnReturn == null) {\n    // @TODO ran into this issue when I forgot to call the query for a nested object, figure out a way to give a better error message\n    // user: useAuthenticatedOrgUserData(\n    //   ({ id, orgRole, accessLevel, preferences }) => ({\n    //     id,\n    //     orgRole,\n    //     accessLevel,\n    //     preferences: preferences({\n    //       query: ({ universityLevel }) => ({ universityLevel }), => this university level is a nested object\n    //     }),\n    //   })\n    // ),\n    throw Error(\n      `The query with the id '${opts.queryId}' has an unexpected value in the query result.`\n    );\n  }\n\n  return Object.keys(mapFnReturn).reduce(\n    (acc, key) => {\n      const isData = !!opts.smData[key];\n\n      if (!isData) return acc;\n\n      // we always query these properties, can ignore any explicit requests for it\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\n        return acc;\n      }\n\n      const data = opts.smData[key] as ISMData;\n      if (\n        data.type === SM_DATA_TYPES.object ||\n        data.type === SM_DATA_TYPES.maybeObject\n      ) {\n        // query for any data stored in old format (stringified json at the root of the node)\n        acc.push(key);\n\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\n        acc.push(\n          ...getQueriedProperties({\n            queryId: opts.queryId,\n            mapFn: mapFnReturn[key] as MapFn<any, any, any>,\n            smData: (data.boxedValue as unknown) as Record<string, ISMData>,\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\n        );\n        return acc;\n      }\n\n      return [...acc, key];\n    },\n    opts.isRootLevel\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\n      : ([] as Array<string>)\n  );\n}\n\nfunction getAllNodeProperties(opts: {\n  nodeProperties: Record<string, ISMData>;\n  isRootLevel: boolean;\n}) {\n  return Object.keys(opts.nodeProperties).reduce(\n    (acc, key) => {\n      // we are already querying these properties, can ignore any explicit requests for it\n      if (opts.isRootLevel && PROPERTIES_QUERIED_FOR_ALL_NODES.includes(key)) {\n        return acc;\n      }\n\n      const data = opts.nodeProperties[key] as ISMData;\n      if (\n        data.type === SM_DATA_TYPES.object ||\n        data.type === SM_DATA_TYPES.maybeObject\n      ) {\n        // query for any data stored in old format (stringified json at the root of the node)\n        acc.push(key);\n        // query for data in new format (\"rootLevelProp_nestedProp_moreNestedProp\")\n        acc.push(\n          ...getAllNodeProperties({\n            nodeProperties: opts.nodeProperties[key].boxedValue as Record<\n              string,\n              ISMData\n            >,\n            isRootLevel: false,\n          }).map(nestedKey => `${key}${OBJECT_PROPERTY_SEPARATOR}${nestedKey}`)\n        );\n        return acc;\n      }\n\n      return [...acc, key];\n    },\n    opts.isRootLevel\n      ? [...PROPERTIES_QUERIED_FOR_ALL_NODES]\n      : ([] as Array<string>)\n  );\n}\n\nfunction getRelationalQueries(opts: {\n  queryId: string;\n  mapFn: (smData: Record<string, any>) => Record<string, any>;\n  smData: Record<string, any>;\n  smComputed?: NodeComputedFns<Record<string, any>, Record<string, any>>;\n  smRelational?: NodeRelationalFns<NodeRelationalQueryBuilderRecord>;\n}): Record<string, RelationalQueryRecordEntry> | undefined {\n  const mapFnReturn = getMapFnReturn({\n    mapFn: opts.mapFn,\n    properties: opts.smData,\n    relational: opts.smRelational,\n  });\n\n  const relationalQueries = Object.keys(mapFnReturn).reduce((acc, key) => {\n    const isData = !!opts.smData[key];\n    const isComputed = opts.smComputed ? !!opts.smComputed[key] : false;\n\n    if (isData || isComputed) {\n      return acc;\n    } else {\n      const relationalQuery = mapFnReturn[key] as NodeRelationalQuery<ISMNode>;\n\n      if (relationalQuery._smRelational == null) {\n        throw Error(\n          `getRelationalQueries - the key \"${key}\" is not a data property, not a computed property and does not contain a relational query.`\n        );\n      }\n\n      const mapFn = (data: any) => relationalQuery.map(data);\n\n      const relationalQueryRecord: BaseQueryRecordEntry = {\n        def: relationalQuery.def,\n        properties: getQueriedProperties({\n          queryId: opts.queryId,\n          mapFn: mapFn,\n          smData: relationalQuery.def.smData,\n          smComputed: relationalQuery.def.smComputed,\n          smRelational: relationalQuery.def.smRelational,\n          isRootLevel: true,\n        }),\n      };\n\n      const relationalQueriesWithinThisRelationalQuery = getRelationalQueries({\n        queryId: opts.queryId,\n        mapFn: mapFn,\n        smData: relationalQuery.def.smData,\n        smComputed: relationalQuery.def.smComputed,\n        smRelational: relationalQuery.def.smRelational,\n      });\n\n      if (relationalQueriesWithinThisRelationalQuery) {\n        relationalQueryRecord.relational = relationalQueriesWithinThisRelationalQuery;\n      }\n\n      const relationalType = relationalQuery._smRelational;\n      if (relationalType === SM_RELATIONAL_TYPES.byReference) {\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          byReference: true;\n        }).byReference = true;\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          idProp: string;\n        }).idProp = (relationalQuery as IByReferenceQuery<ISMNode, any>).idProp;\n      } else if (relationalType === SM_RELATIONAL_TYPES.children) {\n        (relationalQueryRecord as RelationalQueryRecordEntry & {\n          children: true;\n        }).children = true;\n        if ('depth' in relationalQuery) {\n          (relationalQueryRecord as RelationalQueryRecordEntry & {\n            depth?: number;\n          }).depth = relationalQuery.depth;\n        }\n      } else {\n        throw Error(`relationalType \"${relationalType}\" is not valid.`);\n      }\n\n      acc[key] = relationalQueryRecord as RelationalQueryRecordEntry;\n      return acc;\n    }\n  }, {} as Record<string, RelationalQueryRecordEntry>);\n\n  if (Object.keys(relationalQueries).length === 0) return undefined;\n  return relationalQueries;\n}\n\nexport function getQueryRecordFromQueryDefinition(opts: {\n  queryId: string;\n  queryDefinitions: QueryDefinitions;\n}) {\n  const queryRecord: QueryRecord = {};\n\n  Object.keys(opts.queryDefinitions).forEach(queryDefinitionsAlias => {\n    const queryDefinition = opts.queryDefinitions[queryDefinitionsAlias];\n\n    let queriedProps;\n    let nodeDef;\n    let relational;\n    if (queryDefinition._isSMNodeDef) {\n      // shorthand syntax where the dev only specified a node defition, nothing else\n      nodeDef = queryDefinition as ISMNode;\n      queriedProps = getAllNodeProperties({\n        nodeProperties: nodeDef.smData,\n        isRootLevel: true,\n      });\n    } else {\n      nodeDef = queryDefinition.def;\n      if (queryDefinition.map) {\n        queriedProps = getQueriedProperties({\n          mapFn: queryDefinition.map,\n          queryId: opts.queryId,\n          smData: queryDefinition.def.smData,\n          smComputed: queryDefinition.def.smComputed,\n          smRelational: queryDefinition.def.smRelational,\n          isRootLevel: true,\n        });\n        relational = getRelationalQueries({\n          mapFn: queryDefinition.map,\n          queryId: opts.queryId,\n          smData: nodeDef.smData,\n          smComputed: nodeDef.smComputed,\n          smRelational: nodeDef.smRelational,\n        });\n      } else {\n        queriedProps = getAllNodeProperties({\n          nodeProperties: nodeDef.smData,\n          isRootLevel: true,\n        });\n      }\n    }\n\n    const queryRecordEntry = {\n      def: nodeDef,\n      properties: queriedProps,\n      relational,\n    };\n\n    if ('ids' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { ids: Array<string> }).ids =\n        queryDefinition.ids;\n    } else if ('id' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { id: string }).id =\n        queryDefinition.id;\n    } else if ('underIds' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & {\n        underIds: Array<string>;\n      }).underIds = queryDefinition.underIds;\n      if ('depth' in queryDefinition) {\n        (queryRecordEntry as QueryRecordEntry & { depth?: string }).depth =\n          queryDefinition.depth;\n      }\n    }\n\n    if ('filter' in queryDefinition) {\n      (queryRecordEntry as QueryRecordEntry & { filter: any }).filter =\n        queryDefinition.filter;\n    }\n\n    queryRecord[queryDefinitionsAlias] = queryRecordEntry as QueryRecordEntry;\n  });\n  return queryRecord;\n}\n\nfunction getIdsString(ids: Array<string>) {\n  return `[${ids.map(id => `\"${id}\"`).join(',')}]`;\n}\n\nexport function getKeyValueFilterString<NodeType>(\n  clause: Partial<Record<keyof NodeType, string>>\n) {\n  return `{${Object.entries(clause).reduce((acc, [key, value]) => {\n    acc += `${key}: ${JSON.stringify(value)}`;\n    return acc;\n  }, '')}}`;\n}\n\nfunction getGetNodeOptions(opts: {\n  def: ISMNode;\n  underIds?: Array<string>;\n  depth?: number;\n  /** @TODO_TECH_DEBT_10_22 - https://tractiontools.atlassian.net/browse/MIO-335 */\n  filter?:\n    | Array<QueryFilterEqualsKeyValue<ISMNode>>\n    | QueryFilterEqualsKeyValue<ISMNode>;\n}) {\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\n\n  if (opts.underIds) {\n    options.push(`underIds: [${opts.underIds.map(id => `\"${id}\"`).join(',')}]`);\n  }\n\n  if (opts.depth !== null && opts.depth !== undefined) {\n    options.push(`depth: ${opts.depth}`);\n  }\n\n  if (opts.filter !== null && opts.filter !== undefined) {\n    options.push(\n      Array.isArray(opts.filter)\n        ? `filter: [${opts.filter.map(getKeyValueFilterString).join(',')}]`\n        : `filter: ${getKeyValueFilterString(opts.filter)}`\n    );\n  }\n\n  return options.join(', ');\n}\n\n// subscriptions use a slightly different set of arguments for now\n// https://tractiontools.atlassian.net/secure/RapidBoard.jspa?rapidView=53&projectKey=SMT&modal=detail&selectedIssue=SMT-636\nfunction getSubscriptionGetNodeOptions(opts: {\n  def: ISMNode;\n  under?: string;\n  depth?: number;\n}) {\n  const options: Array<string> = [`type: \"${opts.def.type}\"`];\n\n  if (opts.under) {\n    options.push(`underIds: [\"${opts.under}\"]`);\n  }\n\n  // @TODO uncomment when subscriptions support depth params\n  // if (opts.depth != null) {\n  //   options.push(`depth: ${opts.depth}`)\n  // }\n\n  return options.join(', ');\n}\n\nfunction getSpaces(numberOfSpaces: number) {\n  return new Array(numberOfSpaces).fill(' ').join('');\n}\n\nfunction getQueryPropertiesString(opts: {\n  queryRecordEntry: QueryRecordEntry | RelationalQueryRecordEntry;\n  nestLevel: number;\n}) {\n  let propsString = `\\n${getSpaces((opts.nestLevel + 2) * 2)}`;\n  propsString += opts.queryRecordEntry.properties.join(\n    `,\\n${getSpaces((opts.nestLevel + 2) * 2)}`\n  );\n\n  if (opts.queryRecordEntry.relational) {\n    propsString +=\n      (propsString !== '' ? ',' : '') +\n      getRelationalQueryString({\n        relationalQueryRecord: opts.queryRecordEntry.relational,\n        nestLevel: opts.nestLevel + 2,\n      });\n  }\n\n  return propsString;\n}\n\nfunction getRelationalQueryString(opts: {\n  relationalQueryRecord: Record<string, RelationalQueryRecordEntry>;\n  nestLevel: number;\n}) {\n  return Object.keys(opts.relationalQueryRecord).reduce((acc, alias) => {\n    const relationalQueryRecordEntry = opts.relationalQueryRecord[alias];\n\n    let operation: string;\n\n    if ('byReference' in relationalQueryRecordEntry) {\n      operation = `GetReferences(propertyNames: \"${relationalQueryRecordEntry.idProp}\")`;\n    } else if ('children' in relationalQueryRecordEntry) {\n      const depthString =\n        'depth' in relationalQueryRecordEntry\n          ? relationalQueryRecordEntry.depth !== undefined\n            ? `,depth: ${relationalQueryRecordEntry.depth}`\n            : ''\n          : '';\n      operation = `GetChildren(type: \"${relationalQueryRecordEntry.def.type}\"${depthString})`;\n    } else {\n      throw Error(\n        `relationalQueryRecordEntry is invalid\\n${JSON.stringify(\n          relationalQueryRecordEntry,\n          null,\n          2\n        )}`\n      );\n    }\n\n    return (\n      acc +\n      `\\n${getSpaces(opts.nestLevel * 2)}${alias}: ${operation} {` +\n      getQueryPropertiesString({\n        queryRecordEntry: relationalQueryRecordEntry,\n        nestLevel: opts.nestLevel,\n      }) +\n      `\\n${getSpaces(opts.nestLevel * 2)}}`\n    );\n  }, '');\n}\n\nfunction getRootLevelQueryString(\n  opts: {\n    alias: string;\n  } & QueryRecordEntry\n) {\n  let operation: string;\n  if ('ids' in opts) {\n    operation = `GetNodesByIdNew(ids: ${getIdsString(opts.ids)})`;\n  } else if ('id' in opts) {\n    operation = `GetNodesByIdNew(ids: ${getIdsString([opts.id])})`;\n  } else {\n    operation = `GetNodesNew(${getGetNodeOptions(opts)})`;\n  }\n\n  return (\n    `${opts.alias}: ${operation} {` +\n    `${getQueryPropertiesString({ queryRecordEntry: opts, nestLevel: 1 })}` +\n    `\\n${getSpaces(4)}}`\n  );\n}\n\nexport type SubscriptionConfig = {\n  alias: string;\n  gqlString: string;\n  extractNodeFromSubscriptionMessage: (\n    subscriptionMessage: Record<string, any>\n  ) => any;\n  extractOperationFromSubscriptionMessage: (\n    subscriptionMessage: Record<string, any>\n  ) => any;\n};\n\nexport function getQueryInfo(opts: {\n  queryDefinitions: QueryDefinitions;\n  queryId: string;\n}) {\n  const queryRecord: QueryRecord = getQueryRecordFromQueryDefinition(opts);\n  const queryGQLString = `\n    query ${getSanitizedQueryId({ queryId: opts.queryId })} {\n        ${Object.keys(queryRecord)\n          .map(alias =>\n            getRootLevelQueryString({\n              alias,\n              ...queryRecord[alias],\n            })\n          )\n          .join('\\n    ')}\n    }\n  `.trim();\n\n  const subscriptionConfigs: Array<SubscriptionConfig> = Object.keys(\n    queryRecord\n  ).reduce((subscriptionConfigsAcc, alias) => {\n    const subscriptionName = getSanitizedQueryId({\n      queryId: opts.queryId + '_' + alias,\n    });\n    const queryRecordEntry = queryRecord[alias];\n\n    let operations: Array<string>;\n    if ('ids' in queryRecordEntry) {\n      operations = [\n        `GetNodesById(ids: ${getIdsString(\n          queryRecordEntry.ids\n        )}, monitorChildEvents: true)`,\n      ];\n    } else if ('id' in queryRecordEntry) {\n      operations = [\n        `GetNodesById(ids: ${getIdsString([\n          queryRecordEntry.id,\n        ])}, monitorChildEvents: true)`,\n      ];\n    } else if ('underIds' in queryRecordEntry) {\n      operations = queryRecordEntry.underIds.map(underId => {\n        return `GetNodesNew(${getSubscriptionGetNodeOptions({\n          ...queryRecordEntry,\n          under: underId,\n        })}, monitorChildEvents: true)`;\n      });\n    } else {\n      operations = [\n        `GetNodesNew(${getSubscriptionGetNodeOptions(\n          queryRecordEntry\n        )}, monitorChildEvents: true)`,\n      ];\n    }\n\n    const gqlStrings = operations.map(operation => {\n      return `\n    subscription ${subscriptionName} {\n      ${alias}: ${operation} {\n        node {\n          ${getQueryPropertiesString({ queryRecordEntry, nestLevel: 5 })}\n        }\n        operation { action, path }\n      }\n    }\n        `.trim();\n    });\n\n    function extractNodeFromSubscriptionMessage(\n      subscriptionMessage: Record<string, any>\n    ) {\n      if (!subscriptionMessage[alias].node) {\n        throw new SMUnexpectedSubscriptionMessageException({\n          subscriptionMessage,\n          description: 'No \"node\" found in message',\n        });\n      }\n\n      return subscriptionMessage[alias].node;\n    }\n\n    function extractOperationFromSubscriptionMessage(\n      subscriptionMessage: Record<string, any>\n    ) {\n      if (!subscriptionMessage[alias].operation) {\n        throw new SMUnexpectedSubscriptionMessageException({\n          subscriptionMessage,\n          description: 'No \"operation\" found in message',\n        });\n      }\n\n      return subscriptionMessage[alias].operation;\n    }\n\n    gqlStrings.forEach(gqlString => {\n      subscriptionConfigsAcc.push({\n        alias,\n        gqlString,\n        extractNodeFromSubscriptionMessage,\n        extractOperationFromSubscriptionMessage,\n      });\n    });\n\n    return subscriptionConfigsAcc;\n  }, [] as Array<SubscriptionConfig>);\n\n  return {\n    subscriptionConfigs: subscriptionConfigs,\n    queryGQLString,\n    queryRecord,\n  };\n}\n\n/**\n * Converts a queryDefinitions into a gql doc that can be sent to the gqlClient\n * Returns a queryRecord for easily deduping requests based on the data that is being requested\n * Can later also be used to build a diff to request only the necessary data\n * taking into account the previous query record to avoid requesting data already in memory\n */\nexport function convertQueryDefinitionToQueryInfo(opts: {\n  queryDefinitions: QueryDefinitions;\n  queryId: string;\n}) {\n  const { queryGQLString, subscriptionConfigs, queryRecord } = getQueryInfo(\n    opts\n  );\n\n  return {\n    queryGQL: gql(queryGQLString),\n    subscriptionConfigs: subscriptionConfigs.map(subscriptionConfig => ({\n      ...subscriptionConfig,\n      gql: gql(subscriptionConfig.gqlString),\n    })),\n    queryRecord,\n  };\n}\n\nfunction getSanitizedQueryId(opts: { queryId: string }): string {\n  return opts.queryId.replace(/-/g, '_');\n}\n","import {\n  JSON_TAG,\n  NULL_TAG,\n  parseJSONFromBE,\n  prepareValueForFE,\n} from './dataConversions';\nimport { SMNotCachedException, SMDataParsingException } from './exceptions';\nimport { PROPERTIES_QUERIED_FOR_ALL_NODES } from './queryDefinitionAdapters';\nimport {\n  SM_DATA_TYPES,\n  OBJECT_PROPERTY_SEPARATOR,\n  OBJECT_IDENTIFIER,\n} from './smDataTypes';\nimport {\n  ISMData,\n  SMDataDefaultFn,\n  NodeDO,\n  ISMNodeRepository,\n  DeepPartial,\n  GetExpectedNodeDataType,\n} from './types';\n\n/**\n * Returns an initialized instance of a repository for an SMNode\n */\nexport function RepositoryFactory<\n  TNodeData extends Record<string, ISMData | SMDataDefaultFn>\n>(opts: {\n  def: {\n    type: string;\n    properties: TNodeData;\n  };\n  DOClass: new (initialData?: Record<string, any>) => NodeDO;\n}): ISMNodeRepository {\n  // silences the error \"A class can only implement an object type or intersection of object types with statically known members.\"\n  // wich happens because NodeDO has non statically known members (each property on a node in SM is mapped to a non-statically known property on the DO)\n  // eslint-disable-next-line\n  // @ts-ignore\n  class Repository implements ISMNodeRepository {\n    private cached: Record<string, NodeDO> = {};\n\n    public onDataReceived(data: { id: string } & Record<string, any>) {\n      const cached = this.cached[data.id];\n\n      const parsedData = this.parseDataFromSM<TNodeData>(data);\n\n      if (cached) {\n        cached.onDataReceived(parsedData);\n      } else {\n        this.cached[data.id] = new opts.DOClass(parsedData);\n      }\n    }\n\n    public byId(id: string) {\n      const cached = this.cached[id];\n\n      if (!cached) {\n        throw new SMNotCachedException({\n          nodeType: opts.def.type,\n          id,\n        });\n      }\n\n      return cached;\n    }\n\n    public onNodeDeleted(id: string) {\n      delete this.cached[id];\n    }\n    /**\n     * This method takes data that comes in from SM and is about to be applied to this DO's instance. It needs to:\n     * 1) ignore data not specified in the smNode definition for this node\n     *     this is so that the querier in smDataContext can call onDataReceived on the DO with the data it receives from SM without having to ignore the relational aliases there\n     *     without doing this, we'd get errors about attempting to set a property on a DO which is read only\n     * 2) take objects spread into root properties and convert them to regular objects\n     *     for example, if we are trying to store `settings: { show: true }` in SM, what is actually stored in the DB is\n     *     settings__dot__show: 'true'\n     *     since all data must be a string (we don't need to worry about coercing strings to booleans or numbers though, that's handled by the smDataTypes)\n     */\n    private parseDataFromSM<\n      TNodeData extends Record<string, ISMData | SMDataDefaultFn>\n    >(\n      receivedData: any\n    ): { id: string } & DeepPartial<GetExpectedNodeDataType<TNodeData>> {\n      const oldStyleObjects: Record<string, any> = {};\n      return Object.keys(receivedData).reduce((parsed, key: string) => {\n        const isDataStoredOnAllNodes = PROPERTIES_QUERIED_FOR_ALL_NODES.includes(\n          key\n        );\n        if (isDataStoredOnAllNodes) {\n          return {\n            ...parsed,\n            [key]: receivedData[key],\n          };\n        }\n\n        // point 1) above\n        const isDataStoredOnTheNode = key.includes(OBJECT_PROPERTY_SEPARATOR)\n          ? Object.keys(opts.def.properties).includes(\n              key.split(OBJECT_PROPERTY_SEPARATOR)[0]\n            )\n          : Object.keys(opts.def.properties).includes(key);\n\n        if (!isDataStoredOnTheNode) return parsed;\n\n        const isObjectData =\n          key.includes(OBJECT_PROPERTY_SEPARATOR) ||\n          (opts.def.properties[key] as ISMData).type === SM_DATA_TYPES.object ||\n          (opts.def.properties[key] as ISMData).type ===\n            SM_DATA_TYPES.maybeObject;\n\n        const isArrayData = (() => {\n          if (isObjectData) {\n            return false;\n          }\n\n          const receivedDataValue = opts.def.properties[key];\n\n          const smDataType =\n            typeof receivedDataValue === 'function'\n              ? ((receivedDataValue as any)._default as ISMData).type\n              : (receivedData as ISMData).type;\n\n          return (\n            smDataType === SM_DATA_TYPES.array ||\n            smDataType === SM_DATA_TYPES.maybeArray\n          );\n        })();\n\n        // point 2 above\n        if (isObjectData) {\n          const [root, ...nests] = key.split(OBJECT_PROPERTY_SEPARATOR);\n\n          // it it was set to __NULL__ it means this\n          // node is using the old style of storing nested objects\n          if (receivedData[root] === NULL_TAG || receivedData[root] === null) {\n            parsed[root as keyof TNodeData] = null as any;\n            return parsed;\n          } else if (\n            typeof receivedData[root] === 'string' &&\n            receivedData[root].startsWith(JSON_TAG)\n          ) {\n            // https://tractiontools.atlassian.net/browse/TT-2905\n            // will ensure this would've been set to null if this object was updated\n            //\n            // this means 3 things\n            // 1 we can acquire all the data for this object from this one property\n            // 2 we have to ignore the \"null\" values coming in when we're querying for the new style propeties (root_nestedProperty)\n            // 3 we have to ensure we only return from this object data that was queried\n            //   otherwise we risk hitting the DO class with data that is not documented in the node definition, leading to errors\n            try {\n              oldStyleObjects[root] =\n                oldStyleObjects[root] || parseJSONFromBE(receivedData[root]);\n            } catch (e) {\n              throw new SMDataParsingException({\n                receivedData,\n                message: 'Could not parse json stored in old format',\n              });\n            }\n          }\n\n          if (oldStyleObjects[root]) {\n            parsed[root as keyof TNodeData] =\n              parsed[root] ||\n              (this.getOnlyQueriedData({\n                allDataReceived: receivedData,\n                dataPreviouslyParsedForThisObject: oldStyleObjects[root],\n                rootProp: root,\n              }) as any);\n\n            return parsed;\n          }\n\n          if (parsed[root] == null) {\n            parsed[root as keyof TNodeData] = {} as any;\n          }\n\n          this.nest({\n            nests,\n            root: parsed[root] as Record<string, any>,\n            val:\n              receivedData[key] === OBJECT_IDENTIFIER ? {} : receivedData[key],\n          });\n\n          return parsed;\n        } else if (isArrayData) {\n          parsed[key as keyof TNodeData] = prepareValueForFE(receivedData[key]);\n          return parsed;\n        } else {\n          parsed[key as keyof TNodeData] = receivedData[key];\n          return parsed;\n        }\n      }, {} as { id: string } & DeepPartial<GetExpectedNodeDataType<TNodeData>>);\n    }\n\n    private getOnlyQueriedData(opts: {\n      allDataReceived: Record<string, any>;\n      dataPreviouslyParsedForThisObject: Record<string, any>;\n      rootProp: string;\n    }) {\n      const newStylePropertiesQueriedForThisObject = Object.keys(\n        opts.allDataReceived\n      ).filter(key =>\n        key.startsWith(`${opts.rootProp}${OBJECT_PROPERTY_SEPARATOR}`)\n      );\n\n      return newStylePropertiesQueriedForThisObject.reduce((acc, prop) => {\n        const [root, ...nests] = prop.split(OBJECT_PROPERTY_SEPARATOR);\n        this.nest({\n          nests,\n          root: acc,\n          val: this.getDataForProp({\n            prop,\n            object: { [root]: opts.dataPreviouslyParsedForThisObject },\n          }),\n        });\n\n        return acc;\n      }, {} as Record<string, any>);\n    }\n\n    // with a \"prop\" in the format root__dot__nestedKey__dot__evenMoreNestedKey\n    // returns the correct value from an \"object\" of previously parsed data { root: { nestedKey: { evenMoreNestedKey: true } } }\n    private getDataForProp(opts: {\n      object: Record<string, any>;\n      prop: string;\n    }): any {\n      if (opts.object == null) {\n        return undefined; // the prop is not set on the object at all\n      }\n\n      if (opts.prop.includes(OBJECT_PROPERTY_SEPARATOR)) {\n        const [root, ...rest] = opts.prop.split(OBJECT_PROPERTY_SEPARATOR);\n        return this.getDataForProp({\n          object: opts.object[root],\n          prop: rest.join(OBJECT_PROPERTY_SEPARATOR),\n        });\n      }\n\n      return opts.object[opts.prop];\n    }\n\n    private nest(opts: {\n      nests: Array<string>;\n      root: Record<string, any>;\n      val: any;\n    }) {\n      if (opts.nests.length === 0) {\n        opts.root = opts.val;\n      } else if (opts.nests.length === 1) {\n        const nextNest = opts.nests[0];\n        opts.root[nextNest] = opts.val;\n      } else {\n        const [nextNest, ...remainingNests] = opts.nests;\n\n        if (opts.root[nextNest] == null) {\n          opts.root[nextNest] = null;\n        } else {\n          this.nest({\n            nests: remainingNests,\n            root: opts.root[nextNest],\n            val: opts.val,\n          });\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  return new Repository();\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import {\n  convertQueryDefinitionToQueryInfo,\n  SubscriptionConfig,\n} from './queryDefinitionAdapters';\nimport {\n  ISMJS,\n  ISMQueryManager,\n  QueryDefinitions,\n  QueryOpts,\n  QueryReturn,\n  QueryDataReturn,\n  SubscriptionOpts,\n  SubscriptionMeta,\n  SubscriptionCanceller,\n} from './types';\n\nlet queryIdx = 0;\n\n/**\n * Declared as a factory function so that \"subscribe\" can generate its own querier which shares the same query manager\n * Which ensures that the socket messages are applied to the correct base set of results\n */\nexport function generateQuerier({\n  smJSInstance,\n  queryManager,\n}: {\n  smJSInstance: ISMJS;\n  queryManager?: ISMQueryManager;\n}) {\n  return async function query<TQueryDefinitions extends QueryDefinitions>(\n    queryDefinitions: TQueryDefinitions,\n    opts?: QueryOpts<TQueryDefinitions>\n  ): Promise<QueryReturn<TQueryDefinitions>> {\n    const startStack = new Error().stack as string;\n\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\n    const { queryGQL, queryRecord } = convertQueryDefinitionToQueryInfo({\n      queryDefinitions,\n      queryId,\n    });\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    function getError(error: any) {\n      if (opts?.onError) {\n        return error;\n      } else {\n        // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n        error.stack =\n          error.stack +\n          '\\n' +\n          startStack.substring(startStack.indexOf('\\n') + 1);\n\n        return error;\n      }\n    }\n\n    if (!token) {\n      const error = getError(\n        new Error(\n          `No token registered with the name \"${tokenName}\".\\n` +\n            'Please register this token prior to using it with sm.setToken({ tokenName, token })) '\n        )\n      );\n\n      if (opts?.onError) {\n        opts.onError(error);\n        return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n      } else {\n        throw error;\n      }\n    }\n\n    return smJSInstance.gqlClient\n      .query({\n        gql: queryGQL,\n        token: token,\n        batched: opts?.batched,\n      })\n      .then((queryResult: any) => {\n        let results;\n        try {\n          const qM =\n            queryManager || new smJSInstance.SMQueryManager(queryRecord);\n          qM.onQueryResult({\n            queryId,\n            queryResult,\n          });\n\n          results = qM.getResults() as QueryDataReturn<TQueryDefinitions>;\n        } catch (e) {\n          const error = getError(\n            new Error(`Error applying query results\\n${e}`)\n          );\n\n          if (opts?.onError) {\n            opts.onError(error);\n            return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n          } else {\n            throw error;\n          }\n        }\n\n        opts?.onData && opts.onData({ results });\n        return { data: results, error: null };\n      })\n      .catch(e => {\n        const error = getError(new Error(`Error querying data\\n${e}`));\n        if (opts?.onError) {\n          opts.onError(error);\n          return { data: {} as QueryDataReturn<TQueryDefinitions>, error };\n        } else {\n          throw error;\n        }\n      });\n  };\n}\n\nexport function generateSubscriber(smJSInstance: ISMJS) {\n  return async function subscribe<\n    TQueryDefinitions extends QueryDefinitions,\n    TSubscriptionOpts extends SubscriptionOpts<TQueryDefinitions>\n  >(\n    queryDefinitions: TQueryDefinitions,\n    opts: TSubscriptionOpts\n  ): Promise<\n    TSubscriptionOpts extends { skipInitialQuery: true }\n      ? SubscriptionMeta\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta\n  > {\n    type ReturnType = TSubscriptionOpts extends {\n      skipInitialQuery: true;\n    }\n      ? SubscriptionMeta\n      : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta;\n\n    // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n    const startStack = new Error().stack as string;\n    const queryId = opts?.queryId || `smQuery${queryIdx++}`;\n    const {\n      queryGQL,\n      queryRecord,\n      subscriptionConfigs,\n    } = convertQueryDefinitionToQueryInfo({\n      queryDefinitions,\n      queryId,\n    });\n\n    opts.onQueryInfoConstructed &&\n      opts.onQueryInfoConstructed({ queryGQL, queryId });\n\n    function getError(error: any) {\n      if (opts.onError) {\n        return error;\n      } else {\n        // https://pavelevstigneev.medium.com/capture-javascript-async-stack-traces-870d1b9f6d39\n        error.stack =\n          error.stack +\n          '\\n' +\n          startStack.substring(startStack.indexOf('\\n') + 1);\n\n        return error;\n      }\n    }\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    if (!token) {\n      const error = getError(\n        new Error(\n          `No token registered with the name \"${tokenName}\".\\n` +\n            'Please register this token prior to using it with sm.setToken(tokenName, { token })) '\n        )\n      );\n      if (opts.onError) {\n        opts.onError(error);\n        return { data: {}, unsub, error } as TSubscriptionOpts extends {\n          skipInitialQuery: true;\n        }\n          ? SubscriptionMeta\n          : { data: QueryDataReturn<TQueryDefinitions> } & SubscriptionMeta;\n      } else {\n        throw error;\n      }\n    }\n\n    const queryManager = new smJSInstance.SMQueryManager(queryRecord);\n\n    function updateQueryManagerWithSubscriptionMessage(data: {\n      message: Record<string, any>;\n      subscriptionConfig: SubscriptionConfig;\n    }) {\n      let node;\n      let operation;\n      try {\n        node = data.subscriptionConfig.extractNodeFromSubscriptionMessage(\n          data.message\n        );\n        operation = data.subscriptionConfig.extractOperationFromSubscriptionMessage(\n          data.message\n        );\n        queryManager.onSubscriptionMessage({\n          node,\n          operation,\n          queryId: queryId,\n          subscriptionAlias: data.subscriptionConfig.alias,\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error applying subscription message\\n${e}`)\n        );\n\n        if (opts.onError) {\n          opts.onError(error);\n        } else {\n          console.error(error);\n        }\n      }\n    }\n\n    let subscriptionCancellers: Array<SubscriptionCanceller> = [];\n    // Subscriptions are initialized immediately, rather than after the query resolves, to prevent an edge case where an update to a node happens\n    // while the data for that node is being transfered from SM to the client. This would result in a missed update.\n    // However, we must be careful to not call opts.onData with any subscription messages before the query resolves,\n    // because a subscription message only includes info about the node that changed, not all data being subscribed to,\n    // which means the consumer of this API would receive and incomplete data set in this edge case.\n    // This flag prevents that, by short-circuiting opts.onData in subscription messages, if the query has not resolved\n    let mustAwaitQuery = !opts.skipInitialQuery;\n    const messageQueue: Array<{\n      message: Record<string, any>;\n      subscriptionConfig: SubscriptionConfig;\n    }> = [];\n    function initSubs() {\n      try {\n        subscriptionCancellers = subscriptionConfigs.map(subscriptionConfig => {\n          return smJSInstance.gqlClient.subscribe({\n            gql: subscriptionConfig.gql,\n            token: token,\n            onMessage: message => {\n              if (mustAwaitQuery) {\n                messageQueue.push({ message, subscriptionConfig });\n                return;\n              }\n\n              updateQueryManagerWithSubscriptionMessage({\n                message,\n                subscriptionConfig,\n              });\n\n              // @TODO When called with skipInitialQuery, results should be null\n              // and we should simply expose a \"delta\" from the message\n              // probably don't need a query manager in that case either.\n              opts.onData({\n                results: queryManager.getResults() as QueryDataReturn<\n                  TQueryDefinitions\n                >,\n              });\n            },\n            onError: e => {\n              // Can never throw here. The dev consuming this would have no way of catching it\n              // To catch an error in a subscription they must provide onError\n              const error = getError(\n                new Error(`Error in a subscription message\\n${e}`)\n              );\n\n              if (opts.onError) {\n                opts.onError(error);\n              } else {\n                console.error(error);\n              }\n            },\n          });\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error initializating subscriptions\\n${e}`)\n        );\n\n        if (opts?.onError) {\n          opts.onError(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    function unsub() {\n      subscriptionCancellers.forEach(cancel => cancel());\n    }\n\n    initSubs();\n    opts.onSubscriptionInitialized && opts.onSubscriptionInitialized(unsub);\n    if (opts.skipInitialQuery) {\n      return { unsub } as ReturnType;\n    } else {\n      const query = generateQuerier({ smJSInstance, queryManager });\n      try {\n        // this query method will post its results to the queryManager declared above\n        await query(queryDefinitions, {\n          queryId: opts.queryId,\n          tokenName: opts.tokenName,\n          batched: opts.batched,\n        });\n      } catch (e) {\n        const error = getError(\n          new Error(`Error querying initial data set\\n${e}`)\n        );\n\n        if (opts?.onError) {\n          opts.onError(error);\n          return { data: {}, unsub, error } as ReturnType;\n        } else {\n          throw error;\n        }\n      }\n\n      if (mustAwaitQuery) {\n        mustAwaitQuery = false;\n        messageQueue.forEach(updateQueryManagerWithSubscriptionMessage);\n        messageQueue.length = 0;\n      }\n\n      const data = queryManager.getResults() as QueryDataReturn<\n        TQueryDefinitions\n      >;\n\n      opts.onData({ results: data as QueryDataReturn<TQueryDefinitions> });\n\n      return { data, unsub, error: null } as ReturnType;\n    }\n  };\n}\n","import { SMDataParsingException } from './exceptions';\nimport {\n  IDOProxy,\n  Maybe,\n  ISMJS,\n  ISMQueryManager,\n  QueryRecord,\n  BaseQueryRecordEntry,\n  RelationalQueryRecordEntry,\n} from './types';\n\ntype SMQueryManagerState = Record<\n  string, // the alias for this set of results\n  SMQueryManagerStateEntry\n>;\n\ntype SMQueryManagerStateEntry = {\n  // which id or ids represent the most up to date results for this alias, used in conjunction with proxyCache to build a returned data set\n  idsOrIdInCurrentResult: string | Array<string>;\n  proxyCache: SMQueryManagerProxyCache;\n};\n\ntype SMQueryManagerProxyCache = Record<\n  string, // id of the node\n  SMQueryManagerProxyCacheEntry\n>;\n\ntype SMQueryManagerProxyCacheEntry = {\n  proxy: IDOProxy;\n  relationalState: Maybe<SMQueryManagerState>;\n}; // the proxy for that DO and relational state from the query results/latest subscription message\n\nexport function createSMQueryManager(smJSInstance: ISMJS) {\n  /**\n   * SMQueryManager is in charge of\n   *\n   *    1) receiving data from an SM query and notifying the appropriate DO repositories\n   *    2) building proxies for those DOs\n   *    3) keeping a cache of those generated proxies so that we can update proxies on subscription messages, rather than generating new ones\n   *    4) handling incoming SM subscription messages and\n   *       4.1) notifying DO repositories with the data in those sub messages\n   *       4.2) build proxies for new DOs received + update relational data (recursively) for proxies that had been previously built\n   *    5) building the resulting data that is returned by useSMQuery from its cache of proxies\n   */\n  return class SMQueryManager implements ISMQueryManager {\n    public state: SMQueryManagerState = {};\n    public queryRecord: QueryRecord;\n\n    constructor(queryRecord: QueryRecord) {\n      this.queryRecord = queryRecord;\n    }\n\n    public onQueryResult(opts: { queryResult: any; queryId: string }) {\n      this.notifyRepositories({\n        data: opts.queryResult,\n        queryRecord: this.queryRecord,\n      });\n\n      this.state = this.getNewStateFromQueryResult(opts);\n    }\n\n    public onSubscriptionMessage(opts: {\n      node: Record<string, any>;\n      operation: {\n        action: 'UpdateNode' | 'DeleteNode' | 'InsertNode';\n        path: string;\n      };\n      queryId: string;\n      subscriptionAlias: string;\n    }) {\n      const { node, operation, subscriptionAlias } = opts;\n      const queryRecordEntryForThisSubscription = this.queryRecord[\n        subscriptionAlias\n      ];\n\n      if (operation.action === 'DeleteNode' && operation.path === node.id) {\n        const idsOrIdInCurrentResult = this.state[opts.subscriptionAlias]\n          .idsOrIdInCurrentResult;\n        if (Array.isArray(idsOrIdInCurrentResult)) {\n          this.state[\n            opts.subscriptionAlias\n          ].idsOrIdInCurrentResult = idsOrIdInCurrentResult.filter(\n            id => id !== node.id\n          );\n        }\n\n        return;\n      }\n\n      this.notifyRepositories({\n        data: {\n          [subscriptionAlias]: node,\n        },\n        queryRecord: {\n          [subscriptionAlias]: queryRecordEntryForThisSubscription,\n        },\n      });\n\n      this.updateProxiesAndStateFromSubscriptionMessage(opts);\n    }\n\n    /**\n     * Returns the current results based on received query results and subscription messages\n     */\n    getResults() {\n      return this.getResultsFromState(this.state);\n    }\n\n    /**\n     * Is used to build the overall results for the query, and also to build the relational results used by each proxy\n     * which is why \"state\" is a param here\n     */\n    public getResultsFromState(\n      state: SMQueryManagerState\n    ): Record<string, any> {\n      return Object.keys(state).reduce((resultsAcc, queryAlias) => {\n        const stateForThisAlias = state[queryAlias];\n        const idsOrId = stateForThisAlias.idsOrIdInCurrentResult;\n        resultsAcc[queryAlias] = Array.isArray(idsOrId)\n          ? idsOrId.map(id => stateForThisAlias.proxyCache[id].proxy)\n          : stateForThisAlias.proxyCache[idsOrId].proxy;\n\n        return resultsAcc;\n      }, {} as Record<string, any>);\n    }\n\n    /**\n     * Takes a queryRecord and the data that resulted from that query\n     * notifies the appropriate repositories so that DOs can be constructed or updated\n     */\n    public notifyRepositories(opts: {\n      data: Record<string, any>;\n      queryRecord: { [key: string]: BaseQueryRecordEntry };\n    }) {\n      Object.keys(opts.queryRecord).forEach(queryAlias => {\n        const dataForThisAlias = opts.data[queryAlias];\n\n        if (!dataForThisAlias) {\n          throw Error(\n            `notifyRepositories could not find resulting data for the alias \"${queryAlias}\" in the following queryRecord:\\n${JSON.stringify(\n              opts.queryRecord,\n              null,\n              2\n            )}\\nResulting data:\\n${JSON.stringify(opts.data, null, 2)}`\n          );\n        }\n\n        const nodeRepository = opts.queryRecord[queryAlias].def.repository;\n\n        if (Array.isArray(dataForThisAlias)) {\n          dataForThisAlias.flatMap(data => nodeRepository.onDataReceived(data));\n        } else {\n          nodeRepository.onDataReceived(dataForThisAlias);\n        }\n\n        const relationalQueries = opts.queryRecord[queryAlias].relational;\n\n        if (relationalQueries) {\n          Object.keys(relationalQueries).forEach(relationalAlias => {\n            const relationalDataForThisAlias = Array.isArray(dataForThisAlias)\n              ? dataForThisAlias.flatMap(\n                  (dataEntry: any) => dataEntry[relationalAlias]\n                )\n              : dataForThisAlias[relationalAlias];\n\n            if (relationalDataForThisAlias) {\n              const relationalQuery = relationalQueries[relationalAlias];\n\n              this.notifyRepositories({\n                data: {\n                  [relationalAlias]: relationalDataForThisAlias,\n                },\n                queryRecord: {\n                  [relationalAlias]: relationalQuery,\n                },\n              });\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Gets the initial state for this manager from the initial query results\n     *   does not execute on subscription messages\n     */\n    public getNewStateFromQueryResult(opts: {\n      queryResult: Record<string, any>;\n      queryId: string;\n    }): SMQueryManagerState {\n      return Object.keys(this.queryRecord).reduce(\n        (resultingStateAcc, queryAlias) => {\n          resultingStateAcc[queryAlias] = this.buildCacheEntry({\n            nodeData: opts.queryResult[queryAlias],\n            queryId: opts.queryId,\n            queryAlias,\n          });\n\n          return resultingStateAcc;\n        },\n        {} as SMQueryManagerState\n      );\n    }\n\n    public buildCacheEntry(opts: {\n      nodeData: Record<string, any> | Array<Record<string, any>>;\n      queryId: string;\n      queryAlias: string;\n      queryRecord?: { [key: string]: BaseQueryRecordEntry };\n    }): SMQueryManagerStateEntry {\n      const { nodeData, queryAlias } = opts;\n      const queryRecord = opts.queryRecord || this.queryRecord;\n      const { relational } = queryRecord[opts.queryAlias];\n\n      const buildRelationalStateForNode = (\n        node: Record<string, any>\n      ): Maybe<SMQueryManagerState> => {\n        if (!relational) return null;\n\n        return Object.keys(relational).reduce(\n          (relationalStateAcc, relationalAlias) => {\n            const relationalDataForThisAlias = node[relationalAlias];\n\n            if (relationalDataForThisAlias) {\n              return {\n                ...relationalStateAcc,\n                [relationalAlias]: this.buildCacheEntry({\n                  nodeData: relationalDataForThisAlias,\n                  queryId: opts.queryId,\n                  queryAlias: relationalAlias,\n                  queryRecord: relational,\n                }),\n              };\n            } else return relationalStateAcc;\n          },\n          {} as SMQueryManagerState\n        );\n      };\n\n      const buildProxyCacheEntryForNode = (\n        node: Record<string, any>\n      ): SMQueryManagerProxyCacheEntry => {\n        const relationalState = buildRelationalStateForNode(node);\n        const nodeRepository = queryRecord[queryAlias].def.repository;\n\n        const proxy = smJSInstance.DOProxyGenerator({\n          node: queryRecord[opts.queryAlias].def,\n          allPropertiesQueried: queryRecord[opts.queryAlias].properties,\n          relationalQueries: relational || null,\n          queryId: opts.queryId,\n          relationalResults: !relationalState\n            ? null\n            : this.getResultsFromState(relationalState),\n          do: nodeRepository.byId(node.id),\n        });\n\n        return {\n          proxy,\n          relationalState,\n        };\n      };\n\n      if (Array.isArray(opts.nodeData)) {\n        if ('id' in queryRecord[opts.queryAlias]) {\n          if (opts.nodeData[0] == null) {\n            throw new SMDataParsingException({\n              receivedData: opts.nodeData,\n              message: `Queried a node by id for the query with the id \"${opts.queryId}\" but received back an empty array`,\n            });\n          }\n\n          return {\n            idsOrIdInCurrentResult: opts.nodeData[0].id,\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\n\n              return proxyCacheAcc;\n            }, {} as SMQueryManagerProxyCache),\n          };\n        } else {\n          return {\n            idsOrIdInCurrentResult: opts.nodeData.map(node => node.id),\n            proxyCache: opts.nodeData.reduce((proxyCacheAcc, node) => {\n              proxyCacheAcc[node.id] = buildProxyCacheEntryForNode(node);\n\n              return proxyCacheAcc;\n            }, {} as SMQueryManagerProxyCache),\n          };\n        }\n      } else {\n        return {\n          idsOrIdInCurrentResult: opts.nodeData.id,\n          proxyCache: {\n            [(nodeData as { id: string }).id]: buildProxyCacheEntryForNode(\n              nodeData\n            ),\n          },\n        };\n      }\n    }\n\n    public updateProxiesAndStateFromSubscriptionMessage(opts: {\n      node: any;\n      queryId: string;\n      subscriptionAlias: string;\n    }) {\n      const { node, queryId, subscriptionAlias } = opts;\n      const queryRecordEntryForThisSubscription = this.queryRecord[\n        subscriptionAlias\n      ];\n      this.state[subscriptionAlias] = this.state[subscriptionAlias] || {};\n      const stateForThisAlias = this.state[subscriptionAlias];\n      const nodeId = node.id;\n      const { proxy, relationalState } =\n        stateForThisAlias.proxyCache[nodeId] || {};\n\n      if (proxy) {\n        const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\n          {\n            queryId,\n            proxy,\n            newRelationalData: this.getRelationalData({\n              queryRecord: queryRecordEntryForThisSubscription,\n              node: opts.node,\n            }),\n            relationalQueryRecord:\n              queryRecordEntryForThisSubscription.relational || null,\n            currentState: { proxy, relationalState },\n          }\n        );\n        stateForThisAlias.proxyCache[nodeId] = newCacheEntry;\n      } else {\n        const { proxyCache } = this.buildCacheEntry({\n          nodeData: node,\n          queryId,\n          queryAlias: subscriptionAlias,\n          queryRecord: this.queryRecord,\n        });\n\n        const newlyGeneratedProxy = proxyCache[node.id];\n\n        if (!newlyGeneratedProxy)\n          throw Error('Expected a newly generated proxy');\n\n        stateForThisAlias.proxyCache[nodeId] = proxyCache[node.id];\n      }\n\n      if ('id' in queryRecordEntryForThisSubscription) {\n        if ((stateForThisAlias.idsOrIdInCurrentResult as string) === nodeId) {\n          return;\n        }\n\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = nodeId;\n      } else {\n        if (\n          (\n            stateForThisAlias.idsOrIdInCurrentResult || ([] as Array<string>)\n          ).includes(nodeId)\n        )\n          return; // don't need to do anything if this id was already in the returned set\n\n        this.state[opts.subscriptionAlias].idsOrIdInCurrentResult = [\n          nodeId, // insert the new node at the start of the array\n          ...(this.state[opts.subscriptionAlias]\n            .idsOrIdInCurrentResult as Array<string>),\n        ];\n      }\n    }\n\n    public recursivelyUpdateProxyAndReturnNewCacheEntry(opts: {\n      queryId: string;\n      proxy: IDOProxy;\n      newRelationalData: Maybe<\n        Record<string, Array<Record<string, any> | Record<string, any>>>\n      >;\n      relationalQueryRecord: Maybe<Record<string, RelationalQueryRecordEntry>>;\n      currentState: SMQueryManagerProxyCacheEntry;\n    }): SMQueryManagerProxyCacheEntry {\n      const {\n        queryId,\n        proxy,\n        newRelationalData,\n        currentState,\n        relationalQueryRecord,\n      } = opts;\n      const { relationalState: currentRelationalState } = currentState;\n\n      const newRelationalState = !relationalQueryRecord\n        ? null\n        : Object.keys(relationalQueryRecord).reduce(\n            (relationalStateAcc, relationalAlias) => {\n              if (!newRelationalData || !newRelationalData[relationalAlias]) {\n                return relationalStateAcc;\n              }\n\n              const relationalDataForThisAlias =\n                newRelationalData[relationalAlias];\n              const queryRecordForThisAlias =\n                relationalQueryRecord[relationalAlias];\n\n              const currentStateForThisAlias = !currentRelationalState\n                ? null\n                : currentRelationalState[relationalAlias];\n\n              if (!currentStateForThisAlias) {\n                relationalStateAcc[relationalAlias] = this.buildCacheEntry({\n                  nodeData: relationalDataForThisAlias,\n                  queryId,\n                  queryAlias: relationalAlias,\n                  queryRecord: relationalQueryRecord,\n                });\n\n                return relationalStateAcc;\n              }\n\n              if (Array.isArray(relationalDataForThisAlias)) {\n                relationalStateAcc[relationalAlias] = relationalStateAcc[\n                  relationalAlias\n                ] || { proxyCache: {}, idsOrIdInCurrentResult: [] };\n\n                relationalDataForThisAlias.forEach(node => {\n                  const existingProxy =\n                    currentStateForThisAlias.proxyCache[node.id]?.proxy;\n\n                  if (!existingProxy) {\n                    const newCacheEntry = this.buildCacheEntry({\n                      nodeData: node,\n                      queryId: queryId,\n                      queryAlias: relationalAlias,\n                      queryRecord: relationalQueryRecord,\n                    });\n\n                    relationalStateAcc[relationalAlias] = {\n                      proxyCache: {\n                        ...relationalStateAcc[relationalAlias].proxyCache,\n                        [node.id]: newCacheEntry.proxyCache[node.id],\n                      },\n                      idsOrIdInCurrentResult: [\n                        ...(relationalStateAcc[relationalAlias]\n                          .idsOrIdInCurrentResult as Array<string>),\n                        node.id,\n                      ],\n                    };\n                  } else {\n                    const newCacheEntry = this.recursivelyUpdateProxyAndReturnNewCacheEntry(\n                      {\n                        queryId,\n                        proxy: existingProxy,\n                        newRelationalData: this.getRelationalData({\n                          queryRecord: queryRecordForThisAlias,\n                          node,\n                        }),\n                        relationalQueryRecord:\n                          queryRecordForThisAlias.relational || null,\n                        currentState:\n                          currentStateForThisAlias.proxyCache[node.id],\n                      }\n                    );\n\n                    relationalStateAcc[relationalAlias] = {\n                      proxyCache: {\n                        ...relationalStateAcc[relationalAlias].proxyCache,\n                        [node.id]: newCacheEntry,\n                      },\n                      idsOrIdInCurrentResult: [\n                        ...(relationalStateAcc[relationalAlias]\n                          .idsOrIdInCurrentResult as Array<string>),\n                        node.id,\n                      ],\n                    };\n                  }\n                });\n              } else {\n                throw Error(\n                  `Not implemented. ${JSON.stringify(\n                    relationalDataForThisAlias\n                  )}`\n                );\n              }\n\n              return relationalStateAcc;\n            },\n            {} as SMQueryManagerState\n          );\n\n      newRelationalState\n        ? proxy.updateRelationalResults(\n            this.getResultsFromState(newRelationalState)\n          )\n        : proxy.updateRelationalResults(null);\n\n      return {\n        proxy,\n        relationalState: newRelationalState,\n      };\n    }\n\n    public getRelationalData(opts: {\n      queryRecord: BaseQueryRecordEntry;\n      node: Record<string, any>;\n    }) {\n      return opts.queryRecord.relational\n        ? Object.keys(opts.queryRecord.relational).reduce(\n            (relationalDataAcc, relationalAlias) => {\n              relationalDataAcc[relationalAlias] = opts.node[relationalAlias];\n\n              return relationalDataAcc;\n            },\n            {} as Record<string, any>\n          )\n        : null;\n    }\n  };\n}\n","export function getMutationNameFromOperations(\n  operations: Array<{ name?: string }>,\n  fallback: string\n) {\n  const operationNames = operations\n    .filter(operation => 'name' in operation && !!operation.name)\n    .map(operation => {\n      if ('name' in operation) {\n        return operation.name;\n      } else {\n        throw Error('Expected an operation name here');\n      }\n    });\n\n  if (operationNames.length) {\n    return operationNames.join('__');\n  }\n\n  return fallback;\n}\n","import { EdgePermissions } from './types';\n\nexport function getEdgePermissionsString(permissions: EdgePermissions): string {\n  return `\n    view: ${permissions.view ? 'true' : 'false'},\n    edit: ${permissions.edit ? 'true' : 'false'},\n    manage: ${permissions.manage ? 'true' : 'false'},\n    terminate: ${permissions.terminate ? 'true' : 'false'},\n    addChild: ${permissions.addChild ? 'true' : 'false'}\n  `;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  CreateEdgeOperation,\n  CreateEdgeOpts,\n  CreateEdgesOperation,\n  EdgeProperties,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function createEdge(edge: CreateEdgeOpts): CreateEdgeOperation {\n  return {\n    type: 'createEdge',\n    ...edge,\n    smOperationName: 'AttachEdge',\n  };\n}\n\nexport function createEdges(\n  edges: CreateEdgesOperation['edges']\n): CreateEdgesOperation {\n  return {\n    type: 'createEdges',\n    smOperationName: 'AttachEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeCreateOperations(\n  operations: Array<CreateEdgeOperation | CreateEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'createEdge') {\n      return convertEdgeCreationOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'createEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeCreationOperationToMutationArguments(edge)\n      );\n    }\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeCreationOperationToMutationArguments(\n  opts: EdgeProperties & { name?: string }\n): DocumentNode {\n  const edge = `{\\ntype: \"${opts.type || 'access'}\",${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n  const name = getMutationNameFromOperations([opts], 'CreateEdge');\n\n  return gql`\n    mutation ${name} {\n        AttachEdge(\n            newSourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  DropEdgeOpts,\n  DropEdgeOperation,\n  DropEdgeProperties,\n  DropEdgesOperation,\n} from './types';\n\nexport function dropEdge(edge: DropEdgeOpts): DropEdgeOperation {\n  return {\n    type: 'dropEdge',\n    smOperationName: 'DropEdge',\n    ...edge,\n  };\n}\n\nexport function dropEdges(edges: Array<DropEdgeOpts>): DropEdgesOperation {\n  return {\n    type: 'dropEdges',\n    smOperationName: 'DropEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeDropOperations(\n  operations: Array<DropEdgeOperation | DropEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'dropEdge') {\n      return convertEdgeDropOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'dropEdges') {\n      return operation.edges.map(operation =>\n        convertEdgeDropOperationToMutationArguments({\n          ...operation.edge,\n          name: operation.name,\n        })\n      );\n    }\n\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeDropOperationToMutationArguments(\n  opts: DropEdgeProperties & { name?: string }\n): DocumentNode {\n  const name = getMutationNameFromOperations([opts], 'DropEdge');\n\n  return gql`\n    mutation ${name} {\n        DropEdge(\n            sourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edgeType: \"${opts.type || 'access'}\"\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  ReplaceEdgeOperation,\n  ReplaceEdgeOpts,\n  ReplaceEdgeProperties,\n  ReplaceEdgesOperation,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function replaceEdge(edge: ReplaceEdgeOpts): ReplaceEdgeOperation {\n  return {\n    type: 'replaceEdge',\n    smOperationName: 'ReplaceEdge',\n    ...edge,\n  };\n}\n\nexport function replaceEdges(\n  edges: Array<{\n    edge: ReplaceEdgeProperties & { name?: string };\n    onSuccess?: () => any;\n  }>\n): ReplaceEdgesOperation {\n  return {\n    type: 'replaceEdges',\n    smOperationName: 'ReplaceEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeReplaceOperations(\n  operations: Array<ReplaceEdgeOperation | ReplaceEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'replaceEdge') {\n      return convertEdgeReplaceOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'replaceEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeReplaceOperationToMutationArguments(edge)\n      );\n    }\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeReplaceOperationToMutationArguments(\n  opts: ReplaceEdgeProperties & { name?: string }\n): DocumentNode {\n  const name = getMutationNameFromOperations([opts], 'ReplaceEdge');\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n\n  return gql`\n    mutation ${name} {\n        ReplaceEdge(\n            currentSourceId: \"${opts.current}\"\n            newSourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { getMutationNameFromOperations } from '../getMutationNameFromOperations';\nimport {\n  EdgeProperties,\n  UpdateEdgeOperation,\n  UpdateEdgeOpts,\n  UpdateEdgesOperation,\n} from './types';\nimport { getEdgePermissionsString } from './utilities';\n\nexport function updateEdge(edge: UpdateEdgeOpts): UpdateEdgeOperation {\n  return {\n    type: 'updateEdge',\n    smOperationName: 'UpdateEdge',\n    ...edge,\n  };\n}\n\nexport function updateEdges(\n  edges: Array<{\n    edge: EdgeProperties & { name?: string };\n    onSuccess?: () => any;\n  }>\n): UpdateEdgesOperation {\n  return {\n    type: 'updateEdges',\n    smOperationName: 'UpdateEdge',\n    edges,\n  };\n}\n\nexport function getMutationsFromEdgeUpdateOperations(\n  operations: Array<UpdateEdgeOperation | UpdateEdgesOperation>\n): Array<DocumentNode> {\n  return operations.flatMap(operation => {\n    if (operation.type === 'updateEdge') {\n      return convertEdgeUpdateOperationToMutationArguments({\n        ...operation.edge,\n        name: operation.name,\n      });\n    } else if (operation.type === 'updateEdges') {\n      return operation.edges.map(({ edge }) =>\n        convertEdgeUpdateOperationToMutationArguments(edge)\n      );\n    }\n\n    throw Error(`Operation not recognized: \"${operation}\"`);\n  });\n}\n\nfunction convertEdgeUpdateOperationToMutationArguments(\n  opts: EdgeProperties & { name?: string }\n): DocumentNode {\n  const edge = `{\\ntype: \"${opts.type || 'access'}\", ${getEdgePermissionsString(\n    opts.permissions\n  )}}`;\n  const name = getMutationNameFromOperations([opts], 'UpdateEdge');\n\n  return gql`\n    mutation ${name} {\n        UpdateEdge(\n            sourceId: \"${opts.from}\"\n            targetId: \"${opts.to}\"\n            edge: ${edge}\n        )\n    }`;\n}\n","import { OBJECT_IDENTIFIER, OBJECT_PROPERTY_SEPARATOR } from '../smDataTypes';\nimport { Maybe } from '../types';\nimport { NodeData } from './types';\n\nexport const JSON_TAG = '__JSON__';\n\n/**\n * Takes the json representation of a node's data and prepares it to be sent to SM\n *\n * @param nodeData an object with arbitrary data\n * @returns stringified params ready for mutation\n */\nexport function convertNodeDataToSMPersistedData(nodeData: NodeData): string {\n  const parsedData = Object.entries(nodeData).reduce((acc, [key, value]) => {\n    if (key === 'childNodes') {\n      if (!Array.isArray(value)) {\n        throw new Error(`\"childNodes\" is supposed to be an array`);\n      }\n\n      return {\n        ...acc,\n        childNodes: value.map(item => convertNodeDataToSMPersistedData(item)),\n      };\n    }\n\n    return {\n      ...acc,\n      ...prepareForBE({ key, value }),\n    };\n  }, {} as Record<string, any>);\n\n  const stringified = Object.entries(parsedData).reduce(\n    (acc, [key, value], i) => {\n      if (i > 0) {\n        acc += '\\n';\n      }\n      if (key === 'childNodes') {\n        return acc + `${key}: [\\n{\\n${value.join('\\n}\\n{\\n')}\\n}\\n]`;\n      }\n      return acc + `${key}: ${value === null ? value : `\"${value}\"`}`;\n    },\n    ``\n  );\n\n  return stringified;\n}\n\nfunction escapeText(text: string): string {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n');\n}\n\nfunction prepareForBE(opts: {\n  key: string;\n  value: any;\n}): Record<string, Maybe<string>> {\n  if (opts.value === null) {\n    return { [opts.key]: null };\n  } else if (Array.isArray(opts.value)) {\n    return {\n      [opts.key]: `${JSON_TAG}${escapeText(JSON.stringify(opts.value))}`,\n    };\n  } else if (typeof opts.value === 'object') {\n    return prepareObjectForBE({ [opts.key]: opts.value });\n  } else if (typeof opts.value === 'string') {\n    return { [opts.key]: escapeText(opts.value) };\n  } else if (\n    typeof opts.value === 'boolean' ||\n    typeof opts.value === 'number'\n  ) {\n    if (typeof opts.value === 'number' && isNaN(opts.value)) {\n      return { [opts.key]: null };\n    }\n    return { [opts.key]: String(opts.value) };\n  } else {\n    throw Error(\n      `I don't yet know how to handle feData of type \"${typeof opts.value}\"`\n    );\n  }\n}\n\n/**\n * Takes an object node value and flattens it to be sent to SM\n *\n * @param obj an object with arbitrary data\n * @param parentKey if the value is a nested object, the key of the parent is passed in order to prepend it to the child key\n * @returns a flat object where the keys are of \"key__dot__value\" syntax\n *\n * For example:\n * ```typescript\n * const obj = {settings: {schedule: {day: 'Monday'} } }\n *  const result = prepareValueForBE(obj)\n * ```\n * The result will be:\n *  ```typescript\n *  {\n * settings: '__object__',\n * settings__dot__schedule: '__object__',\n * settings__dot__schedule__dot__day: 'Monday',\n * }\n * ```\n */\nfunction prepareObjectForBE(obj: Record<string, any>, parentKey?: string) {\n  return Object.entries(obj).reduce((acc, [key, val]) => {\n    const preparedKey = parentKey\n      ? `${parentKey}${OBJECT_PROPERTY_SEPARATOR}${key}`\n      : key;\n\n    if (typeof val === 'object' && val != null) {\n      acc[preparedKey] = OBJECT_IDENTIFIER;\n      acc = { ...acc, ...prepareObjectForBE(val, preparedKey) };\n    } else {\n      acc[preparedKey] = val;\n    }\n    return acc;\n  }, {} as Record<string, any>);\n}\n","import { gql } from '@apollo/client/core';\nimport { DocumentNode } from '../types';\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\nimport { NodeData } from './types';\n\nexport type CreateNodesOperation = {\n  type: 'createNodes';\n  smOperationName: 'CreateNodes';\n  nodes: Array<{\n    data: NodeData;\n    under?: string | Array<string>;\n    position?: number;\n    onSuccess?: (data: any) => any;\n  }>;\n  name?: string;\n};\n\nexport function createNodes(\n  operation: Omit<CreateNodesOperation, 'type' | 'smOperationName'>\n): CreateNodesOperation {\n  return {\n    type: 'createNodes',\n    smOperationName: 'CreateNodes',\n    ...operation,\n  };\n}\n\nexport type CreateNodeOperation = {\n  type: 'createNode';\n  smOperationName: 'CreateNodes';\n  data: NodeData;\n  under?: string | Array<string>;\n  name?: string;\n  position?: number;\n  onSuccess?: (data: any) => any;\n};\n\nexport function createNode(\n  operation: Omit<CreateNodeOperation, 'type' | 'smOperationName'>\n): CreateNodeOperation {\n  return {\n    type: 'createNode',\n    smOperationName: 'CreateNodes',\n    ...operation,\n  };\n}\n\nexport function getMutationsFromTransactionCreateOperations(\n  operations: Array<CreateNodeOperation | CreateNodesOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n  const allCreateNodeOperations: Array<{\n    data: NodeData;\n    under?: string | Array<string>;\n  }> = operations.flatMap(operation => {\n    if (operation.type === 'createNode') {\n      return operation;\n    } else if (operation.type === 'createNodes') {\n      return operation.nodes;\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  const name = getMutationNameFromOperations(operations, 'CreateNodes');\n\n  // For now, returns a single mutation\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\n  return [\n    gql`\n      mutation ${name} {\n        CreateNodes(\n          createOptions: [\n            ${allCreateNodeOperations\n              .map(convertCreateNodeOperationToCreateNodesMutationArguments)\n              .join('\\n')}\n          ] \n        ) {\n          id\n        }\n      }\n    `,\n  ];\n}\n\nfunction convertCreateNodeOperationToCreateNodesMutationArguments(operation: {\n  data: NodeData;\n  under?: string | Array<string>;\n}): string {\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation.data);\n  let mutationArgs: Array<string> = [\n    `node: {\n        ${dataToPersistInSM}\n      }`,\n  ];\n\n  if (operation.under) {\n    const value =\n      typeof operation.under === 'string'\n        ? `[\"${operation.under}\"]`\n        : `[\"${operation.under.join('\", \"')}\"]`;\n\n    mutationArgs.push(`underIds: ${value}`);\n  }\n\n  return `{\n    ${mutationArgs.join('\\n')}\n  }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\nimport { OBJECT_PROPERTY_SEPARATOR } from '..';\n\nimport { convertNodeDataToSMPersistedData } from './convertNodeDataToSMPersistedData';\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\nimport { NodeData } from './types';\n\nexport type UpdateNodesOperation = {\n  type: 'updateNodes';\n  smOperationName: 'UpdateNodes';\n  nodes: Array<{\n    data: { id: string } & NodeData;\n    position?: number;\n    onSuccess?: (data: any) => any;\n  }>;\n  name?: string;\n};\n\nexport function updateNodes(\n  operation: Omit<UpdateNodesOperation, 'type' | 'smOperationName'>\n): UpdateNodesOperation {\n  return {\n    type: 'updateNodes',\n    smOperationName: 'UpdateNodes',\n    ...operation,\n  };\n}\n\nexport type UpdateNodeOperation = {\n  type: 'updateNode';\n  smOperationName: 'UpdateNodes';\n  data: { id: string } & NodeData;\n  name?: string;\n  onSuccess?: (data: any) => any;\n};\n\nexport function updateNode(\n  operation: Omit<UpdateNodeOperation, 'type' | 'smOperationName'>\n): UpdateNodeOperation {\n  return {\n    type: 'updateNode',\n    smOperationName: 'UpdateNodes',\n    ...operation,\n  };\n}\n\nfunction getPropertiesToNull(object: Record<string, any>) {\n  return Object.entries(object).reduce((acc, [key, value]) => {\n    if (value == null) acc.push(key);\n    else if (!Array.isArray(value) && typeof value === 'object') {\n      acc.push(\n        ...getPropertiesToNull(value).map(\n          property => `${key}${OBJECT_PROPERTY_SEPARATOR}${property}`\n        )\n      );\n    }\n\n    return acc;\n  }, [] as Array<string>);\n}\n\nexport function getMutationsFromTransactionUpdateOperations(\n  operations: Array<UpdateNodeOperation | UpdateNodesOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n\n  const allUpdateNodeOperations: Array<{\n    id: string;\n  } & NodeData> = operations.flatMap(operation => {\n    if (operation.type === 'updateNode') {\n      return operation.data;\n    } else if (operation.type === 'updateNodes') {\n      return operation.nodes.map(({ data }) => data);\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  const name = getMutationNameFromOperations(operations, 'UpdateNodes');\n\n  const dropPropertiesMutations = allUpdateNodeOperations.reduce(\n    (acc, updateNodeOperation) => {\n      const propertiesToNull = getPropertiesToNull(updateNodeOperation);\n      if (propertiesToNull.length) {\n        acc.push(gql`\n        mutation {\n          DropProperties(\n            nodeIds: [\"${updateNodeOperation.id}\"]\n            propertyNames: [${propertiesToNull\n              .map(prop => `\"${prop}${OBJECT_PROPERTY_SEPARATOR}*\"`)\n              .join(',')}]\n  \n          )\n          { \n            id\n          }\n      }\n      `);\n      }\n      return acc;\n    },\n    [] as Array<DocumentNode>\n  );\n\n  // For now, returns a single mutation\n  // later, we may choose to alter this behavior, if we find performance gains in splitting the mutations\n  return [\n    gql`\n        mutation ${name} {\n          UpdateNodes(\n            nodes: [\n              ${allUpdateNodeOperations\n                .map(convertUpdateNodeOperationToUpdateNodesMutationArguments)\n                .join('\\n')}\n            ] \n          ) {\n            id\n          }\n        }\n      `,\n  ].concat(dropPropertiesMutations);\n}\n\nfunction convertUpdateNodeOperationToUpdateNodesMutationArguments(\n  operation: {\n    id: string;\n  } & NodeData\n): string {\n  const dataToPersistInSM = convertNodeDataToSMPersistedData(operation);\n\n  return `{\n      ${dataToPersistInSM}\n    }`;\n}\n","import { DocumentNode, gql } from '@apollo/client/core';\n\nimport { getMutationNameFromOperations } from './getMutationNameFromOperations';\n\nexport type DropNodeOperation = {\n  type: 'dropNode';\n  smOperationName: 'DropNode';\n  id: string;\n  name?: string;\n  onSuccess?: () => any;\n};\n\nexport function dropNode(\n  operation: Omit<DropNodeOperation, 'type' | 'smOperationName'>\n): DropNodeOperation {\n  return {\n    type: 'dropNode',\n    smOperationName: 'DropNode',\n    ...operation,\n  };\n}\n\nexport function getMutationsFromTransactionDropOperations(\n  operations: Array<DropNodeOperation>\n): Array<DocumentNode> {\n  if (!operations.length) return [];\n\n  const allDropNodeOperations: Array<{\n    id: string;\n    name?: string;\n  }> = operations.map(operation => {\n    if (operation.type === 'dropNode') {\n      return operation;\n    } else {\n      throw Error(`Operation not recognized: \"${operation}\"`);\n    }\n  });\n\n  return allDropNodeOperations.map(operation => {\n    const name = getMutationNameFromOperations([operation], 'DropNode');\n\n    return gql`\n      mutation ${name} {\n        DropNode(nodeId: \"${operation.id}\")\n      }    \n    `;\n  });\n}\n","import { DocumentNode } from '@apollo/client/core';\nimport { sortBy } from 'lodash';\nimport {\n  createEdge,\n  createEdges,\n  getMutationsFromEdgeCreateOperations,\n  dropEdge,\n  dropEdges,\n  getMutationsFromEdgeDropOperations,\n  replaceEdge,\n  replaceEdges,\n  getMutationsFromEdgeReplaceOperations,\n  updateEdge,\n  updateEdges,\n  getMutationsFromEdgeUpdateOperations,\n} from './edges';\nimport {\n  CreateEdgeOperation,\n  CreateEdgesOperation,\n  DropEdgeOperation,\n  DropEdgesOperation,\n  ReplaceEdgeOperation,\n  ReplaceEdgesOperation,\n  UpdateEdgeOperation,\n  UpdateEdgesOperation,\n} from './edges/types';\nimport {\n  createNode,\n  CreateNodeOperation,\n  createNodes,\n  CreateNodesOperation,\n  getMutationsFromTransactionCreateOperations,\n} from './create';\nimport {\n  getMutationsFromTransactionUpdateOperations,\n  updateNode,\n  UpdateNodeOperation,\n  updateNodes,\n  UpdateNodesOperation,\n} from './update';\nimport {\n  dropNode,\n  DropNodeOperation,\n  getMutationsFromTransactionDropOperations,\n} from './drop';\nimport { ISMJS } from '../types';\n\nexport interface ITransactionContext {\n  createNodes: typeof createNodes;\n  createNode: typeof createNode;\n  updateNodes: typeof updateNodes;\n  updateNode: typeof updateNode;\n  dropNode: typeof dropNode;\n  createEdge: typeof createEdge;\n  createEdges: typeof createEdges;\n  dropEdge: typeof dropEdge;\n  dropEdges: typeof dropEdges;\n  updateEdge: typeof updateEdge;\n  updateEdges: typeof updateEdges;\n  replaceEdge: typeof replaceEdge;\n  replaceEdges: typeof replaceEdges;\n}\n\ntype TIndexedOperationType = OperationType & { position?: number };\n\ntype TExecutionResult =\n  | Array<{\n      data: Record<string, any>;\n    }>\n  | Array<\n      Array<{\n        data: Record<string, any>;\n      }>\n    >;\n\ntype TOperationsByType = Record<\n  OperationType['type'],\n  Array<TIndexedOperationType>\n>;\n\nexport interface IPendingTransaction {\n  operations: TOperationsByType;\n  execute: () => Promise<any>;\n  callbackResult?: void | Promise<any> | Array<IPendingTransaction>;\n}\n\ntype OperationType =\n  | CreateNodeOperation\n  | CreateNodesOperation\n  | UpdateNodeOperation\n  | UpdateNodesOperation\n  | DropNodeOperation\n  | CreateEdgeOperation\n  | CreateEdgesOperation\n  | DropEdgeOperation\n  | DropEdgesOperation\n  | UpdateEdgeOperation\n  | UpdateEdgesOperation\n  | ReplaceEdgeOperation\n  | ReplaceEdgesOperation;\n\nexport function createTransaction(smJSInstance: ISMJS) {\n  /**\n   * A transaction allows developers to build groups of mutations that execute with transactional integrity\n   *   this means if one mutation fails, others are cancelled and any graph state changes are rolled back.\n   *\n   * The callback function can return a promise if the transaction requires some data fetching to build its list of operations.\n   */\n  return function transaction(\n    callback:\n      | ((context: ITransactionContext) => void | Promise<void>)\n      | Array<IPendingTransaction>,\n    opts?: { tokenName: string }\n  ) {\n    const operationsByType: TOperationsByType = {\n      createNode: [],\n      createNodes: [],\n      updateNode: [],\n      updateNodes: [],\n      dropNode: [],\n      createEdge: [],\n      createEdges: [],\n      dropEdge: [],\n      dropEdges: [],\n      replaceEdge: [],\n      replaceEdges: [],\n      updateEdge: [],\n      updateEdges: [],\n    };\n\n    /**\n     * Keeps track of the number of operations performed in this transaction (for operations that we need to provide callback data for).\n     * This is used to store each operation's order in the transaction so that we can map it to the response we get back from SM.\n     * SM responds with each operation in the order they were sent up.\n     */\n    let createOperationsCount = 0;\n    let updateOperationsCount = 0;\n\n    function pushOperation(operation: OperationType) {\n      if (!operationsByType[operation.type]) {\n        throw Error(\n          `No operationsByType array initialized for \"${operation.type}\"`\n        );\n      }\n      /**\n       * createNodes/updateNodes creates multiple nodes in a single operation,\n       * therefore we need to track the position of these nodes instead of just the position of the operation itself\n       */\n      if (operation.type === 'createNodes') {\n        createOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: createOperationsCount,\n          nodes: operation.nodes.map((node, idx) => {\n            return {\n              ...node,\n              position:\n                idx === 0\n                  ? createOperationsCount\n                  : (createOperationsCount += 1),\n            };\n          }),\n        });\n      } else if (operation.type === 'createNode') {\n        createOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: createOperationsCount,\n        });\n      } else if (operation.type === 'updateNodes') {\n        updateOperationsCount += 1;\n\n        operationsByType[operation.type].push({\n          ...operation,\n          position: updateOperationsCount,\n          nodes: operation.nodes.map((node, idx) => {\n            return {\n              ...node,\n              position:\n                idx === 0\n                  ? updateOperationsCount\n                  : (updateOperationsCount += 1),\n            };\n          }),\n        });\n      } else if (operation.type === 'updateNode') {\n        updateOperationsCount += 1;\n        operationsByType[operation.type].push({\n          ...operation,\n          position: updateOperationsCount,\n        });\n      } else {\n        operationsByType[operation.type].push(operation);\n      }\n    }\n\n    const context: ITransactionContext = {\n      createNode: opts => {\n        const operation = createNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createNodes: opts => {\n        const operation = createNodes(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateNode: opts => {\n        const operation = updateNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateNodes: opts => {\n        const operation = updateNodes(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropNode: opts => {\n        const operation = dropNode(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createEdge: opts => {\n        const operation = createEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      createEdges: opts => {\n        const operation = createEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropEdge: opts => {\n        const operation = dropEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      dropEdges: opts => {\n        const operation = dropEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateEdge: opts => {\n        const operation = updateEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      updateEdges: opts => {\n        const operation = updateEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      replaceEdge: opts => {\n        const operation = replaceEdge(opts);\n        pushOperation(operation);\n        return operation;\n      },\n      replaceEdges: opts => {\n        const operation = replaceEdges(opts);\n        pushOperation(operation);\n        return operation;\n      },\n    };\n\n    function sortMutationsByTransactionPosition<T>(\n      operations: Array<TIndexedOperationType>\n    ) {\n      return (sortBy(\n        operations,\n        operation => operation.position\n      ) as unknown) as T;\n    }\n\n    function getAllMutations(\n      operations: TOperationsByType\n    ): Array<DocumentNode> {\n      return [\n        ...getMutationsFromTransactionCreateOperations(\n          sortMutationsByTransactionPosition([\n            ...(operations.createNode as Array<\n              CreateNodeOperation & { position: number }\n            >),\n            ...(operations.createNodes as Array<\n              CreateNodesOperation & { position: number }\n            >),\n          ])\n        ),\n        ...getMutationsFromTransactionUpdateOperations(\n          sortMutationsByTransactionPosition([\n            ...(operations.updateNode as Array<\n              UpdateNodeOperation & { position: number }\n            >),\n            ...(operations.updateNodes as Array<\n              UpdateNodesOperation & { position: number }\n            >),\n          ])\n        ),\n        ...getMutationsFromTransactionDropOperations([\n          ...(operations.dropNode as Array<DropNodeOperation>),\n        ]),\n        ...getMutationsFromEdgeCreateOperations([\n          ...(operations.createEdge as Array<CreateEdgeOperation>),\n          ...(operations.createEdges as Array<CreateEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeDropOperations([\n          ...(operations.dropEdge as Array<DropEdgeOperation>),\n          ...(operations.dropEdges as Array<DropEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeReplaceOperations([\n          ...(operations.replaceEdge as Array<ReplaceEdgeOperation>),\n          ...(operations.replaceEdges as Array<ReplaceEdgesOperation>),\n        ]),\n        ...getMutationsFromEdgeUpdateOperations([\n          ...(operations.updateEdge as Array<UpdateEdgeOperation>),\n          ...(operations.updateEdges as Array<UpdateEdgesOperation>),\n        ]),\n      ];\n    }\n\n    const tokenName = opts?.tokenName || 'default';\n    const token = smJSInstance.getToken({ tokenName });\n\n    /**\n     * Group operations by their SM operation name, sorted by position if applicable\n     */\n    function groupBySMOperationName(operations: TOperationsByType) {\n      const result = Object.entries(operations).reduce(\n        (acc, [_, operations]) => {\n          operations.forEach(\n            (operation: TIndexedOperationType | OperationType) => {\n              if (acc.hasOwnProperty(operation.smOperationName)) {\n                acc[operation.smOperationName] = [\n                  ...acc[operation.smOperationName],\n                  operation,\n                ];\n              } else {\n                acc[operation.smOperationName] = [operation];\n              }\n            }\n          );\n          return acc;\n        },\n        {} as Record<string, Array<any>>\n      );\n\n      Object.entries(result).forEach(([smOperationName, operations]) => {\n        result[smOperationName] = sortBy(\n          operations,\n          operation => operation.position\n        );\n      });\n\n      return result;\n    }\n\n    if (Array.isArray(callback)) {\n      return transactionGroup(callback);\n    }\n\n    const result = callback(context);\n\n    function handleSuccessCallbacks(opts: {\n      executionResult: TExecutionResult;\n      operationsByType: TOperationsByType;\n    }) {\n      const { executionResult, operationsByType } = opts;\n\n      const operationsBySMOperationName = groupBySMOperationName(\n        operationsByType\n      );\n\n      /**\n       * Loop through the operations, map the operation to each result sent back from SM,\n       * then pass the result into the callback if it exists\n       */\n      const executeCallbacksWithData = (executionResult: TExecutionResult) => {\n        executionResult.forEach(\n          (\n            result:\n              | {\n                  data: Record<string, any>;\n                }\n              | {\n                  data: Record<string, any>;\n                }[]\n          ) => {\n            // if executionResult is 2d array\n            if (Array.isArray(result)) {\n              executeCallbacksWithData(result);\n            } else {\n              const resultData = result.data;\n\n              Object.entries(operationsBySMOperationName).forEach(\n                ([smOperationName, operations]) => {\n                  if (resultData.hasOwnProperty(smOperationName)) {\n                    operations.forEach(operation => {\n                      // we only need to gather the data for node create/update operations\n                      if (\n                        smOperationName === 'CreateNodes' ||\n                        smOperationName === 'UpdateNodes'\n                      ) {\n                        const groupedResult = resultData[smOperationName];\n                        // for createNodes, execute callback on each individual node rather than top-level operation\n                        if (operation.hasOwnProperty('nodes')) {\n                          operation.nodes.forEach((node: any) => {\n                            if (node.hasOwnProperty('onSuccess')) {\n                              const operationResult =\n                                groupedResult[node.position - 1];\n\n                              node.onSuccess(operationResult);\n                            }\n                          });\n                        } else if (operation.hasOwnProperty('onSuccess')) {\n                          const operationResult =\n                            groupedResult[operation.position - 1];\n                          operation.onSuccess(operationResult);\n                        }\n                      }\n                    });\n                  }\n                }\n              );\n            }\n          }\n        );\n      };\n\n      executeCallbacksWithData(executionResult);\n\n      /**\n       * For all other operations, just invoke the callback with no args.\n       * Transactions will guarantee that all operations have succeeded, so this is safe to do\n       */\n      Object.entries(operationsBySMOperationName).forEach(\n        ([smOperationName, operations]) => {\n          if (\n            smOperationName !== 'CreateNodes' &&\n            smOperationName !== 'UpdateNodes'\n          ) {\n            operations.forEach(operation => {\n              if (operation.hasOwnProperty('onSuccess')) {\n                operation.onSuccess();\n              } else if (operation.hasOwnProperty('edges')) {\n                (operation.edges as CreateEdgesOperation['edges']).forEach(\n                  edgeOperation => {\n                    if (edgeOperation.hasOwnProperty('onSuccess')) {\n                      edgeOperation.onSuccess!();\n                    }\n                  }\n                );\n              }\n            });\n          }\n        }\n      );\n    }\n\n    async function execute() {\n      try {\n        if (typeof callback === 'function') {\n          if (result instanceof Promise) {\n            await result;\n          }\n        }\n        const mutations = getAllMutations(operationsByType);\n\n        const executionResult: TExecutionResult = await smJSInstance.gqlClient.mutate(\n          {\n            mutations,\n            token,\n          }\n        );\n\n        if (executionResult) {\n          handleSuccessCallbacks({\n            executionResult,\n            operationsByType,\n          });\n        }\n\n        return executionResult;\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    return {\n      operations: operationsByType,\n      execute,\n      callbackResult: result,\n    };\n\n    function transactionGroup(\n      transactions: Array<IPendingTransaction>\n    ): Omit<IPendingTransaction, 'callbackResult'> {\n      const asyncCallbacks = transactions\n        .filter(tx => tx.callbackResult instanceof Promise)\n        .map(({ callbackResult }) => callbackResult);\n\n      async function execute() {\n        try {\n          if (asyncCallbacks.length) {\n            await Promise.all(asyncCallbacks);\n          }\n\n          const allMutations = transactions.map(({ operations }) => {\n            return smJSInstance.gqlClient.mutate({\n              mutations: getAllMutations(operations),\n              token,\n            });\n          });\n\n          const executionResults: Array<TExecutionResult> = await Promise.all(\n            allMutations\n          );\n\n          if (executionResults) {\n            executionResults.forEach((result, idx) => {\n              handleSuccessCallbacks({\n                executionResult: result,\n                operationsByType: transactions[idx].operations,\n              });\n            });\n          }\n\n          return executionResults.flat();\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      return {\n        operations: operationsByType,\n        execute,\n      };\n    }\n  };\n}\n","import React from 'react';\nimport { SubscriptionCanceller, ISMJS, DocumentNode } from '../types';\ninterface ISMContextSubscription {\n  results?: any;\n  error?: any;\n  querying?: boolean;\n  unsub?: SubscriptionCanceller;\n  suspendPromise?: Promise<any>;\n  onResults?: (newResults: any) => void;\n  onError?: (newError: any) => void;\n  setQuerying?: (querying: boolean) => void;\n  queryInfo?: { queryGQL: DocumentNode; queryId: string };\n  lastQueryTimestamp?: number;\n}\n\ninterface ISMContext {\n  smJSInstance: ISMJS;\n  ongoingSubscriptionRecord: Record<string, ISMContextSubscription>;\n  updateSubscriptionInfo: (\n    subscriptionId: string,\n    subInfo: Partial<ISMContextSubscription>\n  ) => void;\n  scheduleCleanup: (subscriptionId: string) => void;\n  cancelCleanup: (subscriptionId: string) => void;\n}\n\nexport const SMContext = React.createContext<ISMContext>(\n  (undefined as unknown) as ISMContext\n);\n\nexport const SMProvider = (props: {\n  children: React.ReactNode;\n  smJS: ISMJS;\n  subscriptionTTLMs?: number;\n}) => {\n  const existingContext = React.useContext(SMContext);\n\n  if (existingContext) {\n    throw Error(\n      'Another instance of an SMProvider was already detected higher up the render tree.\\nHaving multiple instances of SMProviders is not supported and may lead to unexpected results.'\n    );\n  }\n\n  const ongoingSubscriptionRecord = React.useRef<\n    Record<string, ISMContextSubscription>\n  >({});\n  const cleanupTimeoutRecord = React.useRef<Record<string, NodeJS.Timeout>>({});\n\n  const updateSubscriptionInfo: ISMContext['updateSubscriptionInfo'] = React.useCallback(\n    (subscriptionId, subInfo) => {\n      ongoingSubscriptionRecord.current[subscriptionId] = {\n        ...ongoingSubscriptionRecord.current[subscriptionId],\n        ...subInfo,\n      };\n    },\n    []\n  );\n\n  const scheduleCleanup: ISMContext['scheduleCleanup'] = React.useCallback(\n    subscriptionId => {\n      function cleanup() {\n        const existingContextSubscription =\n          ongoingSubscriptionRecord.current[subscriptionId];\n        if (existingContextSubscription) {\n          existingContextSubscription.unsub &&\n            existingContextSubscription.unsub();\n          delete ongoingSubscriptionRecord.current[subscriptionId];\n        }\n      }\n\n      if (props.subscriptionTTLMs != null) {\n        cleanupTimeoutRecord.current[subscriptionId] = setTimeout(\n          cleanup,\n          props.subscriptionTTLMs\n        );\n      } else {\n        cleanup();\n      }\n    },\n    [props.subscriptionTTLMs]\n  );\n\n  const cancelCleanup: ISMContext['cancelCleanup'] = React.useCallback(\n    subscriptionId => {\n      clearTimeout(cleanupTimeoutRecord.current[subscriptionId]);\n    },\n    []\n  );\n\n  return (\n    <SMContext.Provider\n      value={{\n        smJSInstance: props.smJS,\n        ongoingSubscriptionRecord: ongoingSubscriptionRecord.current,\n        updateSubscriptionInfo,\n        scheduleCleanup,\n        cancelCleanup,\n      }}\n    >\n      {props.children}\n    </SMContext.Provider>\n  );\n};\n","import React from 'react';\nimport { convertQueryDefinitionToQueryInfo } from '../queryDefinitionAdapters';\nimport { QueryDefinitions, QueryDataReturn } from '../types';\n\nimport { SMContext } from './context';\n\nexport function useSubscription<TQueryDefinitions extends QueryDefinitions>(\n  queryDefinitions: TQueryDefinitions\n): { data: QueryDataReturn<TQueryDefinitions>; querying: boolean } {\n  const smContext = React.useContext(SMContext);\n\n  if (!smContext) {\n    throw Error(\n      'You must wrap your app with an SMProvider before using useSubscription.'\n    );\n  }\n\n  const obj = { stack: '' };\n  Error.captureStackTrace(obj, useSubscription);\n  if (obj.stack === '') {\n    // Should be supported in all browsers, but better safe than sorry\n    throw Error('Error.captureStackTrace not supported');\n  }\n  const subscriptionId = obj.stack.split('\\n')[1];\n  const preExistingContextForThisSubscription =\n    smContext.ongoingSubscriptionRecord[subscriptionId];\n\n  const [results, setResults] = React.useState<\n    QueryDataReturn<TQueryDefinitions> | undefined\n  >(preExistingContextForThisSubscription?.results);\n  const [error, setError] = React.useState<any>(\n    preExistingContextForThisSubscription?.error\n  );\n  const [querying, setQuerying] = React.useState<boolean>(\n    preExistingContextForThisSubscription?.querying != null\n      ? preExistingContextForThisSubscription?.querying\n      : true\n  );\n  React.useEffect(() => {\n    smContext.cancelCleanup(subscriptionId);\n    return () => {\n      smContext.scheduleCleanup(subscriptionId);\n    };\n  }, [smContext, subscriptionId]);\n\n  // We can not directly call \"setResults\" from this useState hook above within the subscriptions 'onData'\n  // because if this component unmounts due to fallback rendering then mounts again, we would be calling setResults on the\n  // state of the component rendered before the fallback occured.\n  // To avoid that, we keep a reference to the most up to date results setter in the subscription context\n  // and call that in \"onData\" instead.\n  smContext.updateSubscriptionInfo(subscriptionId, {\n    onResults: setResults,\n    onError: setError,\n    setQuerying: setQuerying,\n  });\n\n  const queryDefinitionHasBeenUpdated =\n    preExistingContextForThisSubscription?.queryInfo?.queryGQL != null &&\n    preExistingContextForThisSubscription.queryInfo.queryGQL !==\n      convertQueryDefinitionToQueryInfo({\n        queryDefinitions,\n        queryId: preExistingContextForThisSubscription.queryInfo.queryId,\n      }).queryGQL;\n  if (!preExistingContextForThisSubscription || queryDefinitionHasBeenUpdated) {\n    if (queryDefinitionHasBeenUpdated) {\n      preExistingContextForThisSubscription.unsub &&\n        preExistingContextForThisSubscription.unsub();\n    }\n\n    const queryTimestamp = new Date().valueOf();\n    setQuerying(true);\n    smContext.updateSubscriptionInfo(subscriptionId, {\n      querying: true,\n      lastQueryTimestamp: queryTimestamp,\n    });\n\n    const suspendPromise = smContext.smJSInstance\n      .subscribe(queryDefinitions, {\n        onData: ({ results: newResults }) => {\n          const contextForThisSub =\n            smContext.ongoingSubscriptionRecord[subscriptionId];\n          const thisQueryIsMostRecent =\n            contextForThisSub.lastQueryTimestamp === queryTimestamp;\n          if (thisQueryIsMostRecent) {\n            contextForThisSub.onResults &&\n              contextForThisSub.onResults(newResults);\n            smContext.updateSubscriptionInfo(subscriptionId, {\n              results: newResults,\n            });\n          }\n        },\n        onError: error => {\n          const contextForThisSub =\n            smContext.ongoingSubscriptionRecord[subscriptionId];\n          contextForThisSub.onError && contextForThisSub.onError(error);\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            error,\n          });\n        },\n        onSubscriptionInitialized: subscriptionCanceller => {\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            unsub: subscriptionCanceller,\n          });\n        },\n        onQueryInfoConstructed: queryInfo => {\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            queryInfo,\n          });\n        },\n      })\n      .finally(() => {\n        const contextForThisSub =\n          smContext.ongoingSubscriptionRecord[subscriptionId];\n        const thisQueryIsMostRecent =\n          contextForThisSub.lastQueryTimestamp === queryTimestamp;\n        if (thisQueryIsMostRecent) {\n          contextForThisSub.setQuerying && contextForThisSub.setQuerying(false);\n          smContext.updateSubscriptionInfo(subscriptionId, {\n            suspendPromise: undefined,\n            querying: false,\n          });\n        }\n      });\n\n    if (!preExistingContextForThisSubscription) {\n      smContext.updateSubscriptionInfo(subscriptionId, { suspendPromise });\n      throw suspendPromise;\n    } else {\n      return { data: results, querying } as {\n        data: QueryDataReturn<TQueryDefinitions>;\n        querying: boolean;\n      };\n    }\n  } else if (preExistingContextForThisSubscription.suspendPromise) {\n    throw preExistingContextForThisSubscription.suspendPromise;\n  } else if (error) {\n    throw error;\n  } else {\n    return { data: results, querying } as {\n      data: QueryDataReturn<TQueryDefinitions>;\n      querying: boolean;\n    };\n  }\n}\n","import {\n  ApolloClient,\n  InMemoryCache,\n  ApolloLink,\n  Observable,\n  split,\n  gql,\n} from '@apollo/client/core';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { HttpLink } from '@apollo/client/link/http';\nimport { BatchHttpLink } from '@apollo/client/link/batch-http';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { DocumentNode, ISMGQLClient } from './types';\n\nrequire('isomorphic-fetch');\n\ninterface IGetGQLClientOpts {\n  httpUrl: string;\n  wsUrl: string;\n}\n\nexport function getGQLCLient(gqlClientOpts: IGetGQLClientOpts) {\n  const wsLink = new WebSocketLink({\n    uri: gqlClientOpts.wsUrl,\n    options: {\n      reconnect: true,\n    },\n  });\n\n  const nonBatchedLink = new HttpLink({\n    uri: gqlClientOpts.httpUrl,\n  });\n\n  const queryBatchLink = split(\n    operation => operation.getContext().batchedQuery !== false,\n    new BatchHttpLink({\n      uri: gqlClientOpts.httpUrl,\n      batchMax: 30,\n      batchInterval: 50,\n    }),\n    nonBatchedLink\n  );\n\n  const mutationBatchLink = split(\n    operation => operation.getContext().batchedMutation,\n    new BatchHttpLink({\n      uri: gqlClientOpts.httpUrl,\n      // no batch max for explicitly batched mutations\n      // to ensure transactional integrity\n      batchMax: Number.MAX_SAFE_INTEGER,\n      batchInterval: 0,\n    }),\n    queryBatchLink\n  );\n\n  const requestLink = split(\n    // split based on operation type\n    ({ query }) => {\n      const definition = getMainDefinition(query);\n      return (\n        definition.kind === 'OperationDefinition' &&\n        definition.operation === 'subscription'\n      );\n    },\n    wsLink,\n    mutationBatchLink\n  );\n\n  function getContextWithToken(opts: { token: string }) {\n    return {\n      headers: {\n        Authorization: `Bearer ${opts.token}`,\n      },\n    };\n  }\n\n  function authenticateSubscriptionDocument(opts: {\n    gql: DocumentNode;\n    token: string;\n  }) {\n    const documentBody = opts.gql.loc?.source.body;\n\n    if (!documentBody) {\n      throw new Error('No documentBody found');\n    }\n\n    const operationsThatRequireToken = [\n      'GetChildren',\n      'GetReferences',\n      'GetNodes',\n      'GetNodesNew',\n      'GetNodesById',\n    ];\n\n    if (\n      operationsThatRequireToken.some(operation =>\n        documentBody?.includes(`${operation}(`)\n      )\n    ) {\n      let documentBodyWithAuthTokensInjected = documentBody;\n\n      operationsThatRequireToken.forEach(operation => {\n        documentBodyWithAuthTokensInjected = documentBodyWithAuthTokensInjected.replace(\n          new RegExp(operation + `\\\\((.*)\\\\)`, 'g'),\n          `${operation}($1, authToken: \"${opts.token}\")`\n        );\n      });\n\n      return gql(documentBodyWithAuthTokensInjected);\n    }\n\n    return opts.gql;\n  }\n\n  const authLink = new ApolloLink(\n    (operation, forward) =>\n      new Observable(observer => {\n        let handle: ZenObservable.Subscription;\n        Promise.resolve(operation)\n          .then(() => {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n\n        return () => {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n\n  const baseClient = new ApolloClient({\n    link: ApolloLink.from([authLink, requestLink]),\n    cache: new InMemoryCache(),\n    defaultOptions: {\n      watchQuery: {\n        fetchPolicy: 'no-cache',\n        errorPolicy: 'ignore',\n      },\n      query: {\n        fetchPolicy: 'no-cache',\n        errorPolicy: 'all',\n      },\n    },\n  });\n\n  const gqlClient: ISMGQLClient = {\n    query: async opts => {\n      const { data } = await baseClient.query({\n        query: opts.gql,\n        context: {\n          batchedQuery: opts.batched != null ? opts.batched : true,\n          ...getContextWithToken({ token: opts.token }),\n        },\n      });\n\n      return data;\n    },\n    subscribe: opts => {\n      const subscription = baseClient\n        .subscribe({\n          query: authenticateSubscriptionDocument(opts),\n        })\n        .subscribe({\n          next: message => {\n            if (!message.data)\n              opts.onError(\n                new Error(`Unexpected message structure.\\n${message}`)\n              );\n            else opts.onMessage(message.data);\n          },\n          error: opts.onError,\n        });\n\n      return () => subscription.unsubscribe();\n    },\n    mutate: async opts => {\n      return await Promise.all(\n        opts.mutations.map(mutation =>\n          baseClient.mutate({\n            mutation,\n            context: {\n              batchedMutation: true,\n              ...getContextWithToken({ token: opts.token }),\n            },\n          })\n        )\n      );\n    },\n  };\n\n  return gqlClient;\n}\n","import { getGQLCLient } from './gqlClient';\nimport { SMConfig } from './types';\n\nexport function getDefaultConfig(): SMConfig {\n  return {\n    gqlClient: getGQLCLient({\n      httpUrl: 'https://saasmaster.dev02.tt-devs.com/playground/..',\n      wsUrl: 'wss://saasmaster.dev02.tt-devs.com/',\n    }),\n  };\n}\n","import { createDOFactory } from './DO';\nimport { createDOProxyGenerator } from './DOProxyGenerator';\nimport { RepositoryFactory } from './Repository';\nimport { generateQuerier, generateSubscriber } from './smQueriers';\nimport { createSMQueryManager } from './SMQueryManager';\nimport { createTransaction } from './transaction/transaction';\nimport {\n  ISMJS,\n  SMConfig,\n  ISMData,\n  SMDataDefaultFn,\n  NodeRelationalQueryBuilderRecord,\n  NodeMutationFn,\n  NodeDefArgs,\n  ISMNode,\n} from './types';\n\nexport * from './smDataTypes';\nexport * from './react';\nexport * from './config';\n\nexport class SMJS implements ISMJS {\n  public gqlClient: ISMJS['gqlClient'];\n  public plugins: ISMJS['plugins'];\n  public query: ISMJS['query'];\n  public subscribe: ISMJS['subscribe'];\n  public SMQueryManager: ISMJS['SMQueryManager'];\n  public transaction: ISMJS['transaction'];\n  public tokens: Record<string, string> = {};\n  public DOFactory: ISMJS['DOFactory'];\n  public DOProxyGenerator: ISMJS['DOProxyGenerator'];\n\n  constructor(config: SMConfig) {\n    this.gqlClient = config.gqlClient;\n    this.plugins = config.plugins;\n    this.query = generateQuerier({ smJSInstance: this });\n    this.subscribe = generateSubscriber(this);\n    this.DOProxyGenerator = createDOProxyGenerator(this);\n    this.DOFactory = createDOFactory(this);\n    this.SMQueryManager = createSMQueryManager(this);\n    this.transaction = createTransaction(this);\n  }\n\n  public def<\n    TNodeData extends Record<string, ISMData | SMDataDefaultFn>,\n    TNodeComputedData extends Record<string, any> = {},\n    TNodeRelationalData extends NodeRelationalQueryBuilderRecord = {},\n    TNodeMutations extends Record<\n      string,\n      /*NodeMutationFn<TNodeData, any>*/ NodeMutationFn\n    > = {}\n  >(\n    def: NodeDefArgs<\n      TNodeData,\n      TNodeComputedData,\n      TNodeRelationalData,\n      TNodeMutations\n    >\n  ): ISMNode<\n    TNodeData,\n    TNodeComputedData,\n    TNodeRelationalData,\n    TNodeMutations\n  > {\n    const DOClass = this.DOFactory(def);\n\n    return {\n      _isSMNodeDef: true,\n      do: DOClass,\n      repository: RepositoryFactory({ def, DOClass }),\n      type: def.type,\n      smData: def.properties,\n      smComputed: def.computed,\n      smRelational: def.relational,\n      smMutations: def.mutations,\n    };\n  }\n\n  public getToken(opts: { tokenName: string }): string {\n    return this.tokens[opts.tokenName];\n  }\n\n  public setToken(opts: { tokenName: string; token: string }): void {\n    this.tokens[opts.tokenName] = opts.token;\n  }\n}\n"],"names":["SMNotUpToDateException","opts","propName","nodeType","queryId","Error","SMNotUpToDateInComputedException","computedPropName","SMNotCachedException","id","SMDataTypeException","dataType","value","SMDataTypeExplicitDefaultException","SMDataParsingException","message","JSON","stringify","receivedData","SMUnexpectedSubscriptionMessageException","exception","throwLocallyLogInProd","error","process","env","NODE_ENV","console","SM_DATA_TYPES","string","maybeString","number","maybeNumber","maybeBoolean","object","maybeObject","record","maybeRecord","array","maybeArray","SMData","type","parser","boxedValue","defaultValue","isOptional","String","_default","optional","parsed","Number","isNaN","boolean","undefined","val","parsedBoxedValue","smArray","SM_RELATIONAL_TYPES","byReference","children","reference","queryBuilderOpts","_smRelational","map","depth","OBJECT_PROPERTY_SEPARATOR","OBJECT_IDENTIFIER","queryDefinition","createDOFactory","smJSInstance","DOFactory","node","initialData","nodePropertiesOrSMData","isObjectType","getDefaultData","getDefaultFnValue","defaultSMData","defaultFn","isArrayType","Object","keys","reduce","acc","prop","propValue","isRecordType","version","restReceivedData","newVersion","newData","parseReceivedData","nodeProperties","properties","extendPersistedWithNewlyReceivedData","smData","_persistedData","extension","parsedData","getParsedData","persistedData","defaultData","_defaults","propNameForThisObject","defineProperty","configurable","enumerable","get","plugins","forEach","plugin","DO","onConstruct","DOInstance","parsedDataKey","initializeNodePropGettersAndSetters","initializeNodeComputedGetters","initializeNodeRelationalGetters","initializeNodeMutations","entries","property","getSMData","propExistsInInitialData","data","boxedValueSMProperty","key","smDataForThisProp","setObjectProp","setArrayProp","setPrimitiveValueProp","computedData","computed","computedProp","setComputedProp","computedFn","relationalData","relational","relationalProp","setRelationalProp","relationalQueryGetter","mutations","mutationName","bind","computedGetter","computedDecorator","createDOProxyGenerator","DOProxyGenerator","relationalResults","nodeSMComputed","smComputed","computedAccessors","computedKey","proxy","DOProxy","ProxyInstance","Proxy","getOwnPropertyDescriptor","target","allPropertiesQueried","includes","relationalQueries","newRelationalResults","results","Array","isArray","getNestedObjectWithNotUpToDateProtection","allCachedData","smDataForThisObject","parentObjectKey","e","objectToReturn","objectProp","name","isUpToDate","some","startsWith","JSON_TAG","NULL_TAG","parseJSONFromBE","jsonString","parse","replace","prepareValueForFE","entry","prepareForFE","beData","prepared","PROPERTIES_QUERIED_FOR_ALL_NODES","getRelationalQueryBuildersFromRelationalFns","relationaFns","getMapFnReturn","mapFnOpts","mapFn","getQueriedProperties","mapFnReturn","smRelational","isData","isRootLevel","push","nestedKey","getAllNodeProperties","getRelationalQueries","isComputed","relationalQuery","relationalQueryRecord","def","relationalQueriesWithinThisRelationalQuery","relationalType","idProp","length","getQueryRecordFromQueryDefinition","queryRecord","queryDefinitions","queryDefinitionsAlias","queriedProps","nodeDef","_isSMNodeDef","queryRecordEntry","ids","underIds","filter","getIdsString","join","getKeyValueFilterString","clause","getGetNodeOptions","options","getSubscriptionGetNodeOptions","under","getSpaces","numberOfSpaces","fill","getQueryPropertiesString","propsString","nestLevel","getRelationalQueryString","alias","relationalQueryRecordEntry","operation","depthString","getRootLevelQueryString","getQueryInfo","queryGQLString","getSanitizedQueryId","trim","subscriptionConfigs","subscriptionConfigsAcc","subscriptionName","operations","underId","gqlStrings","extractNodeFromSubscriptionMessage","subscriptionMessage","description","extractOperationFromSubscriptionMessage","gqlString","convertQueryDefinitionToQueryInfo","queryGQL","gql","subscriptionConfig","RepositoryFactory","Repository","onDataReceived","cached","parseDataFromSM","DOClass","byId","onNodeDeleted","oldStyleObjects","isDataStoredOnAllNodes","isDataStoredOnTheNode","split","isObjectData","isArrayData","receivedDataValue","smDataType","root","nests","getOnlyQueriedData","allDataReceived","dataPreviouslyParsedForThisObject","rootProp","nest","newStylePropertiesQueriedForThisObject","getDataForProp","rest","nextNest","remainingNests","queryIdx","generateQuerier","queryManager","getError","onError","stack","startStack","substring","indexOf","tokenName","token","getToken","gqlClient","query","batched","then","queryResult","qM","SMQueryManager","onQueryResult","getResults","onData","generateSubscriber","updateQueryManagerWithSubscriptionMessage","initSubs","unsub","subscriptionCancellers","cancel","subscribe","onMessage","mustAwaitQuery","messageQueue","onSubscriptionMessage","subscriptionAlias","onQueryInfoConstructed","skipInitialQuery","onSubscriptionInitialized","createSMQueryManager","notifyRepositories","state","getNewStateFromQueryResult","queryRecordEntryForThisSubscription","action","path","idsOrIdInCurrentResult","updateProxiesAndStateFromSubscriptionMessage","getResultsFromState","resultsAcc","queryAlias","stateForThisAlias","idsOrId","proxyCache","dataForThisAlias","nodeRepository","repository","flatMap","relationalAlias","relationalDataForThisAlias","dataEntry","resultingStateAcc","buildCacheEntry","nodeData","buildRelationalStateForNode","relationalStateAcc","buildProxyCacheEntryForNode","relationalState","proxyCacheAcc","nodeId","newCacheEntry","recursivelyUpdateProxyAndReturnNewCacheEntry","newRelationalData","getRelationalData","currentState","newlyGeneratedProxy","currentRelationalState","newRelationalState","queryRecordForThisAlias","currentStateForThisAlias","existingProxy","updateRelationalResults","relationalDataAcc","getMutationNameFromOperations","fallback","operationNames","getEdgePermissionsString","permissions","view","edit","manage","terminate","addChild","createEdge","edge","smOperationName","createEdges","edges","getMutationsFromEdgeCreateOperations","convertEdgeCreationOperationToMutationArguments","from","to","dropEdge","dropEdges","getMutationsFromEdgeDropOperations","convertEdgeDropOperationToMutationArguments","replaceEdge","replaceEdges","getMutationsFromEdgeReplaceOperations","convertEdgeReplaceOperationToMutationArguments","current","updateEdge","updateEdges","getMutationsFromEdgeUpdateOperations","convertEdgeUpdateOperationToMutationArguments","convertNodeDataToSMPersistedData","childNodes","item","prepareForBE","stringified","i","escapeText","text","prepareObjectForBE","obj","parentKey","preparedKey","createNodes","createNode","getMutationsFromTransactionCreateOperations","allCreateNodeOperations","nodes","convertCreateNodeOperationToCreateNodesMutationArguments","dataToPersistInSM","mutationArgs","updateNodes","updateNode","getPropertiesToNull","getMutationsFromTransactionUpdateOperations","allUpdateNodeOperations","dropPropertiesMutations","updateNodeOperation","propertiesToNull","convertUpdateNodeOperationToUpdateNodesMutationArguments","concat","dropNode","getMutationsFromTransactionDropOperations","allDropNodeOperations","createTransaction","transaction","callback","operationsByType","createOperationsCount","updateOperationsCount","pushOperation","position","idx","context","sortMutationsByTransactionPosition","sortBy","getAllMutations","groupBySMOperationName","result","hasOwnProperty","transactionGroup","handleSuccessCallbacks","executionResult","operationsBySMOperationName","executeCallbacksWithData","resultData","groupedResult","operationResult","onSuccess","edgeOperation","execute","Promise","mutate","callbackResult","transactions","asyncCallbacks","tx","all","allMutations","executionResults","flat","SMContext","React","createContext","SMProvider","props","existingContext","useContext","ongoingSubscriptionRecord","useRef","cleanupTimeoutRecord","updateSubscriptionInfo","useCallback","subscriptionId","subInfo","scheduleCleanup","cleanup","existingContextSubscription","subscriptionTTLMs","setTimeout","cancelCleanup","clearTimeout","Provider","smJS","useSubscription","smContext","captureStackTrace","preExistingContextForThisSubscription","useState","setResults","setError","querying","setQuerying","useEffect","onResults","queryDefinitionHasBeenUpdated","queryInfo","queryTimestamp","Date","valueOf","lastQueryTimestamp","suspendPromise","newResults","contextForThisSub","thisQueryIsMostRecent","subscriptionCanceller","require","getGQLCLient","gqlClientOpts","wsLink","WebSocketLink","uri","wsUrl","reconnect","nonBatchedLink","HttpLink","httpUrl","queryBatchLink","getContext","batchedQuery","BatchHttpLink","batchMax","batchInterval","mutationBatchLink","batchedMutation","MAX_SAFE_INTEGER","requestLink","definition","getMainDefinition","kind","getContextWithToken","headers","Authorization","authenticateSubscriptionDocument","documentBody","loc","source","body","operationsThatRequireToken","documentBodyWithAuthTokensInjected","RegExp","authLink","ApolloLink","forward","Observable","observer","handle","resolve","next","complete","unsubscribe","baseClient","ApolloClient","link","cache","InMemoryCache","defaultOptions","watchQuery","fetchPolicy","errorPolicy","subscription","mutation","getDefaultConfig","SMJS","config","smMutations","tokens","setToken"],"mappings":"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"}